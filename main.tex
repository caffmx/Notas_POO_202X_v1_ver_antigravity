%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%     LaTeX source code to approximate a NIST Technical report
%	  Instructions for authors: tinyurl.com/techpubsnist 
%	DOI watermark will be added on final PDF
% 	Developed by K. Miller, kmm5@nist.gov 
%	Last updated: 22-March-2019
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[12pt]{book}
\usepackage{amsmath}
\usepackage{amsfonts}   % if you want the fonts
\usepackage{amssymb}    % if you want extra symbols
\usepackage{graphicx}   % need for figures
\usepackage{wrapfig}

%\usepackage{xcolor}
\usepackage[table]{xcolor}

\usepackage{bm}
\usepackage{secdot}		
\usepackage{mathptmx}
\usepackage{textcomp}
\usepackage{float}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage[hang,flushmargin,bottom]{footmisc} % footnote format
%\usepackage{ifthen}
\usepackage{alltt}
\usepackage{hyperref}


\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{minted}
\usepackage{listings}
\lstset{
	literate={_}{_}1
}

\usepackage{hyperref}

\usepackage[margin=1.25in,bottom=1in,top=1in]{geometry}
\usepackage{fancyhdr}
%\usepackage[stable]{footmisc}

%para la tabla de stl
%\usepackage{listings}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{url}


\pagestyle{fancy}
\fancyhf{}
\rhead{\textcolor{blue}{\textbf{Notas de Programación Orientada a Objetos}} \\ \leftmark}

%\lfoot{Página \thepage}
\rfoot{\textcolor{blue}{Carlos Alberto Fernández y Fernández}}
\cfoot{\\ - \thepage \hspace{1pt} / \pageref{LastPage} -}
\renewcommand{\footrulewidth}{1pt}




%Para código de múltiples páginas
\usepackage{caption}
\setminted{
    linenos=true,
    autogobble,
}

\newenvironment{longlisting}{\captionsetup{type=listing}}{}
%%%%




\usepackage{titlesec}
\titleformat{\section}{\normalsize\bfseries}{\thesection.}{1em}{}	% required for heading numbering style
\titleformat*{\subsection}{\normalsize\bfseries}

\usepackage{tocloft}	% change typeset, titles, and format list of appendices/figures/tables
\renewcommand{\cftdot}{}	
\renewcommand{\contentsname}{Table of Contents}
\renewcommand{\cftpartleader}{\cftdotfill{\cftdotsep}} % for parts
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
%\renewcommand\cftbeforesecskip{\setlength{4pt}{}}
%\addtolength{\cftfignumwidth}{1em}
%\renewcommand{\cftfigpresnum}{\figurename\ }
%\addtolength{\cfttabnumwidth}{1em}
%\renewcommand{\cfttabpresnum}{\tablename\ }
\setlength{\cfttabindent}{0in}    %% adjust as you like
\setlength{\cftfigindent}{0in} 

\usepackage{enumitem}         % to control spacing between bullets/numbered lists

\usepackage[numbers,sort&compress]{natbib} % format bibliography 
\renewcommand{\bibsection}{}
\setlength{\bibsep}{0.0pt}

%\usepackage[hidelinks]{hyperref}
\hypersetup{
	colorlinks = true,
urlcolor ={blue},
citecolor = {.},
linkcolor = {.},
anchorcolor = {.},
filecolor = {.},
menucolor = {.},
runcolor = {.},
pdftitle={},
pdfsubject={},
pdfauthor={},
pdfkeywords={}
}
\urlstyle{same}

\usepackage{epstopdf} % converting EPS figure files to PDF

\usepackage{fancyhdr, lastpage}	% formatting document, calculating number of pages, formatting headers
\setlength{\topmargin}{-0.5in}
\setlength{\headheight}{39pt}
\setlength{\oddsidemargin}{0.25in}
\setlength{\evensidemargin}{0.25in}
\setlength{\textwidth}{6.0in}
\setlength{\textheight}{8.5in}

\usepackage{caption} % required for Figure labels
\captionsetup{font=small,labelfont=bf,figurename=Fig.,labelsep=period,justification=raggedright} 

%%%%%%%%%%% !!!!!! REQUIRED - FILL OUT METADATA HERE !!!!!!!! %%%%%%%%%%%%%%
%  	Report Number - fill in Report Number sent to you (see info below)
%   DOI Statement - fill in DOI sent to you 
%   Month Year - fill in Month and Year of Publication
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pubnumber}{2025}
\newcommand{\DOI}{https://doi.org/10.6028/NIST.HB.XXXX}
\newcommand{\monthyear}{Month Year}

\usemintedstyle{borland}


\newif\ifcpp
%\cpptrue % <- comment this line to switch between the two versions

\newif\ifjava
%\javatrue % <- comment this line to switch between the two versions

\newif\ifpython
%\pythontrue % <- comment this line to switch between the two versions

\newif\ifruby
%\rubytrue % <- comment this line to switch between the two versions

\newif\ifcsharp
%\csharptrue % <- comment this line to switch between the two versions

\newif\ifd
%\dtrue % <- comment this line to switch between the two versions

\newif\ifscala
%\scalatrue % <- comment this line to switch between the two versions

\newif\ifadvanced  % para temas AVANZADOS
%\advancedtrue % <- comment this line to switch between the two versions


\newif\ifdraft  % para notas EN DESARROLLO
%\drafttrue % <- comment this line to switch between the two versions



%\newboolean{cpp}
%\setboolean{cpp}{true}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   	BEGIN DOCUMENT 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
	\urlstyle{rm} % Format style of \url   

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Cover Page is REQUIRED and must contain the information 
%	displayed here, at a minimum. Additional artwork may be included 
%	(e.g., official project/conference logo, etc.).
%	Pub Number automated based on metadata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
\begin{flushright}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 	Automated based on metadata - delete if not applicable
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\LARGE{\textbf{POO Handbook \pubnumber}}\\
\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Title 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\Huge{\textbf{Notas de Programación Orientada a Objetos con}}\\

%\ifthenelse{\boolean{cpp}}{
%\Large{\textbf{C++}}\\
%}{}

\ifcpp
C++   
%\else
\fi

\ifjava
Java
\fi

\ifruby
Ruby
\fi

\ifpython
Python
\fi

\ifcsharp
C\#
\fi

\ifd
D
\fi

\ifscala
Scala
\fi




\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	Authors - add complete list of authors, affiliations will be 
%   added on title page
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
   \large \textbf{Carlos Alberto Fernández y Fernández}, \\ Instituto de Computación,\\ Universidad Tecnológica de la Mixteca.
   
\vfill


%%%%  CITA DANTE

\begin{flushright}
\vspace*{1cm}
\textit{Considerate la vostra semenza:\\
fatti non foste a viver come bruti,\\
ma per seguir virtute e canoscenza.}

\vspace{0.5cm}

Considerad vuestra estirpe:\\
hechos no fuisteis para vivir como brutos,\\
sino para perseguir virtud y conocimiento.

\vspace{0.5cm}

\textsc{Dante Alighieri}\\
\textit{La Divina Comedia, Infierno, Canto XXVI}
\end{center}

%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	The DOI is automated based on metadata.	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\normalsize This publication is available free of charge from:\\
%\DOI\\
%\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	NIST LOGO - keep as-is
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\includegraphics[width=0.15\linewidth]{imagenes/logoUTM.eps}\\ 
 
  
\end{flushright}
\end{titlepage}


\begin{titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Disclaimer/CODEN page - required
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flushright}
\footnotesize  This work is licensed under a \href{https://creativecommons.org/licenses/by-nc-sa/4.0/}{Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License}.\\ 

\vfill
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   This secton automated - do not change
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\normalsize \textbf{Universidad Tecnológica de la Mixteca \pubnumber\\ 
POO Handbook \pubnumber, \pageref{LastPage} páginas (\today)} \\
\vspace{12pt}
%\textbf{This publication is available free of charge from: \DOI}
\vfill
\end{flushright}
\end{titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Start front matter - page number starts with "i"
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section*{Foreword}
%\pagenumbering{roman}
%\normalsize Delete if not applicable\\
%\section*{Preface}
%\normalsize Delete if not applicable\\
%\section*{Abstract}
%\normalsize Required\\
%\section*{Key words}
%\normalsize Required, alphabetized, separated by semicolon, and end in a period.\\
%\pagebreak
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Table of Contents is required
% 	List of Tables & Figures required if more than 5 tables/figures
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\tableofcontents
\listoftables
\listoffigures

\renewcommand\listoflistingscaption{Índice de código fuente} 
\listoflistings


\end{center}
\pagebreak
%\section*{Glossary}
%Delete if not applicable\\
\pagebreak

\newcommand{\ejemplo}{\textcolor{blue}{Ejemplo:}}

%%%%%%%%%%%%%%%%%
\part{Introducción}

\chapter{Lenguajes y Ambientes sugeridos para desarrollo}
\label{sec:lengu}
\pagenumbering{arabic}

\section{Lenguajes de programación}

\normalsize Existe una infinidad de lenguajes de programación. Además de los cubiertos de manera general en este material podemos mencionar algunos como:

\begin{itemize}
\item \textbf{Groovy}. Es un lenguaje orientado a objetos y dinámico, similar a Python, Ruby, Perl y Smalltalk pero que es dinámicamente compilado hacia bytecodes de la máquina virtual de Java. 

    \includegraphics[scale=.4]{imagenes/groovy.png}

\begin{lstlisting}[language=Java, caption={Groovy: Hola Mundo}]
println "Hola Mundo"
\end{lstlisting}

\item \textbf{JRuby}. Es una implementación en Java del intérprete de Ruby. Su alta integración con Java permite completo acceso en los dos sentidos entre código Java y Ruby.

\begin{lstlisting}[language=Ruby, caption={JRuby: Hola Mundo}]
puts "Hola Mundo"
\end{lstlisting}

\item \textbf{Jython/JPython}. Una implementación de Python en Java. Programas en Jython pueden importar y usar clases en Java. 

    \includegraphics[scale=.5]{imagenes/jython.png}

\begin{lstlisting}[language=Python, caption={Jython: Hola Mundo}]
print("Hola Mundo")
\end{lstlisting}

\item \textbf{Kotlin}. Un lenguaje orientado a objetos para JVM, para aplicaciones del lado del servidor, Android y compilación a JavaScript.

\begin{lstlisting}[language=Java, caption={Kotlin: Hola Mundo}]
fun main() {
    println("Hola Mundo")
}
\end{lstlisting}

\item \textbf{IronPython}. Es una implementación de Python en .NET y Mono. Permite el uso de bibliotecas de .NET y una fácil interoperabilidad con lenguajes como C\#.

\begin{lstlisting}[language=Python, caption={IronPython: Hola Mundo}]
print("Hola Mundo desde .NET")
\end{lstlisting}

\item \textbf{Dart}. Es un lenguaje de programación de código abierto, desarrollado por Google, optimizado para la creación de aplicaciones web, móviles (con Flutter), de escritorio y del lado del servidor.

\begin{lstlisting}[language=Java, caption={Dart: Hola Mundo}]
void main() {
  print('Hola Mundo');
}
\end{lstlisting}

\item \textbf{Go}. Conocido también como Golang, es un lenguaje compilado y concurrente, desarrollado por Google. Es apreciado por su simplicidad y eficiencia en sistemas distribuidos.

\begin{lstlisting}[language=C, caption={Go: Hola Mundo}]
package main
import "fmt"
func main() {
    fmt.Println("Hola Mundo")
}
\end{lstlisting}

\item \textbf{Swift}. Creado por Apple, es un lenguaje multiparadigma para el desarrollo de aplicaciones en iOS, macOS, watchOS y tvOS. Se enfoca en seguridad y rendimiento.

\begin{lstlisting}[language=C, caption={Swift: Hola Mundo}]
print("Hola Mundo")
\end{lstlisting}

\item \textbf{Cobra}. Lenguaje inspirado en Python y Ruby, pero con tipos estáticos, generación de código para .NET/Mono, ligado dinámico, contratos y soporte de pruebas de unidad.

\begin{lstlisting}[caption={Cobra: Hola Mundo}]
class Hola
    def main
        print "Hola Mundo"
\end{lstlisting}

\item \textbf{Fantom}. Es un lenguaje portable y orientado a objetos, diseñado para ejecutarse en múltiples plataformas (JVM, .NET y JavaScript). Más información en: \url{http://fantom.org/}

\begin{lstlisting}[caption={Fantom: Hola Mundo}]
class Hola {
  static Void main() {
    echo("Hola Mundo")
  }
}
\end{lstlisting}

\item \textbf{Elixir}. Es un lenguaje funcional, concurrente y distribuido que se ejecuta en la máquina virtual de Erlang (BEAM). Es usado en sistemas tolerantes a fallos y aplicaciones web escalables.

\begin{lstlisting}[caption={Elixir: Hola Mundo}]
IO.puts "Hola Mundo"
\end{lstlisting}

\end{itemize}

En la tabla \ref{tab:comparacion_lenguajes} podemos ver una tabla con algunas características de los languajes antes mencionados.

\begin{table}[H]
\centering
\caption{Comparación de lenguajes de programación}
\label{tab:comparacion_lenguajes}
\begin{tabularx}{\textwidth}{|l|X|l|c|}
\hline
\textbf{Lenguaje} & \textbf{Paradigma principal} & \textbf{Plataforma base} & \textbf{Año de creación} \\
\hline
Groovy     & Orientado a objetos, dinámico & JVM (Java Virtual Machine) & 2003 \\
\hline
JRuby      & Orientado a objetos (Ruby) & JVM & 2001 \\
\hline
Jython     & Imperativo, orientado a objetos (Python) & JVM & 1997 \\
\hline
Kotlin     & Orientado a objetos y funcional & JVM, Android, compilación a JS & 2011 \\
\hline
IronPython & Imperativo, orientado a objetos (Python) & .NET, Mono & 2006 \\
\hline
Dart       & Orientado a objetos & Web, Flutter (móvil), escritorio & 2011 \\
\hline
Go (Golang)& Imperativo, concurrente, orientado a objetos ligero & Nativo (compilado) & 2009 \\
\hline
Swift      & Multiparadigma (OO, funcional) & iOS, macOS, watchOS, tvOS & 2014 \\
\hline
Cobra      & Orientado a objetos con contratos & .NET, Mono & 2006 \\
\hline
Fantom     & Orientado a objetos, multiplataforma & JVM, .NET, JavaScript & 2005 \\
\hline
Elixir     & Funcional, concurrente, distribuido & BEAM (Erlang VM) & 2011 \\
\hline
\end{tabularx}
\end{table}



\subsection{IDEs}

Los \textit{Entornos de Desarrollo Integrados} (IDE, por sus siglas en inglés) son herramientas que reúnen en una sola aplicación diversos componentes necesarios para programar: editores de código, compiladores, depuradores, asistentes gráficos y gestores de proyectos. Su objetivo es aumentar la productividad del desarrollador y facilitar el mantenimiento de proyectos grandes.

\subsubsection{Eclipse}
\normalsize Eclipse es desarrollado como un proyecto de código abierto lanzado en noviembre de 2001 por IBM, Object Technology International y otras compañías. El objetivo era desarrollar una plataforma abierta de desarrollo. Fue planeada para ser extendida mediante plug-ins. 

\includegraphics[scale=0.3]{imagenes/eclipse_logo.png}

Es desarrollada en Java, por lo que puede ejecutarse en un amplio rango de sistemas operativos. También incorpora facilidades para desarrollar en Java, aunque es posible instalarle plug-ins para otros lenguajes como C/C++, PHP, Ruby, Haskell, etc. Incluso antiguos lenguajes como Cobol tienen extensiones disponibles para Eclipse [1]:

\begin{itemize}
\item Eclipse + JDT = Java IDE
\item Eclipse + CDT = C/C++ IDE
\item Eclipse + PHP = PHP IDE
\item Eclipse + JDT + CDT + PHP = Java, C/C++, PHP IDE
\end{itemize}

Trabaja bajo “\textit{workbenchs}” que determinan la interfaz del usuario centrada alrededor del editor, vistas y perspectivas.

\includegraphics[scale=0.7]{imagenes/eclipse_IDE.png}

Los recursos son almacenados en el espacio de trabajo (workspace) el cual es un folder almacenado normalmente en el directorio de Eclipse. Es posible manejar diferentes áreas de trabajo.

Eclipse, sus componentes y documentación pueden ser obtenidos de: \url{www.eclipse.org}

\subsubsection{Mono}

\textit{Mono} es una alternativa de software libre patrocinada por Novell. Implementa principalmente un compilador para C\# y el \textit{Common Language Runtime} de .NET. Incluye un IDE y existen versiones para plataformas distintas a Windows.  Su IDE es \textbf{MonoDevelop}, el cual facilita la creación de aplicaciones multiplataforma.

\includegraphics[scale=0.5]{imagenes/mono_develop-logo.png} 

\subsubsection{NetBeans}

NetBeans es una plataforma de desarrollo y un IDE multilenguaje. Originalmente creado para desarrollo en Java y adquirido por Sun Microsystems. El IDE es actualmente de código abierto y disponible en \url{www.netbeans.org}.

\includegraphics[scale=0.3]{imagenes/netbeans_logo.png}

Creado en 1996 como un proyecto universitario en la Universidad Karlova (Praga), fue adoptado más tarde por Sun y posteriormente por Oracle.

\includegraphics[scale=0.3]{imagenes/netbeans_ide.png}

Soporta una variedad de lenguajes y tecnologías como C/C++, Java (SE, EE, ME), Ruby y PHP. NetBeans destaca por integrar de manera nativa un diseñador visual de interfaces gráficas (GUI Builder), útil en el desarrollo rápido de aplicaciones de escritorio.

\subsubsection{Visual Studio Code}

Visual Studio Code es un editor gratuito y de código abierto desarrollado por Microsoft.\footnote{\url{https://code.visualstudio.com/}}  

\includegraphics[scale=1.3]{imagenes/visualCode.jpeg}

Se caracteriza por ser ligero, extensible y multiplataforma (Windows, Linux, macOS). Algunas características principales son:  

\begin{itemize}
\item Interfaz de usuario intuitiva y personalizable.
\item Soporte integrado para depuración paso a paso.
\item Amplo ecosistema de extensiones para lenguajes, depuradores y control de versiones.
\item Integración nativa con Git y GitHub.
\item Autocompletado inteligente mediante \textit{IntelliSense}.
\end{itemize}

Hoy en día, Visual Studio Code es probablemente el editor más popular en la comunidad de desarrolladores.

\subsubsection{Algunos editores ligeros}

Si no se desea usar IDEs completos como Eclipse o NetBeans, existen editores ligeros que ofrecen rapidez y flexibilidad:

\begin{itemize}
\item Geany. \footnote{\url{https://www.geany.org/}}
\item Sublime Text. \footnote{\url{https://www.sublimetext.com/}}
\item Atom. \footnote{\url{https://atom.io/}}
\item Brackets. \footnote{\url{http://brackets.io/}}
\end{itemize}

Estos editores no incluyen compiladores, por lo que dependen de las herramientas de línea de comandos instaladas en el sistema.

\subsubsection{Otros ejemplos de frameworks}

Algunos de los principales frameworks usados para desarrollo Web son:

\begin{itemize}
\item \textbf{Ruby on Rails}. Framework gratuito para desarrollo de aplicaciones Web en Ruby. 
\includegraphics[scale=0.7]{imagenes/rails_logo.png}

\item \textbf{Merb}. Framework para desarrollo web en Ruby, diseñado con enfoque en concurrencia y modularidad.

\item \textbf{Django}. Framework open source para desarrollo de aplicaciones web con Python.  
\includegraphics[scale=0.5]{imagenes/django_logo.png}

\item \textbf{Grails}. Framework open source para el lenguaje Groovy, basado en la JVM.  

\includegraphics[scale=0.5]{imagenes/grails_logo.png}

\item \textbf{SproutCore}. Framework open source para aplicaciones web con JavaScript, orientado a experiencias similares a aplicaciones de escritorio. Fue utilizado por Apple en proyectos como MobileMe.

\item \textbf{Lift}. Framework para desarrollo web en Scala. Aprovecha la JVM y la biblioteca de Java, garantizando compatibilidad y escalabilidad.
\end{itemize}

\subsubsection{Comparación de IDEs}
En la tabla \ref{tab:comparacion_IDEs}, se presenta una breve comparación de los IDEs.
\begin{table}[H]
\centering
\scriptsize
\caption{Breve comparación de IDEs}
\label{tab:comparacion_IDEs}
\begin{tabularx}{\textwidth}{l p{5cm} l c}
\toprule
\textbf{IDE} & \textbf{Características principales} & \textbf{Lenguajes base} & \textbf{Licencia} \\
\midrule
Eclipse & Altamente extensible mediante plugins; multiplataforma; soporte a múltiples lenguajes & Java, C/C++, PHP, Ruby, entre otros & EPL (open source) \\
\midrule
MonoDevelop & Orientado a C\# y .NET multiplataforma; integración con GTK\# & C\#, F\# & MIT/X11 \\
\midrule
NetBeans & IDE completo con GUI Builder; soporte para múltiples lenguajes; enfoque educativo y empresarial & Java, C/C++, PHP, Ruby & Apache License 2.0 \\
\midrule
VS Code & Editor ligero; extensible; integración con Git; depuración integrada & Multilenguaje (a través de extensiones) & MIT \\
\midrule
Editores ligeros & Simples, rápidos, personalizables; requieren compiladores externos & Multilenguaje (sin integración nativa) & Variada \\
\bottomrule
\end{tabularx}
\end{table}


\section{Lenguajes estáticos y dinámicos}

Los lenguajes de programación pueden clasificarse, entre otros criterios, según su tipado en dos categorías principales: estáticos y dinámicos. La diferencia central radica en el momento en que se verifican los tipos de datos y la validez de las operaciones.

En los \textbf{lenguajes estáticos}, las variables y sus tipos se comprueban en tiempo de compilación. Esto permite detectar errores de tipo y de sintaxis antes de la ejecución, lo que conduce a programas más seguros y predecibles. Además, la vinculación de variables y funciones ocurre en esta fase, lo que suele mejorar la eficiencia del código resultante. Ejemplos comunes son \textit{C, C++, Java, Go y C\#}.

En contraste, los \textbf{lenguajes dinámicos} realizan la verificación en tiempo de ejecución. Los errores pueden aparecer solo cuando el programa se ejecuta, lo que implica mayor riesgo de fallos inesperados. No obstante, esta flexibilidad facilita cambios rápidos en el código y acelera el desarrollo. Lenguajes representativos son \textit{Python, JavaScript y Ruby}.

En síntesis, los lenguajes estáticos tienden a ser preferidos en proyectos grandes y críticos, donde la robustez es esencial, mientras que los dinámicos son útiles en entornos donde prima la agilidad y la experimentación.


%%%%%%%%%%
% ADVANCED
%%%%%%%%%%
\ifadvanced

\section{Documentación automática de código}
 La documentación automática de código es un proceso esencial en el desarrollo de software, donde se generan automáticamente descripciones y explicaciones del código fuente sin intervención manual por parte del programador.

La documentación automática es llevada a cabo por herramientas especializadas, las cuales analizan el código fuente y extraen información relevante sobre clases, métodos, variables y sus interacciones. Estos detalles se utilizan para generar documentos legibles y coherentes que proporcionan una guía comprensiva sobre la estructura y funcionamiento del programa.

Al utilizar la documentación automática, se logra mejorar la comprensión del código tanto para los propios desarrolladores como para otros colaboradores o usuarios potenciales del software. Esto es especialmente valioso en proyectos de gran envergadura, donde el código puede volverse complejo y difícil de entender con facilidad.

Además de facilitar la comprensión, la documentación automática también promueve una mayor eficiencia en el proceso de desarrollo y mantenimiento del software. Al tener documentación actualizada y generada automáticamente, los desarrolladores pueden ahorrar tiempo en la creación y actualización manual de la documentación.

Es importante resaltar que, si bien la documentación automática es una herramienta poderosa, no reemplaza por completo la documentación manual y las buenas prácticas de programación. Es fundamental que los programadores también incluyan comentarios significativos en el código para explicar decisiones de diseño, funcionalidades importantes y otras consideraciones relevantes que no pueden ser extraídas automáticamente.

La documentación automática de código es un proceso clave en el desarrollo de software, que utiliza herramientas especializadas para generar descripciones detalladas del código fuente sin intervención manual. Esta práctica mejora la comprensión del código, fomenta la eficiencia en el desarrollo y es especialmente útil en proyectos complejos. Sin embargo, se recomienda complementarla con comentarios manuales para brindar una documentación más completa y detallada.

Hay una variedad de herramientas disponibles para la documentación automática de código, y cada una tiene sus propias características y ventajas. Algunas de las herramientas más populares incluyen:

    \begin{itemize}
        \item Doxygen: una herramienta de código abierto que genera documentación HTML, XML, LaTeX y RTF a partir de comentarios en el código fuente.
        \item Javadoc: una herramienta de código abierto que genera documentación HTML a partir de comentarios en el código fuente de Java.
        \item Sphinx: una herramienta de código abierto que genera documentación HTML, LaTeX y RST a partir de comentarios en el código fuente.
    \end{itemize}

%%%%%%%%%%
% PYTHON
%%%%%%%%%%
%\ifthenelse{\boolean{cpp}}{

\ifpython

\subsection{Documentación automática de código en Python}

Python, al ser un lenguaje altamente utilizado y apreciado por su simplicidad y legibilidad, fomenta el uso de la documentación para facilitar la comprensión y el mantenimiento de proyectos de software. En este contexto, la documentación automática en Python se realiza mediante el uso de herramientas específicas, como \textit{Pydoc}, \textit{Sphinx}, o \textit{Doxygen}, que analizan el código fuente y extraen información relevante para generar documentación coherente.

\textit{Pydoc} es una herramienta incorporada en Python que permite generar documentación automática directamente desde el código fuente y los comentarios del programa.

\textit{Pydoc} analiza el código Python y busca \textit{docstrings}, que son cadenas de texto colocadas como primeras líneas de definiciones de módulos, clases, funciones y métodos. Estas \textit{docstrings} contienen información detallada sobre el propósito, la funcionalidad y el uso de cada componente del código. La herramienta \textit{Pydoc} extrae estas \textit{docstrings} y las convierte en una documentación estructurada y legible.

A continuación, se presenta un ejemplo de código documentado utilizando \textit{docstrings} y cómo \textit{Pydoc} lo utiliza para generar documentación automática:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
# Ejemplo de función para calcular el área de un círculo
def calcular_area_circulo(radio):
    """
    Calcula el área de un círculo dado su radio.

    Parámetros:
        radio (float): El radio del círculo.

    Retorna:
        float: El área del círculo.
    """
    area = 3.1416 * radio ** 2
    return area

\end{minted}

\caption{Ejemplo de documentación en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo, la función calcular \textit{area\_circulo} está documentada utilizando una \textit{docstring}. La \textit{docstring} describe claramente el propósito de la función, los parámetros que acepta y el tipo de valor que deben tener, así como el valor de retorno que se puede esperar. Estas descripciones son esenciales para que \textit{Pydoc} pueda generar una documentación detallada.

Para generar la documentación utilizando \textit{Pydoc}, se debe ejecutar el siguiente comando en la línea de comandos:

%one line
\mint[linenos=false]{console}| python -m pydoc nombre_del_archivo.py |

o directamente \textit{pydoc} :

\mint[linenos=false]{console}| pydoc -w nombre_del_archivo.py |


Para ver la documentación podemos dar el nombre del módulo o archivo:

\mint[linenos=false]{console}| pydoc nombre.py |

Inclusive ver localmente toda la documentación que tengamos disponible en nuestra localmente en nuestra computadora, lanzando un servidor temporal:

\mint[linenos=false]{console}| pydoc -p 8001 |

\textit{Pydoc} es una herramienta útil para generar documentación automática básica para el código Python. Sin embargo, es importante tener en cuenta que no es una herramienta de documentación completa.
\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


\fi
%%%%%%%%%%
% ADVANCED_END
%%%%%%%%%%




%\chapter{Introducción a lenguajes}

%%%%%%%%%%
% C++
%%%%%%%%%%
%\ifthenelse{\boolean{cpp}}{

\ifcpp



Los compiladores de C++ son normalmente compatibles con C, y se puede usar el de preferencia, pero si usan la terminal de linux se compila:

$g++ -o foo.o foo.cpp$

o, desde el compilador de C:

$gcc -o foo.o foo.cpp -lstdc++$

\chapter{Introducción a características de C++}

%\section{Origen}

Ahora comentaremos algunas características de C++ que no tienen que ver directamente con la programación orientada a objetos.

\section{Comentarios en C++}

	Los comentarios en C son:
\mint[linenos=false]{c}|/*  comentario en C     */|

	En C++ los comentarios pueden ser además de una sola línea:
\mint[linenos=false]{cpp}|// este es un comentario en C++|

Acabando el comentario al final de la línea, lo que quiere decir que el programador no se preocupa por cerrar el comentario.

\section{Flujo de entrada/salida}

En C, la salida y entrada estándar estaba dada por \textit{printf} y \textit{scanf} principalmente  (o funciones similares) para el manejo de los tipos da datos simples y las cadenas. En C++ se proporcionan a través de la biblioteca \textit{iostream}, la cual debe ser insertada a través de un \textit{\#include}. Las instrucciones son:

\begin{itemize}
\item \textit{cout}. Utiliza el flujo  salida estándar. Que se apoya del operador \(<<\), el cual se conoce como operador de inserción de flujo \textit{colocar en}.
\item \textit{cin}. Utiliza el flujo de entrada estándar.
Que se apoya del operador \(>>\) , conocido como operador de extracción de flujo \textit{obtener de}
\end{itemize}

Los operadores de inserción y de  extracción  de flujo no requieren cadenas de formato (\%s, \%f), ni especificadores de tipo. C++  reconoce de manera automática que tipos de datos son extraídos o introducidos.

	En el caso del operador de extracción \(>>\) no se requiere el operador de dirección \&.

	De tal forma un código de desplegado con \textit{printf} y \textit{scanf} de la forma (usando el área de nombres estándar):

\mint[linenos=false]{c}|printf("Número: ");|
\mint[linenos=false]{c}|scanf("\%d", &num);|
\mint[linenos=false]{c}|printf("El valor leído es: " \%d\n", num);|

Sería en C++ de la siguiente manera:

\mint[linenos=false]{cpp}|cout << "Número";|
\mint[linenos=false]{cpp}|cin >> num;|
\mint[linenos=false]{cpp}|cout << "El valor leído es: " << num << '\n';|

\section{Funciones en línea}

Las funciones en línea, se refiere a introducir un calificador \textit{inline}  a una función de manera que le sugiera al compilador que genere una copia del código de la función en lugar de la llamada.

Ayuda a reducir el número de llamadas a funciones reduciendo el tiempo de ejecución en algunos casos, pero en contraparte puede aumentar el tamaño del programa. 

A diferencia de las macros, las funciones \textit{inline} si incluyen verificación de tipos y son reconocidas por el depurador. Un depurador puede ayudar a encontrar un error de lógica resultado de usar una macro, pero no puede atribuir los errores a alguna macro.

Las funciones inline deben usarse sólo para funciones chicas que se usen frecuentemente.

El compilador desecha las solicitudes \textit{inline} para programas que incluyan un ciclo, un \textit{switch} o un \textit{goto}. Tampoco se consideran si no tienen \textit{return} (aunque no regresen valores) o si contienen variables de tipo \textit{static}. Además, lógicamente no genera una función \textit{inline} para funciones recursivas.

%tabla para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint{cpp}|inline <declaración de la función>|\\
\hline
\end{tabular}
\end{center}


\textcolor{blue}{Ejemplo:}

   \begin{minted}{cpp}
inline float suma (float a, float b) { 
       return a+b;
}

inline int max( int a, int b) {
		return (a > b) ? a :  b;
}
\end{minted}


Nota: Las funciones \textit{inline} tienen conflictos con los prototipos, así que deben declararse completas sin prototipo en el archivo .h. Además, si la función en línea hace uso de otra función,  en donde se expanda la función en línea debe tener los \textit{include} correspondientes a esas funciones utilizadas.

\section{Declaraciones de variables}

Mientras que en C, las declaraciones deben ir en la función antes de cualquier línea ejecutable, en C++ pueden ser introducidas en cualquier punto, con la condición lógica de que la declaración esté antes de la utilización de lo declarado.

En algunos compiladores podía declararse una variable en la sección de inicialización de la instrucción for, pero es incorrecto declarar una variable en la expresión condicional del \textit{while}, \textit{do-while}, \textit{for}, \textit{if} o \textit{switch}. El actual estándar de C++ no permite la declaración de variables dentro del for.
	
\textcolor{blue}{Ejemplo:}

    \begin{listing}[ht] 
    \begin{minted}
        [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}
#include <iostream>

int main() {
	int i=0;
	
	for (i=1; i<10; i++){
		int j=10;
		std::cout<<i<<" j: "<<j<<std::endl;
   	}

   	std::cout<<"\ni al salir del ciclo: "<<i; 
	
	return 0;
}
    \end{minted}
    \caption{Ejemplo declaración de variables}
    \label{listing:1}
    \end{listing}

O usando el área de nombres estándar:


    \begin{listing}[ht] 
    \begin{minted}
        [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}
#include <iostream>

using namespace std;

int main() {
	int i=0;
	
	for (i=1; i<10; i++){
		int j=10;
		cout<<i<<" j: "<<j<<endl;
   	}

   	cout<<"\ni al salir del ciclo: "<<i; 

	return 0;
}
    \end{minted}
    \caption{Ejemplo declaración de variables usando el área de nombres estándar}
    \label{listing:1}
    \end{listing}

El alcance de las variables en C++ es por bloques. Una variable es vista a partir de su declaración y hasta la llave “\}” del nivel en que se declaró. Lo cual quiere decir que las instrucciones anteriores a su declaración no pueden hacer uso de la variable, ni después de finalizado el bloque.

\section{Operador de resolución de alcance}

Se puede utilizar el operador de resolución de alcance \textbf{::} se refiere a una variable (variable, función, tipo, enumerador u objeto), con un alcance de archivo (variable global). No tiene alcance de bloque, aunque esten variables definidas con el mismo nombre en varios niveles de bloques.

	Esto le permite al identificador ser visible aún si el identificador se encuentra oculto.

\textcolor{blue}{Ejemplo:}
\begin{minted}{cpp}
float h;

void g(int h) {
	float a;
	int b;

	a=::h;	// a se inicializa con la variable global h

	b=h;	// b se inicializa con la variable local h
}  
\end{minted}

\section{Valores por default}
	Las funciones en C++ pueden tener valores por default. Estos valores son los que toman los parámetros en caso de que en una llamada a la función no se encuentren especificados.
	
	Los valores por omisión deben encontrarse en los parámetros que estén más a la derecha. Del mismo modo, en la llamada se deben empezar a omitir los valores de la extrema derecha.
	
\textcolor{blue}{Ejemplo:}
 \begin{listing}[ht] 
    \begin{minted}
        [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}
#include <iostream>

using namespace std;

int punto(int=5, int=4);

int main () {

	cout<<"valor 1: "<<punto()<<'\n';
	cout<<"valor 2: "<<punto(1)<<'\n';
	cout<<"valor 3: "<<punto(1,3)<<'\n';
	return 0;
}

int punto( int x, int y){

	if(y!=4)
		return y;
	if(x!=5)
		return x;
	return x+y;
}
    \end{minted}
    \caption{Ejemplo de valores por default}
    \label{listing:1}
    \end{listing}

	C++ no permite la llamada omitiendo un valor antes de la extrema derecha de los argumentos:

\mint[linenos=false]{cpp}|punto( , 8);|

Otro ejemplo de  valores o argumentos por default:



%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}

#include <iostream>

using namespace std;

int b=1;
int f(int);
int h(int x=f(b));	// argumento default f(::b)

int main () {
	b=5;
	cout<<b<<endl;
	{
		int b=3;
		cout<<b<<endl;
		cout<<h();		//h(f(::b))
	}
	
	return 0;
}

int h(int z){
	cout<<"Valor recibido: "<<z<<endl;
	return z*z;
}
int f(int y){
	return y;
}
\end{minted}
\caption{Valores o argumentos por deafult.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


  
\section{Parámetros por referencia}
En C todos los pasos de parámetros son por valor, aunque se pueden enviar parámetros ''por referencia'' al enviar por valor la dirección de un dato (variable, estructura, objeto), de manera que se pueda acceder directamente el área de memoria del dato del que se recibió su dirección. Aunque se tienen que manejar en algunas ocasiones como apuntadores.

C++ introduce parámetros por referencia \textbf{reales}. La manera en que se definen es agregando el símbolo \& de la misma manera que se coloca el *: después del tipo de dato en el prototipo y en la declaración de la función.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// Comparando parámetros por valor, por valor con  apuntadores ("referencia"), 
// y paso por referencia real

#include <iostream>
using namespace std;

int porValor(int);
void porApuntador(int *);
void porReferencia( int &);

int main() {
	int x=2;
	cout << "x= " << x << " antes de llamada a porValor \n"
		<< "Regresado por la función: "<< porValor(x)<<endl
		<< "x= " << x << " despues de la llamada a porValor\n\n";

	int y=3;
	cout << "y= " << y << " antes de llamada a porApuntador\n";
	porApuntador(&y);
	cout << "y= " << y << " despues de la llamada a porApuntador\n\n";

	int z=4;
	cout << "z= " << z << " antes de llamada a porReferencia \n";
	porReferencia(z);
	cout<< "z= " << z << " despues de la llamada a porReferencia\n\n";	
	return 0;
}

int porValor(int valor){
	return valor*=valor;     //parámetro no modificado
}

void porApuntador(int *p){
	*p *= *p;		// parámetro modificado
}

void porReferencia( int &r){
	r *= r;		//parámetro modificado
}
   
\end{minted}
\caption{Otro ejemplo Parámetros por referencia.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


Notar que no hay diferencia en el manejo de un parámetro por referencia y uno por valor, lo que puede ocasionar ciertos errores de programación.

\subsubsection{Variables de referencia}
	También puede declararse una variable por referencia que puede ser utilizada como un seudónimo o alias. Ejemplo:
	
    \begin{minted}{cpp}
int max=1000, &sMax=max;	//declaro max y sMax es un alias de max
sMax++;		//incremento en uno max a través de su alias
    \end{minted}

Esta declaración no reserva espacio para el dato, pues es como un apuntador pero se maneja como una variable normal. No se permite reasignarle a la variable por referencia otra variable. La variable por referencia debe ser inicializada en el momento de su declaración.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// variable por referencia
#include <iostream>

using namespace std;

int main() {
	int x=2, &y=x, z=8;

	cout << "x= "<<x <<endl
		<<"y= "<<y<<endl;

	y=10;
	cout << "x= "<<x <<endl
		<<"y= "<<y<<endl;
// Reasignar no esta permitido
//	 \&  y= &z;
//	cout << "z= "<<z <<endl
//		<<"y= "<<y<<endl;

	y++;
	cout << "z= "<<z <<endl
		<<"y= "<<y<<endl;
   
	return 0;
}
\end{minted}
\caption{Ejemplo de variables por referencia.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\section{Asignación de memoria en C++}
	En el \textbf{ANSI C}, se utilizan \textit{malloc}, \textit{calloc} y \textit{free} para asignar y liberar dinámicamente memoria:
	
	    \begin{minted}{c}
	float *f;
	f = (float *) malloc(sizeof(float));
	. . .
	free(f);
    \end{minted}

Se debe indicar el tamaño a través de \textit{sizeof} y utilizar una máscara (\textit{cast}) para designar el tipo de dato apropiado.

	En C++, existen dos operadores para asignación y liberación de memoria dinámica: \textit{new} y \textit{delete}.
	
 \begin{minted}{cpp}
	float *f;
	f= new float;
	. . .
	delete f;
    \end{minted}

	El operador new crea automáticamente un área de memoria del tamaño adecuado. Si no se pudo asignar la memoria se regresa un apuntador nulo (\textit{NULL} ó 0). Nótese que en C++ se trata de operadores que forman parte del lenguaje, no de funciones de biblioteca.

	El operador \textit{delete} libera la memoria asignada previamente por \textit{new}. No se debe tratar de liberar memoria previamente liberada o no asignada con \textit{new}.

	Es posible hacer asignaciones de memoria con inicialización:	

\mint[linenos=false]{cpp}|int *max= new int (1000);|

También es posible crear arreglos dinámicamente:

 \begin{minted}{cpp}
    char *cad;
	cad= new char [30];
	. . .
	delete [] cad;
    \end{minted}

Usar \textit{delete} \textbf{sin} los corchetes para arreglos dinámicos puede no liberar adecuadamente la memoria, sobre todo si son elementos de un tipo definido por el usuario.

\textcolor{blue}{Ejemplo 1:}	

 \begin{longlisting}%[ht] 
    \begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}
    
#include <iostream>

using namespace std;

int main() {
	int *p,*q;

	p= new int; //asigna memoria

	if(!p) {
		cout<<"No se pudo asignar memoria\n";
		return 0;
	}
	*p=100;
	cout<<endl<< *p<<endl;

	q= new int (123); //asigna memoria
	cout<<endl<< *q<<endl;

	delete p; //libera memoria
//	*p=20;		Uso indebido de pues ya se liberó
//	cout<<endl<< *p<<endl; la memoria
	delete q;
	return 0;
}
    \end{minted}
    \caption{Ejemplo 1 de asignación de memoria en C++}
    \label{listing:1}
    \end{longlisting}

\textcolor{blue}{Ejemplo 2:}
 \begin{longlisting}%[ht] 
    \begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}
    
#include <iostream>

using namespace std;

int main() {
	float *ap, *p=new float (3) ;
	const int MAX=5;
	ap= new float [MAX]; //asigna memoria
	int i;
	for(i=0; i<MAX; i++)
		ap[i]=i * *p;
	for(i=0; i<MAX; i++)
		cout<<ap[i]<<endl;
	delete p;
    delete [] ap;
	return 0;
}
\end{minted}
    \caption{Ejemplo 2 de asignación de memoria en C++}
    \label{listing:1}
    \end{longlisting}


\textcolor{blue}{Ejemplo 3:}

 \begin{longlisting}%[ht] 
    \begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}

#include <iostream>

using namespace std;

typedef struct {
	int n1,
		n2,
		n3;
}cPrueba;

int main() {
	cPrueba *pr1, *pr2;

	pr1= new cPrueba;
	pr1->n1=11;
	pr1->n2=12;
	pr1->n3=13;

	pr2= new cPrueba(*pr1);
	delete pr1;

   cout<< pr2->n1<<" "<<pr2->n2 <<" "<<pr2->n3<<endl;

	delete pr2;
	return 0;
}
    \end{minted}
    \caption{Ejemplo 3 de asignación de memoria en C++}
    \label{listing:1}
    \end{longlisting}

\section{Plantillas}

Cuando las operaciones son idénticas pero requieren de diferentes tipos de datos, podemos usar lo que se conoce como \textit{templates} o plantillas de función.

El término de plantilla es porque el código sirve como base (o plantilla) a diferentes tipos de datos. C++ genera al compilar el código objeto de las funciones para cada tipo de dato involucrado en las llamadas.  Esta solución antes se hacia en C usando macros con \#define, pero no tenían verificación de tipos.

Las definiciones de plantilla se escriben con la palabra clave \textit{template}, con una lista de parámetros formales entre $< >$ . Cada parámetro formal lleva la palabra clave \textit{class}. La instrucción \textit{type} puede también ser usada.

Cada parámetro formal puede ser usado para sustituir a: tipos de datos básicos, estructurados o definidos por el usuario, tipos de los argumentos, tipo de regreso de la función y para variables dentro de la función.

\textcolor{blue}{Ejemplo 1:}

\begin{longlisting}
    \begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}

#include <iostream>

using namespace std;

template <class T>
T mayor(T x, T y)
{
  return (x > y) ? x : y;
};

int main(){
	int a=10, b=20, c=0;
	float x=44.1, y=22.3, z=0 ;

	c=mayor(a, b);
	z=mayor(x, y);
	cout<<c<<" "<<z<<endl;

//	z=mayor(x,b); error no hay mayor( float, int)
//	z=mayor(a, y); ""   ""   "" ""  (int, float)
	
	return 0;
}
    \end{minted}
    \caption{Ejemplo.}
   % \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


Consideraciones:
    
\begin{itemize}
\item 	Cada parámetro formal debe aparecer en la lista de parámetros de la función al menos una vez.
\item     No puede repetirse en la definición de la plantilla el nombre de un parámetro formal. 
\item     Tener cuidado al manejar mas de un parámetro en los templates.
\end{itemize}
   
\textcolor{blue}{Ejemplo 2:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}

#include <iostream>

using namespace std;

template <class T>
void desplegaArr(T arr[], const int cont, T pr)
{
	for(int i=0; i<cont; i++)
		cout<< arr[i] << " ";
	cout<<endl;
	cout<<pr<<endl;
}

int main() {
	const int contEnt=4, contFlot=5, contCar=10;
int ent[]={1,2,3,4};
	float flot[]={1.1, 2.2, 3.3, 4.4, 5.5};
	char car[]={"Plantilla"};	


	cout<< "Arreglo de flotantes:\n";
	desplegaArr(flot, contFlot,(float)3.33);

	cout<< "Arreglo de caracteres:\n";
	desplegaArr(car, contCar, 'Z');

	cout<< "Arreglo de enteros:\n";
	desplegaArr(ent, contEnt, 99);
	
	return 0;
}

\end{minted}
\caption{Ejemplo 2 de uso de plantillas en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textcolor{blue}{Ejemplo 3:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}

#include <iostream>

using namespace std;

template <class T, class TT>
T mayor(T x, TT y)
{
  return (x > y) ? x : y;
};

int main(){

	int a=10, b=20, c=0;
	float x=44.1, y=22.3, z=0 ;

	c=mayor(a, b);
	z=mayor(x, y);

	cout<<c<<" "<<z<<endl;
//sin error al aumentar un parámetro formal.
	z=mayor(x,b);
	cout<<z<<endl;
	z=mayor(a,y); //regresa entero pues a es entero (tipo T es entero para
	cout<<z<<endl;		// este llamado.

	z=mayor(y, a);
	cout<<z<<endl;
	c=mayor(y, a);//regresa flotante pero la asignaci¢n lo corta en entero.
	cout<<c<<endl;
	
	return 0;
}
\end{minted}
\caption{Ejemplo 3 de uso de plantillas en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Enumeraciones}

Aunque las enumeraciones existen en ANSI C, en ese lenguaje son constantes asociadas al tipo entero; por lo que son una especie de alias hacia estos valores. En C++ una enumeración define realmente un tipo de dato.\footnote{Existe otro tipo de enumeración en C++ llamado $enum class$}
% https://stackoverflow.com/questions/18335861/why-is-enum-class-preferred-over-plain-enum
% http://www-cs-students.stanford.edu/~sjac/c-to-cpp-info/c-to-cpp-differ
% https://dev.to/rawrasaurus/enumerations-in-c-traditional-enum-vs-enum-class-part-2-3jn6

Las enumeraciones sirven para agrupar un conjunto de elementos dentro de un tipo definido. El manejo de enumeraciones en C++ es el siguiente:

\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}|enum <nombreEnum> { <elem 1>, <elem 2>, …, <elem n> }; |\\
\hline
\end{tabular}
\end{center}

Por lo que para el código anterior, la enumeración sería:

 \mint[linenos=false]{cpp}|enum Temporada { PRIMAVERA, VERANO, OTOÑO, INVIERNO } |

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}

#include <iostream>

using namespace std;

enum Temporada { PRIMAVERA, VERANO, OTONO, INVIERNO };

 int main() {
		Temporada tem;
		tem=PRIMAVERA;
		cout<<"Temporada: " << tem<<endl;
		
        cout<<"\nListado de temporadas:";
		int t;
        for(t=PRIMAVERA; t<=INVIERNO; t++)
			cout<<"Temporada: "<< t<<endl;
        return 0;
}
\end{minted}
\caption{Ejemplo de enumeración en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Espacios de nombre (\textit{namespaces})}

Los espacios de nombres permiten agrupar entidades que de otro modo tendrían un alcance global. Es preferible tener un alcance de espacio de nombre que un alcance global. Un \textit{namespace} proporciona un un alcance para identificadores tales como tipos, funciones, variables, etc. Algunas características\footnote{Más información: \href{https://en.cppreference.com/w/cpp/language/namespace}{C++ reference: namespace}}:
   
\begin{itemize}
\item  Se pueden tener múltiples bloques con el mismo \textit{namespace}, todas la declaraciones en bloques con el mismo nombre irán al mismo espacio de nombres.
\item   Es posible tener espacios de nombre anidados.
\item   Las declaraciones de espacios de nombre no dan acceso público o privado.
\end{itemize}


\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
namespace <nombre> {   
   int x, y; // declaraciones de código donde  
             // x , y son declaradas en el alcance de <nombre> 
} 
    \end{minted}
\\ \hline
\end{tabular}
\end{center}


\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}

#include <iostream> 
using namespace std; 

namespace ns1 { 
    int valor()    { return 5; } 
} 
namespace ns2  { 
    const double x = 100; 
    double valor() {  return 2*x; } 
} 
  
int main() { 
    cout << ns1::valor() << '\n';  
    cout << ns2::valor() << '\n';  
    cout << ns2::x << '\n';         
} 

\end{minted}
\caption{Ejemplo de uso de \textit{namespace}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Tipo de dato booleano}

Este tipo de dato (\textit{bool}) maneja los valores verdadero o falso ( \textit{true} o \textit{false} ). Es un tipo de dato y sus literales son además parte de las palabras reservadas de C++. Puede ser declarado como sigue:

\begin{minted}{cpp}
    bool b1;
    b1=true;
    bool b2 = false;
\end{minted}

Sin embargo, al final el tipo booleano en C++ sigue siendo equivalente a su uso en el lenguaje C: cero para falso y diferente de cero es verdadero. Por lo que su uso no es obligatorio.

\section{Uso de cadenas con \textit{string} }

En C++ podemos hacer uso de cadenas por medio del tipo \textit{string}. En compiladortes actuales es suficiente con incluir la biblioteca \textit{iostream} aunque en realidad se encuentra directamente declarado en \textit{cstring}


\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize,
linenos]
    {cpp}

#include<iostream>
using namespace std;

int main() {
   string nombre="Juan", apellido="Pérez";
   cout << "Hola, " << nombre << " " << apellido << endl;
   cout << "¿Cómo estás?" << endl;
}

\end{minted}
\caption{Ejemplo de uso de cadenas \textit{string}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Ciclo foreach en C++ }

C++ tiene un estilo de bucle \textit{for each} llamado \textit{for (auto element : container)}, el cual se utiliza para recorrer un contenedor de elementos. Este estilo de iteración se introdujo en C++11, presentado en 2011, y es una forma más simple y legible de recorrer un contenedor en comparación con el uso tradicional de un ciclo \textit{for} con un iterador.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
for (<tipo_de_dato>  <nombre_variable> : <tipo_contenedor>) {
     <instrucciones>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}


Por ejemplo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}

#include <iostream>

using namespace std;

int main() {
    int myArray[] = {1, 2, 3, 4, 5};

    // Recorriendo el array con un ciclo for each
    for (int element : myArray) {
        cout << element << " ";
    }
    cout << endl;

    // Recorriendo el array con un ciclo for each usando auto
    for (auto element : myArray) {
        cout << element << " ";
    }
    cout << endl;
    return 0;
}
\end{minted} 

\caption{Ejemplo de \textit{foreach} en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo se define un arreglo de enteros llamado \textit{myArray} y se inicializa con los valores $1, 2, 3, 4, 5$. Luego se utiliza el estilo de ciclo \textit{for each} para recorrer cada elemento del arreglo y se imprime cada elemento en pantalla. El código anterior imprimiría $1 2 3 4 5$ en pantalla.

Es importante mencionar que el estilo de iteración \textit{for each} sólo es válido para contenedores que soporten el acceso aleatorio, tales como arreglos y vector, entre otros.





%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
https://www.programiz.com/cpp-programming/strings

Concatenación https://www.w3schools.com/cpp/cpp_strings_concat.asp

\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%

\section{Características relevantes de C++17 \protect\footnote{Partes de esta sección fueron desarrollados con apoyo de ChatGPT}}

C++17 es la séptima versión del estándar de C++, fue aprobada en diciembre de 2017, y introduce varias características y mejoras en el lenguaje, algunas de las más importantes incluyen:


\begin{itemize}
\item \textbf{Inicialización de estructuras y clases}: Se permite inicializar estructuras y clases de manera similar a como se inicializan los arreglos y los objetos de cualquier tipo de contenedor. Esto se logra mediante la inclusión de una lista de inicializadores entre llaves \{\}.
\item \textbf{Inicialización automática de variables}: Se permite inicializar variables automáticamente en el momento de su declaración, ahorrando la necesidad de escribir código adicional para inicializarlas.
\item \textbf{Eliminación de if y switch}: Se permite eliminar el cuerpo de un if o un switch si su condición es siempre verdadera o falsa, respectivamente.

\item \textbf{Programación concurrente y paralela}: Se ha añadido soporte para la programación concurrente y paralela mediante el uso de las librerías estándar de C++.
\item \textbf{Mejoras en las plantillas}: Se han añadido mejoras en las plantillas, como la posibilidad de especificar un tipo de retorno automático para las funciones plantilla, lo que permite una mayor flexibilidad y legibilidad en el código.
\item \textbf{Mejoras en la sintaxis}: Se han añadido mejoras en la sintaxis del lenguaje, como la posibilidad de usar el operador "auto" para deducir el tipo de una variable en una expresión.
\end{itemize}

C++17 ha mejorado significativamente el lenguaje, haciéndolo más conciso, fácil de leer y de escribir, y más adecuado para la programación concurrente y paralela. Estas mejoras hacen que el código sea más eficiente y escalable, y que sea más fácil para los desarrolladores escribir código correcto y seguro.

\subsection{Inicialización de estructuras y clases}
La inicialización de estructuras y clases es una característica introducida en C++17 que permite inicializar los miembros de una estructura o clase mediante una lista de inicializadores entre llaves \{\}. Esto es similar a cómo se inicializan los arreglos y los objetos de cualquier tipo de contenedor.

La sintaxis para inicializar una estructura es la siguiente:

%multiple lines
\begin{minted}{cpp}

struct MyStruct {
    int x;
    float y;
};

MyStruct myStruct {1, 3.14f};

\end{minted}

Para una clase:

%multiple lines
\begin{minted}{cpp}

class MyClass {
public:
    int x;
    float y;
};

MyClass myClass {1, 3.14f};

\end{minted}


En el ejemplo anterior se define una estructura llamada \textit{MyStruct} con dos miembros: ''x'' e ''y'', se declara una variable \textit{myStruct} de ese tipo y se inicializa con los valores 1 y 3.14f respectivamente. Y también se define una clase llamada \textit{MyClass} con dos miembros: ''x'' e ''y'', se declara una variable \textit{myClass} de ese tipo y se inicializa con los valores 1 y 3.14f respectivamente.

Además, es posible inicializar solo algunos de los miembros de una estructura o una clase, dejando los demás con su valor por defecto:

%multiple lines
\begin{minted}{cpp}
MyStruct myStruct {1};  // x = 1, y = 0.0f (valor por defecto)

MyClass myClass {1};   // x = 1, y = 0.0f (valor por defecto)

\end{minted}

La inicialización de estructuras y clases es una característica muy útil que permite escribir código más conciso y legible, y también ayuda a prevenir errores comunes relacionados con la inicialización de variables.


\subsection{Inicialización automática de variables}

La inicialización automática de variables es una característica introducida en C++17 que permite inicializar una variable automáticamente en el momento de su declaración, sin necesidad de escribir código adicional para inicializarla. Esto se logra mediante el uso del operador \textit{auto} junto con el valor con el que se desea inicializar la variable.

La sintaxis para inicializar una variable automáticamente es la siguiente:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}{| auto <variable>= <valor>;}
 |\\
\hline
\end{tabular}
\end{center}

Se utiliza el operador \textit{auto} para inicializar automáticamente la variable con el valor, y el compilador deduce automáticamente el tipo de la variable.

Se puede usar auto con cualquier tipo de dato, incluso con tipos compuestos como \textit{structs} o clases:

%multiple lines
\begin{minted}{cpp}
struct MyStruct {
    int x;
    float y;
};

auto myStruct = MyStruct{1, 3.14f};

class MyClass {
public:
    int x;
    float y;
};

auto myClass = MyClass{1, 3.14f};
\end{minted}

En estos ejemplos, se utiliza el operador \textit{auto} para inicializar automáticamente las variables \textit{myStruct} y \textit{myClass} con los valores especificados en las estructuras \textit{MyStruct} y \textit{MyClass} respectivamente.

La inicialización automática de variables es una característica muy útil que permite escribir código más conciso y legible, ya que el compilador deduce automáticamente el tipo de la variable a partir del valor con el que se inicializa. Esto también ayuda a prevenir errores comunes relacionados con la inicialización de variables, ya que el compilador se encarga de realizar la deducción del tipo de forma segura.

\subsection{Eliminación de sentencias vacias if y switch}
En C++17 se ha introducido la característica de ''Eliminación de sentencias vacías'' en las estructuras de control \textit{if} y \textit{switch}.

Se refiere a la eliminación de las sentencias vacías de las estructuras de control \textit{if} y \textit{switch} cuando su condición es siempre verdadera o falsa.

Por ejemplo, consideremos el siguiente código:

%multiple lines
\begin{minted}{cpp}
int x = 5;

if (x > 0)
    x = x + 2;
else
    ; // sentencia vacía

\end{minted}

En este caso, la condición del \textit{if} es siempre verdadera, por lo que el cuerpo del \textit{else} no se ejecutará nunca. Es decir, la sentencia vacía '';'' en el cuerpo del \textit{else} no tiene efecto alguno. El compilador puede eliminarla automáticamente y generar código más eficiente.

Con respecto al \textit{switch}, consideremos el siguiente código:

%multiple lines
\begin{minted}{cpp}
int x = 5;

switch (x) {
    case 5:
        x = x + 2;
        break;
    case 6:
        ; // sentencia vacía
        break;
    default:
        x = x - 2;
}
\end{minted}

En este caso, el valor de x es siempre 5, por lo que el cuerpo de case 6 no se ejecutará nunca, es decir la sentencia vacía ";" no tiene efecto alguno. El compilador puede eliminarla automáticamente y generar código más eficiente.

La eliminación de sentencias vacías ayuda a escribir código más conciso y legible ya que permite eliminar las estructuras de control innecesarias. Además, también ayuda a mejorar el rendimiento del código ya que el compilador puede generar código más eficiente al eliminar las sentencias vacías.


\subsection{Mejoras en las plantillas}

Las plantillas son una característica de C++ que permite escribir código genérico que se aplica a diferentes tipos de datos. C++17 ha introducido varias mejoras en las plantillas, que hacen que sea más fácil y flexible escribir código genérico.

Una de las mejoras más importantes es la posibilidad de especificar un tipo de retorno automático para las funciones plantilla. Esto permite que el compilador deduzca automáticamente el tipo de retorno de una función plantilla a partir de los argumentos de entrada.

La sintaxis para especificar un tipo de retorno automático para una función plantilla es la siguiente:

%multiple lines
\begin{minted}{cpp}
template <typename T>
auto add(T a, T b) -> decltype(a + b) {
    return a + b;
}

\end{minted}

En este ejemplo, la función \textit{add} es una plantilla que acepta dos argumentos de cualquier tipo ''T'' y devuelve el resultado de la suma de estos argumentos. La función utiliza el operador \textit{decltype} para especificar que el tipo de retorno de la función es el mismo que el tipo de los argumentos de entrada.

Otra mejora importante en las plantillas es la posibilidad de especificar parámetros de plantilla de forma no estricta. Esto significa que se pueden especificar parámetros de plantilla que no son necesariamente tipos.

La sintaxis para especificar parámetros de plantilla no estrictos es la siguiente:

%multiple lines
\begin{minted}{cpp}
template <typename T, int N>
void print_array(T (&arr)[N]) {
    for (int i = 0; i < N; i++) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
}
\end{minted}


En este ejemplo, la función \textit{print\_array} es una plantilla que acepta un arreglo \textit{arr} de cualquier tipo ''T'' y un entero ''N'' que indica el tamaño del arreglo. La función imprime el contenido del arreglo en pantalla.

Estas mejoras en las plantillas hacen que el código sea más fácil y flexible de escribir, ya que permite deducir automáticamente el tipo de retorno y no solo utilizar tipos como parámetros. Esto permite una mayor flexibilidad y legibilidad en el código.

\subsection{Mejoras en la sintaxis}

C++17 ha introducido varias mejoras en la sintaxis del lenguaje que hacen que sea más fácil y legible escribir código. Algunas de las mejoras más importantes son:

Inicializadores de lista en la declaración de variables: Es posible inicializar una variable en el momento de su declaración utilizando una lista de inicializadores entre llaves {}. Esto es similar a cómo se inicializan los arreglos y los objetos de cualquier tipo de contenedor.

%multiple lines
\begin{minted}{cpp}
int x = {5};
std::vector<int> v = {1, 2, 3};
\end{minted}

Mejoras en el operador ternario: El operador ternario se ha mejorado para permitir la asignación y el llamado a funciones dentro de su sintaxis.

%multiple lines
\begin{minted}{cpp}
int x = 5;
int y = x > 0 ? x + 2 : x - 2;

std::string message = x > 0 ? "Positive" : "Negative";

\end{minted}

Mejoras en el operador de propagación: El operador de propagación "..." permite pasar los elementos de un contenedor como argumentos individuales a una función o constructor.

%multiple lines
\begin{minted}{cpp}
std::vector<int> v = {1, 2, 3};
std::initializer_list<int> l = {4, 5, 6};

foo(1, 2, 3);
foo(v.begin(), v.end());
foo(l);

\end{minted}

Mejoras en el uso de corchetes y llaves: La sintaxis de corchetes y llaves se ha mejorado para permitir su uso como una forma de expresar bloques de código y para inicializar variables.

%multiple lines
\begin{minted}{cpp}
for (int i : {1, 2, 3}) {
    std::cout << i << std::endl;
}

\end{minted}

Estas mejoras en la sintaxis ayudan a escribir código más legible y fácil de entender, y también ayudan a prevenir errores comunes.

\subsection{Manejo de cadenas con \textit{string}}

Las cadenas de caracteres son elementos fundamentales en la programación, y en C++, se gestionan a través de la clase \textit{std::string}. Esta clase proporciona una interfaz conveniente para manipular cadenas de manera eficiente. A continuación, se presentan un ejemplo completo que ilustran cómo utilizar cadenas en C++.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}

#include <iostream>
#include <string>

int main() {
    // Crear una cadena e inicializarla
    std::string cadena = "Hola, mundo";

    // Imprimir la cadena original
    std::cout << "Cadena original: " << cadena << std::endl;

    // Obtener la longitud de la cadena
    size_t longitud = cadena.length();
    std::cout << "Longitud de la cadena: " << longitud << " caracteres" << std::endl;

    // Acceder a caracteres individuales mediante índices
    char primerCaracter = cadena[0];
    char ultimoCaracter = cadena[longitud - 1];
    std::cout << "Primer caracter: " << primerCaracter << std::endl;
    std::cout << "Último caracter: " << ultimoCaracter << std::endl;

    // Concatenar cadenas
    std::string otraCadena = "¡Bienvenido!";
    std::string concatenacion = cadena + " " + otraCadena;
    std::cout << "Cadenas concatenadas: " << concatenacion << std::endl;

    // Comparar cadenas
    std::string otraCadena2 = "Hola, mundo";
    if (cadena == otraCadena2) {
        std::cout << "Las cadenas son iguales" << std::endl;
    } else {
        std::cout << "Las cadenas son diferentes" << std::endl;
    }

    std::string cadena1 = "Hola";
    std::string cadena2 = "Hola";
    int comparacion = cadena1.compare(cadena2); // comparacion = 0
    std::cout << "Comparación: "<<comparacion << std::endl;
    
    // Encontrar subcadenas
    size_t posicion = cadena.find("mundo");
    if (posicion != std::string::npos) {
        std::cout << "La subcadena 'mundo' comienza en la posición: " 
          << posicion << std::endl;
    } else {
        std::cout << "La subcadena 'mundo' no se encontró" << std::endl;
    }
    
    // Se pueden convertir cadenas a otros tipos de datos 
    // utilizando métodos como stoi o stof
    std::string numero = "123";
    int valor = std::stoi(numero); // valor = 123
    std::cout << "Valor: " << valor << std::endl;

    std::string decimal = "3.1415";
    float pi = std::stof(decimal); // pi = 3.1415
    std::cout << "pi: " << pi << std::endl;

    // Conversión a cadena con el método to_string()
    cadena = std::to_string(pi);
    std::cout << cadena << std::endl;
    
    return 0;
}

\end{minted} 

\caption{Ejemplo de uso de \textit{string} en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


En este programa, se ha creado una cadena inicial, se han explorado diversas operaciones comunes de cadenas y se han comentado para proporcionar claridad. Desde la creación e inicialización de cadenas hasta la comparación y búsqueda de subcadenas, estos ejemplos abarcan aspectos esenciales del uso de cadenas en C++. \textit{size\_t} es un tipo de datos sin signo en C++ utilizado para representar el tamaño o la longitud de estructuras de datos, como arreglos o cadenas.

\fi
%%%%%%%%%%
% C++_END
%%%%%%%%%%

%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava

\chapter{Introducción a Java}


\section{Origen}

Java es un lenguaje de programación orientada a objetos, diseñado dentro de\textit{ Sun Microsystems} por James Gosling. Originalmente, se le asignó el nombre de \textit{Oak} y fue un lenguaje pensado para usarse dentro de dispositivos electrodomésticos, que tuvieran la capacidad de comunicarse entre sí.
\begin{wrapfigure}{O}{0.05\textwidth} 
    \centering
    \includegraphics[]{imagenes/java_logo_01.png}

%    \includegraphics[]{imagenes/groovy.png}
%    \includegraphics[width=0.25\textwidth]{mesh}
\end{wrapfigure}
Posteriormente fue reorientado hacia Internet, aprovechando el auge que estaba teniendo en ese momento la red, y lo rebautizaron con el nombre de Java. Es anunciado al público en mayo de 1995 enfocándolo como la solución para el desarrollo de aplicaciones en \textit{web}. Sin embargo, se trata de un lenguaje de propósito general que puede ser usado para la solución de problemas diversos.

Java es un intento serio de resolver simultáneamente los problemas ocasionados por la diversidad y crecimiento de arquitecturas incompatibles, tanto entre máquinas diferentes como entre los diversos sistemas operativos y sistemas de ventanas que funcionaban sobre una misma máquina, añadiendo la dificultad de crear aplicaciones distribuidas en una red como Internet.
\begin{wrapfigure}{I}{0.05\textwidth} 
    \centering
    \includegraphics[]{imagenes/java_logo_02.png}
%    \includegraphics[]{imagenes/groovy.png}
%    \includegraphics[width=0.25\textwidth]{mesh}
\end{wrapfigure}
El interés que generó Java en la industria fue mucho, tal que nunca un lenguaje de programación había sido adoptado tan rápido por la comunidad de desarrolladores. Las principales razones por las que Java es aceptado tan rápido:
\begin{itemize}
\item  Aprovecha el inicio del auge de la Internet, específicamente del \textit{World Wide Web}.
\item  Es orientado a objetos, la cual si bien no es tan reciente, estaba en uno de sus mejores momentos, todo mundo quería programar de acuerdo al modelo de objetos.
\item  Se trataba de un lenguaje que eliminaba algunas de las principales dificultades del lenguaje C/C++, el cuál era uno de los lenguajes dominantes. Se decía que la ventaja de Java es que es sintácticamente parecido a C++, sin serlo realmente.
\item  Java era resultado de una investigación con fines comerciales, no era un lenguaje académico como Pascal o creado por un pequeño grupo de personas como C ó C++.
\end{itemize}

Aunado a esto, las características de diseño de Java, lo hicieron muy atractivo a los programadores.

\section{Características de diseño}
Es un lenguaje de programación de alto nivel, de propósito general, y cuyas características son \cite{Sun01}:

\begin{itemize}
\item  Simple y familiar.
\item  Orientado a objetos.
\item  Independiente de la plataforma 
\item  Portable
\item  Robusto.
\item  Seguro.
\item  Multihilos.
\end{itemize}

\subsubsection{Simple y familiar} 

Es simple, ya que tanto la estructura léxica como sintáctica del lenguaje es muy sencilla. Además, elimina las características complejas e innecesarias de sus predecesores.

Es familiar al incorporar las mejores características de lenguajes tales como:	C/C++, Modula, Beta, CLOS, Dylan, Mesa, Lisp, Smalltalk, Objective-C, y Modula 3.


\subsubsection{Orientado a objetos}

Es realmente un lenguaje orientado a objetos, todo en Java son objetos:

\begin{itemize}
\item  No es posible que existan funciones que no pertenezcan a una clase.
\item  La excepción son los tipos de datos primitivos, como números, caracteres y booleanos \footnote{Los puristas objetarían que no es totalmente orientado a objetos. En un sentido estricto \textit{Smalltalk} es un lenguaje “más” puro, ya que ahí hasta los tipos de datos básicos son considerados objetos.}.
\end{itemize}

	Cumple con los 4 requerimientos de Wegner \cite{wegner1986classification}:
\begin{center}
    \textbf{OO = abstracción + clasificación + polimorfismo + herencia}
\end{center}

\subsubsection{Independiente de la plataforma}
La independencia de la plataforma implica que un programa en Java se ejecute sin importar el sistema operativo que se este ejecutando en una máquina en particular. Por ejemplo un programa en C++ compilado para \textit{Windows}, debe ser al menos vuelto a compilar si se quiere ejecutar en Unix; además, posiblemente habrá que ajustar el código que tenga que ver con alguna característica particular de la plataforma, como la interfaz con el usuario.

	Java resuelve el problema de la distribución binaria mediante un formato de código binario (\textit{bytecode}) que es independiente del hardware y del sistema operativo gracias a su máquina virtual.

	Si el sistema de \textit{runtime} o máquina virtual está disponible para una plataforma específica, entonces una aplicación puede ejecutarse sin necesidad de un trabajo de programación adicional. Ver figura \ref{fig:java_capas}.
	

\begin{figure}
    \centering
    \includegraphics[scale=.25]{imagenes/java_capas.png}
    \caption{ Máquina virtual de Java y su ejecución sobre una plataforma }
    \label{fig:java_capas}
\end{figure}	
	
\subsubsection{Portable}

	Una razón por la que los programas en Java son portables es precisamente que el lenguaje es independiente de la plataforma. 

Además, la especificación de sus tipos de datos primitivos y sus tamaños, así como el comportamiento de los operadores aritméticos, son estándares en todas las implementaciones de Java. Por lo que por ejemplo, un entero es definido de un tamaño de 4 bytes, y este espacio ocupará en cualquier plataforma, por lo que no tendrá problemas en el manejo de los tipos de datos. En cambio, un entero en C generalmente ocupa 2 bytes, pero en algunas plataformas el entero ocupa 4 bytes, lo que genera problemas a la hora de adaptar un programa de una plataforma a otra.

\subsubsection{Robusto}

Java se considera un lenguaje robusto y confiable, gracias a:

\begin{itemize}
\item \textbf{Validación de tipos.} Los objetos de tipos compatibles pueden ser asignados a otros objetos sin necesidad de modificar sus tipos. Los objetos de tipos potencialmente incompatibles requieren un modificador de tipo (\textit{cast}). Si la modificación de tipo es claramente imposible, el compilador lo rechaza y reporta un \textbf{error en tiempo de compilación}. Si la modificación resulta legal, el compilador lo permite, pero inserta una \textbf{validación en tiempo de ejecución.} Cuando el programa se ejecuta se realiza la validación cada vez que se ejecuta una asignación potencialmente inválida.
\item  \textbf{Control de acceso a variables y métodos.} Los miembros de una clase pueden ser privados, públicos o protegidos\footnote{Más adelante en el curso se ahondará en el tema.}. En java una variable privada, es realmente privada. Tanto el compilador como la máquina virtual de Java, controlan el acceso a los miembros de una clase, garantizando así su privacidad.
\item  \textbf{Validación del apuntador Null.} Todos los programas en Java usan apuntadores para referenciar a un objeto. Esto no genera inestabilidad pues una validación del apuntador a \textit{Null} ocurre cada vez que un apuntador deja de referencia a un objeto. C y C++ por ejemplo, no tienen esta consideración sobre los apuntadores, por lo que es posible estar referenciando a localidades inválidas de la memoria.
\item \textbf{ Límites de un arreglo. }Java verifica en tiempo de ejecución que un programa no use arreglos para tratar de acceder a áreas de memoria que no le pertenecen. De nuevo, C y C++ no tiene esta verificación, lo que permite que un programa se salga del límite mayor y menor de un arreglo.
\item  \textbf{Aritmética de apuntadores.} Aunque todos los objetos se manejan con apuntadores, Java elimina la mayor parte de los errores de manejo de apuntadores  porque no soporta la aritmética de apuntadores:
\begin{itemize}
\item No soporta acceso directo a los apuntadores
\item No permite operaciones sobre apuntadores.
\end{itemize}
\item  \textbf{Manejo de memoria. }Muchos de los errores de la programación se deben a que el programa no libera la memoria que debería liberar, o se libera la misma memoria más de una vez. Java, hace recolección automática de basura, liberando la memoria y evitando la necesidad de que el programador se preocupe por liberar memoria que ya no utilice.
\end{itemize}

\section{Diferencias entre Java y C++}

Se compara mucho al lenguaje de Java con C++, y esto es lógico debido a la similitud en la sintaxis de ambos lenguajes, por lo que resulta necesario resaltar las diferencias principales que existen entre estos. Java a diferencia de C++:


\begin{itemize}
\item  \textbf{No tiene aritmética de apuntadores.} Java si tiene apuntadores, sin embargo no permite la manipulación directa de las direcciones de memoria. No se proporcionan operadores para el manejo de los apuntadores pues no se considera responsabilidad del programador.
\item  \textbf{No permite funciones con ámbito global.} Toda operación debe estar asociada a una clase, por lo que el ámbito de la función esta limitado al ámbito de la clase.
\item  \textbf{Elimina la instrucción \textit{goto}.} La instrucción \textit{goto} se considera obsoleta, ya que es una herencia de la época de la programación no estructurada. Sin embargo, esta definida como palabra reservada para restringir su uso.
\item  \textbf{Las cadenas no terminan con '\textbackslash{0}'.} Las cadenas en C y C++ terminan con '\textbackslash{0} ' que corresponde al valor en ASCII 0, ya que en estos lenguajes no existe la cadena como un tipo de dato estándar y se construye a partir de arreglos de caracteres. En Java una cadena es un objeto de la clase \textit{String} y no necesita ese carácter para indicar su finalización.
\item \textbf{ No maneja macros.} Una macro es declarada en C y C++ a través de la instrucción \textit{\#define}, la cual es tratada por el preprocesador. 
\item  \textbf{No soporta un preprocesador.} Una de las razones por las cuales no maneja macros Java es precisamente porque no tiene un preprocesador que prepare el programa previo a la compilación.
\item  \textbf{El tipo \textit{char} contiene 16 bits}. Un carácter en Java  utiliza 16 bits en lugar de 8 para poder soportar UNICODE en lugar de ASCII, lo que permite la representación de múltiples símbolos.
\item  \textbf{Java soporta múltiples hilos de ejecución}. Los múltiples hilos de ejecución o multihilos permiten un fácil manejo de programación concurrente. Otros lenguajes dependen de la plataforma para implementar concurrencia.
\item  \textbf{Todas las condiciones en Java deben tener como resultado un tipo booleano. }Debido a que en Java los resultados de las expresiones son dados bajo este tipo de dato. Mientras que en C y C++ se considera a un valor de cero como falso y no cero como verdadero.
\item \textbf{ Java no soporta el operador \textit{sizeof}.} Este operador permite en C y C++ obtener el tamaño de una estructura de datos. En Java esto no es necesario ya que cada objeto “sabe” el espacio que ocupa en memoria.
\item \textbf{ No tiene herencia múltiple.} Java solo cuenta con herencia simple, con lo que pierde ciertas capacidades de generalización que son subsanadas a través del uso de interfaces. El equipo de desarrollo de Java explica que esto simplifica el lenguaje y evita la ambigüedad natural generada por la herencia múltiple.
\item \textbf{ No tiene liberación de memoria explícita (\textit{delete} y \textit{free()} ).} En Java no es necesario liberar la memoria ocupada, ya que cuenta con un recolector de basura \footnote{\textit{Garbage Collector}} responsable de ir liberando cada determinado tiempo los recursos de memoria que ya no se estén ocupando.
\end{itemize}

Además:

\begin{itemize}
\item  No contiene estructuras y uniones (\textit{struct} y \textit{union}).
\item  No contiene tipos de datos sin signo.
\item  No permite alias (\textit{typedef}).
\item  No tiene conversión automática de tipos compatibles.
\end{itemize}

\section{Archivos .java y .class}

En Java el código fuente se almacena en archivos con extensión .java, mientras que el \textit{bytecode} o código compilado se almacena en archivos .\textit{class}. El compilador de Java crea un archivo \textit{.class} por cada declaración de clase que encuentra en el archivo \textit{.java}.

	Un archivo de código fuente debe tener solo una clase principal, y ésta debe tener exactamente el mismo nombre que el del archivo \textit{.java}. Por ejemplo, si tengo una clase que se llama \textit{Alumno}, el archivo de código fuente se llamará \textit{Alumno.java}. Al compilar, el archivo resultante será \textit{Alumno.class}.

\section{Programas generados con java}

Existen dos tipos principales de programas en Java \footnote{Se presenta la división clásica de los programas de Java, aunque existen algunas otras opciones no son relevantes en este curso.}:

Por un lado están las aplicaciones, las cuales son programas \textit{standalone}, escritos en Java y ejecutados por un intérprete del código de bytes desde la línea de comandos del sistema. 

Por otra parte, los \textit{Applets}, que son pequeñas aplicaciones escritas en Java, las cuales siguen un conjunto de convenciones que les permiten ejecutarse dentro de un navegador. Estos \textit{applets} siempre están incrustados en una página \textit{html}.

En términos del código fuente las diferencias entre un \textit{applet} y una aplicación son:

\begin{itemize}
\item  Una aplicación debe definir una clase que contenga el método \textit{main()}, que controla su ejecución. Un \textit{applet} no usa el método \textit{main()}; su ejecución es controlado por varios métodos definidos en la clase \textit{applet}.
\item   Un \textit{applet}, debe definir una clase derivada de la clase \textit{Applet} \footnote{A partir de la versión 1.9 del jdk, los applets ya no son soportados.}.
\end{itemize}

\section{El Java Developer’s Kit}

La herramienta básica para empezar a desarrollar aplicaciones en Java es el JDK (\textit{Java Development Kit}) o Kit de Desarrollo Java, que consiste esencialmente, en un compilador y un intérprete (JVM\footnote{\textit{Java Virtual Machine}}) para la línea de comandos. No dispone de un entorno de desarrollo integrado (IDE), pero es suficiente para aprender el lenguaje y desarrollar pequeñas aplicaciones\footnote{ Este kit de desarrollo es gratuito y puede obtenerse de la dirección proporcionada al final de este documento. Independientemente del IDE que se use, el jdk debe estar instalado para poder compilar código Java.}.

Los principales programas del \textit{Java Development Kit}:

\begin{itemize}
\item \textbf{javac}. Es el compilador en línea del JDK.
\item \textbf{java}. Es la máquina virtual para aplicaciones de Java.
\item \textbf{appletviewer}. Visor de \textit{applets} de java.
\end{itemize}


\subsubsection{Compilación}

Utilizando el JDK, los programas se compilan desde el símbolo del sistema con el compilador javac. 

Ejemplo:

\begin{alltt}
C:\\MisProgramas> javac MiClase.java
\end{alltt}

Normalmente se compila como se ha mostrado en el ejemplo anterior. Sin embargo, el compilador proporciona diversas opciones a través de modificadores que se agregan en la línea de comandos. 


\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{bash}|javac [opciones] <archivo1.java>|\\
\hline
\end{tabular}
\end{center}

donde opciones puede ser:

\begin{itemize}
\item $-classpath <ruta>$   	Indica donde buscar los archivos de clase de Java
\item $-d <directorio>$      	Indica el directorio destino para los archivos .class
\item $-g$     					Habilita la generación de tablas de depuración.
\item $-nowarn$   			Deshabilita los mensajes del compilador.
\item $-O$     					Optimiza el código, generando en línea los métodos estáticos, finales y privados.
\item $-verbose$   			Indica cuál archivo fuente se esta compilando.
\end{itemize}


\section{“Hola Mundo”}

Para no ir en contra de la tradición al comenzar a utilizar un lenguaje, los primeros ejemplos son precisamente dos programas muy simples que lo único que van a hacer es desplegar el mensaje “Hola Mundo”.

\paragraph{Hola mundo básico en Java}

El primero es una aplicación que va a ser interpretado posteriormente por la máquina virtual:

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}

public class HolaMundo {
    public static void main(String args[]) {          
        System.out.println("¡Hola, Mundo!"); 
    }
}
\end{minted}
\caption{Hola, Mundo en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Para los que han programado en C ó C++, notarán ya ciertas similitudes. Lo importante aquí es que una aplicación siempre requiere de un método \textit{main}, este tiene un solo argumento (\textit{String args[ ]}), a través del cual recibe información de los argumentos de la línea de comandos, pero la diferencia con los lenguajes C/C++ es que este método depende de una clase, en este caso la clase \textit{HolaMundo}. Este programa es compilado en al jdk\footnote{ Se asume que el jdk se encuentra instalado y que el PATH tiene indicado el directorio bin del jdk para que encuentre el programa javac. También es recomendable añadir nuestro directorio de programas de java a una variable de ambiente llamada CLASSPATH.}:

\begin{alltt}
%javac HolaMundo.java
\end{alltt}

con lo que, si el programa no manda errores, se obtendrá el archivo \textit{HolaMundo.class}.

En Eclipse, al grabar automáticamente el programa se compilará (si la opción \textit{Build Automatically} está activada). De hecho, algunos errores se van notificando, si los hay, conforme se va escribiendo el código en el editor.

\subsubsection{Hola mundo básico en C++}
En C++ no estamos obligados a usar clases, por lo que un “Hola mundo” en C++ - aunque no en objetos – podría quedar de la siguiente forma:

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}

#include <iostream>

using namespace std;

int main(){
    cout << "Hola Mundo!" << endl;
    return 0;
}
\end{minted}
\caption{Hola, Mundo en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Ejecución}
Para ejecutar una aplicación usamos la máquina virtual proporcionada por el \textit{jdk}, proporcionando el nombre de la clase:

\begin{alltt}
% java HolaMundo
\end{alltt}

A partir de la versión 11 del jdk\footnote{ \footnote{\href{https://www.codejava.net/java-core/tools/run-a-java-program-directly-from-source-code-file}{Ver: codejava.net}}
}, podemos ejecutar directamente ejemplos pequeños de código java. Se compila y ejecuta, sin generar el código \textit{.class} correspondiente:

\begin{alltt}
% java HolaMundo.java
\end{alltt}


%Para la ejecución de un \textit{applet} utilizamos el \textit{appletviewer}, también proporcionado por el \textit{jdk}:

%\begin{alltt}
% appletviewer hola.html
%\end{alltt}

%La ejecución del \textit{applet} desde Eclipse implica seleccionar la opción de \textit{“Run as…”} y posteriormente \textit{“Java Applet”} del menú o icono de ejecución, o del menú contextual.

%Un \textit{applet}  en realidad es construido para se ejecutado por un navegador. El \textit{appletviewer} es una versión reducida de un navegador que es utilizada para probar los \textit{applets}. Un vez que vean que su \textit{applet} se ejecuta en el visor de \textit{applets} pruébenlo en su navegador.

%Es recomendable que primero prueben los \textit{applets} en el visor, ya que este soporta la misma versión de Java del \textit{jdk} que tengan instalado. Dependiendo de su configuración, los navegadores no siempre soportan la última versión de Java.

\section{Fundamentos del Lenguaje Java}
En esta sección se hablará de cómo está constituido el lenguaje, sus instrucciones, tipos de datos, entre otras características. Antes de comenzar a hacer programación orientada a objetos.

\subsection{Comentarios}

Los comentarios en los programas fuente son muy importantes en cualquier lenguaje. Sirven para aumentar la facilidad de comprensión del código y para recordar ciertas cosas sobre el mismo. Son porciones del programa fuente que el compilador omite, y, por tanto, no ocuparán espacio en el archivo de clase. 

Existen tres tipos de comentarios en Java:

\begin{itemize}
\item  Si el comentario que se desea escribir es de una sola línea, basta con poner dos barras inclinadas //. Por ejemplo:
\end{itemize}

\begin{minted}{java}
for (i=0; i<20;i++) // comentario de ciclo { 
	System.out.println(“Adiós”);
}
\end{minted}

No puede ponerse código después de un comentario introducido por // en la misma línea, ya que desde la aparición de las dos barras inclinadas // hasta el final de la línea es considerado como comentario e ignorado por el compilador.

\begin{itemize}
\item Si un comentario debe ocupar más de una línea, hay que anteponerle /* y al final */. Por ejemplo:
\end{itemize}

\begin{minted}{java}
/* Esto es un
comentario que
ocupa tres líneas */
\end{minted}

\begin{itemize}
\item Existe otro tipo de comentario que sirve para generar documentación automáticamente en formato HTML mediante la herramienta javadoc. Puede ocupar varias líneas y se inicia con /** para terminar con */. Para mas información ver:  \url{http://java.sun.com/j2se/javadoc/}  
\end{itemize}

\subsection{Tipos de datos}

En Java existen dos tipos principales de datos:

\begin{enumerate}
\item  Tipos de datos \textbf{simples}.
\item  \textbf{Referencias} a objetos.
\end{enumerate}

Los tipos de datos simples son aquellos que pueden utilizarse directamente en un programa, sin necesidad del uso de clases. Estos tipos son:

\begin{itemize}
\item  byte
\item  short
\item  int
\item  long
\item  float
\item  double 
\item  char 
\item  boolean
\end{itemize}

El segundo tipo está formado por todos los demás. Se les llama referencias porque en realidad lo que se almacena en los mismos son punteros a áreas de memoria donde se encuentran almacenadas las estructuras de datos que los soportan. Dentro de este grupo se encuentran las clases (objetos) y también se incluyen las interfaces, los vectores y las cadenas o \textit{Strings}.

Pueden realizarse conversiones entre los distintos tipos de datos (incluso entre simples y referenciales), bien de forma implícita o de forma explícita.

\subsubsection{Tipos de datos simples}

Los tipos de datos simples en Java tienen las siguientes características:


\begin{table}[]
\resizebox{\textwidth}{!}{%

\begin{tabular}{|l|l|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
 \textbf{Tipo} & \textbf{Descripción} & \textbf{Formato} & \textbf{Longitud}& \textbf{Rango} \\  \hline
 \textbf{byte} & byte & C-2\footnote{C-2 = Complemento a dos.}&1 byte&- 128 … 127\\  \hline
 \textbf{short} & entero corto & C-2&2 bytes&- 32.768 … 32.767 \\  \hline
 \textbf{int} & entero & C-2&4 bytes&- 2.147.483.648 …2.147.483.647 \\  \hline
 \textbf{long} & entero largo & C-2&8 bytes&-9.223.372.036.854.775.808 …9.223.372.036.854.775.807 \\  \hline
 \textbf{float} & real en coma flotante de precisión simple & IEEE 754& 32 bits& $±3,4*10_{-38}$… $±3,4*10_{38}$ \\  \hline
 \textbf{double} & real en coma flotante de precisión doble & IEEE 754&64 bits&$±1,7*10_{-308}$…$ ±1,7*10_{308}$\\  \hline
 \textbf{char} & Carácter & Unicode&2 bytes&0 … 65.535 \\  \hline
 \textbf{boolean} & Lógico &  &1 bit&true / false \\  \hline
 
\end{tabular}%
}
\caption{Tipos de datos simples en Java}
\label{tab:datos_java}
\end{table}


No existen más datos simples en Java. Incluso éstos que se enumeran pueden ser remplazados por clases equivalentes (\textit{Integer}, \textit{Double}, \textit{Byte}, etc.), con la ventaja de que es posible tratarlos como si fueran objetos en lugar de datos simples.

A diferencia de otros lenguajes de programación como C, en Java los tipos de datos simples no dependen de la plataforma ni del sistema operativo. Un entero de tipo \textit{int} siempre tendrá 4 bytes, por lo que no tendremos resultados inesperados al migrar un programa de un sistema operativo a otro. 

Eso sí, Java no realiza una comprobación de los rangos. Por ejemplo: si a una variable de tipo \textit{short} con el valor 32.767 se le suma 1, el resultado será -32.768 y no se producirá ningún error de ejecución. 

Los valores que pueden asignarse a variables y que pueden ser utilizados en expresiones directamente reciben el nombre de literales. 

\subsubsection{Referencias a objetos}
El resto de tipos de datos que no son simples, son considerados referencias. Estos tipos son básicamente apuntadores a las instancias de las clases, en las que se basa la programación orientada a objetos.

Al declarar una variable de objeto perteneciente a una determinada clase, se indica que ese identificador de referencia tiene la capacidad de apuntar a un objeto del tipo al que pertenece la variable. El momento en el que se realiza la reserva física del espacio de memoria es cuando se instancia el objeto realizando la llamada a su constructor, y no en el momento de la declaración.

Existe un tipo referencial especial nominado por la palabra reservada \textit{null} que puede ser asignado a cualquier variable de cualquier clase y que indica que el puntero no tiene referencia a ninguna zona de memoria (el objeto no está inicializado).

\subsection{Identificadores}

Los identificadores son los nombres que se les da a las variables, clases, interfaces, atributos y métodos de un programa.

Existen algunas reglas básicas para nombrar a los identificadores:

\begin{enumerate}
\item Java hace distinción entre mayúsculas y minúsculas, por lo tanto, nombres o identificadores como \textit{var1}, \textit{Var1} y \textit{VAR1} son distintos.
\item Pueden estar formados por cualquiera de los caracteres del código \textit{Unicode}, por lo tanto, se pueden declarar variables con el nombre: \textit{añoDeCreación}, \textit{raïm}, etc.
\item El primer carácter no puede ser un dígito numérico y no pueden utilizarse espacios en blanco ni símbolos coincidentes con operadores. 
\item No puede ser una palabra reservada del lenguaje ni los valores lógicos \textit{true} o \textit{false}.
\item No pueden ser iguales a otro identificador declarado en el mismo ámbito.
\item Por convención, los nombres de las variables y los métodos deberían empezar por una letra minúscula y los de las clases por mayúscula. 
\end{enumerate}

Además, si el identificador está formado por varias palabras, la primera se escribe en minúsculas (excepto para las clases e interfaces) y el resto de palabras se hace empezar por mayúscula (por ejemplo: \textit{añoDeCreación}). Las constantes se escriben en mayúsculas, por ejemplo \textit{MÁXIMO}. 

Esta última regla no es obligatoria, pero es conveniente ya que ayuda al proceso de codificación de un programa, así como a su legibilidad. Es más sencillo distinguir entre clases y métodos, variables o constantes.

\subsection{Variables}

La declaración de una variable se realiza de la misma forma que en C/C++. Siempre contiene el nombre (identificador de la variable) y el tipo de dato al que pertenece. El ámbito de la variable depende de la localización en el programa donde es declarada.

Ejemplo:

\mint[linenos=false]{java}|int x;|

Las variables pueden ser inicializadas en el momento de su declaración, siempre que el valor que se les asigne coincida con el tipo de dato de la variable.

Ejemplo:

\mint[linenos=false]{java}|int x = 0;|

\subsubsection{Ámbito de una variable}

El ámbito de una variable es la porción de programa donde dicha variable es visible para el código del programa y, por tanto, referenciable. El ámbito de una variable depende del lugar del programa donde es declarada, pudiendo pertenecer a cuatro categorías distintas.

\begin{itemize}
\item  Variable local.
\item  Atributo.
\item  Parámetro de un método.
\item  Parámetro de un manejador de excepciones\footnote{Este se tocará en otra etapa del curso, al hablar de manejo de excepciones.}.
\end{itemize}

Como puede observarse, no existen las variables globales. La utilización de variables globales es considerada peligrosa, ya que podría ser modificada en cualquier parte del programa y por cualquier procedimiento. A la hora de utilizarlas hay que buscar dónde están declaradas para conocerlas y dónde son modificadas para evitar sorpresas en los valores que pueden contener.

Los ámbitos de las variables u objetos en Java siguen los criterios “clásicos”, al igual que en la mayoría de los lenguajes de programación como Pascal, C++, etc. 

Si una variable que \textbf{no es local} no ha sido inicializada, tiene un valor asignado por defecto. Este valor es, para las variables referencias a objetos, el valor \textit{null}. Para las variables de tipo numérico, el valor por defecto es cero, las variables de tipo \textit{char}, el valor ‘\\u0000’ y las variables de tipo \textit{boolean}, el valor \textit{false}.

\paragraph{Variables locales}

 Una variable local se declara dentro del cuerpo de un método de una clase y es visible únicamente dentro de dicho método. Se puede declarar en cualquier lugar del cuerpo, incluso después de instrucciones ejecutables, aunque es una buena costumbre declararlas justo al principio.

\subsection{Operadores}
Los operadores son partes indispensables en la construcción de expresiones. Existen muchas definiciones técnicas para el término expresión. Puede decirse que una expresión es una combinación de operandos ligados mediante operadores.

Los operandos pueden ser variables, constantes, funciones, literales, etc. y los operadores se comentarán a continuación.

\subsubsection{Operadores aritméticos:}

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
 Operador&Formato&Descripción  \\ \hline
 +&op1 + op2 &Suma aritmética de dos operandos  \\ \hline
 -&op1 - op2  &Resta aritmética de dos operandos  \\ \hline
 -op1&  &Cambio de signo  \\ \hline
 *&op1 * op2  &Multiplicación de dos operandos  \\ \hline
 /&op1 / op2  &División entera de dos operandos  \\ \hline
 \%&op1 \% op2  &Resto de la división entera ( o módulo)  \\ \hline
 ++& ++op1  &Incremento unitario \\ \hline
  &op1++  &  \\ \hline
 - -&- -op1  &Decremento unitario  \\ \hline
  &op1- -  &  \\ \hline
 
\end{tabular}%
}
\caption{Operadores aritméticos Java}
\label{tab:op_arit_java}
\end{table}


El operador - puede utilizarse en su versión unaria ( - op1 ) y la operación que realiza es la de invertir el signo del operando.

Como en C/C++, los operadores unarios ++ y -- realizan un incremento y un decremento respectivamente. Estos operadores admiten notación prefija y postfija. Ver Cuadro \ref{tab:op_arit_java}

\begin{itemize}
\item ++op1: En primer lugar realiza un incremento (en una unidad) de \textit{op1} y después ejecuta la instrucción en la cual está inmerso.
\item  op1++: En primer lugar ejecuta la instrucción en la cual está inmerso y después realiza un incremento (en una unidad) de \textit{op1}.
\item  --op1: En primer lugar realiza un decremento (en una unidad) de \textit{op1} y después ejecuta la instrucción en la cual está inmerso. Visión General y elementos básicos del lenguaje.
\item  op1--: En primer lugar ejecuta la instrucción en la cual está inmerso y después realiza un decremento (en una unidad) de \textit{op1}.
\end{itemize}

La diferencia entre la notación prefija y la postfija no tiene importancia en expresiones en las que únicamente existe dicha operación:

\begin{minted}{java}
++contador; //es equivalente a: contador++;
--contador; //contador--;
\end{minted}

La diferencia es apreciable en instrucciones en las cuáles están incluidas otras operaciones.

Ejemplo:

\begin{minted}{java}
a = 1; a = 1;
b = 2 + a++; b = 2 + ++a;
\end{minted}


En el primer caso, después de las operaciones, b tendrá el valor 3 y al valor 2. En el segundo caso, después de las operaciones, b tendrá el valor 4 y al valor 2.

\subsubsection{Operadores relacionales:}

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
 Operador&Formato&Descripción  \\ \hline
 $>$&op1 $>$ op2 &Devuelve \textit{true} si op1 es mayor que op2  \\ \hline
 $<$&op1 $<$ op2  &Devuelve \textit{true} si op1 es menor que op2  \\ \hline
 $>$=&op1 $>=$ op2 &Devuelve \textit{true} si op1 es mayor o igual que op2 \\ \hline
 $<=$&op1 $<=$ op2  &Devuelve \textit{true} si op1 es menor o igual que op2  \\ \hline
 ==&op1 == op2  &Devuelve \textit{true}  si op1 es igual a op2  \\ \hline
 !=&op1 != op2  &Devuelve \textit{true}  si op1 es distinto de op2 \\ \hline
 
\end{tabular}%
}
\caption{Operadores relacionales en Java}
\label{tab:op_rel_java}
\end{table}

Los operadores relacionales actúan sobre valores enteros, reales y caracteres; y devuelven un valor del tipo booleano (\textit{true} o \textit{false}). Ver Cuadro \ref{tab:op_rel_java}

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}

public class Relacional {
	public static void main(String arg[]) {
		double op1,op2;
		op1=1.34;
		op2=1.35;
		System.out.println("op1="+op1+" op2="+op2);
		System.out.println("op1>op2 = "+(op1>op2));
		System.out.println("op1<op2 = "+(op1<op2));
		System.out.println("op1==op2 = "+(op1==op2));
		System.out.println("op1!=op2 = "+(op1!=op2));
		char op3,op4;
		op3='a'; op4='b';
		System.out.println("'a'>'b' = "+(op3>op4));
	}
}
\end{minted}
\caption{Ejemplo de operadores relacionales en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Operadores lógicos:}

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
 Operador&Formato&Descripción  \\ \hline
 \&\& &op1 \&\& op2 &Y lógico. Devuelve \textit{true} si son ciertos op1 y op2  \\ \hline
 $||$&op1 $||$ op2  &O lógico. Devuelve \textit{true} si son ciertos op1 o op2  \\ \hline
 !&!op1&Negación lógica. Devuelve \textit{true} si es falso op1. \\ \hline
 
\end{tabular}%
}
\caption{Operadores lógicos en Java}
\label{tab:op_log_java}

\end{table}

Estos operadores actúan sobre operadores o expresiones lógicas, es decir, aquellos que se evalúan a cierto o falso. Ver Cuadro \ref{tab:op_log_java}

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}

public class Bool {
	public static void main ( String argumentos[] ) {
		boolean a=true;
		boolean b=true;
		boolean c=false;
		boolean d=false;
		System.out.println("true Y true = " + (a && b) );
		System.out.println("true Y false = " + (a && c) );
		System.out.println("false Y false = " + (c && d) );
		System.out.println("true O true = " + (a || b) );
		System.out.println("true O false = " + (a || c) );
		System.out.println("false O false = " + (c || d) );
		System.out.println("NO true = " + !a);
		System.out.println("NO false = " + !c);
		System.out.println("(3 > 4) Y true = " + ((3 >4) && a) );
	}
}
\end{minted}
\caption{Ejemplo de operadores lógicos en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Operadores de asignación:}

El operador de asignación es el símbolo igual ( = ).

\mint[linenos=false]{java}|op1 = Expresión;|

Asigna el resultado de evaluar la expresión de la derecha a \textit{op1}.

Además del operador de asignación existen unas abreviaturas, como en C/C++,  cuando el operando que aparece a la izquierda del símbolo de asignación también aparece a la derecha del mismo. Ver Cuadro \ref{tab:op_asig_java}


% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
 Operador & Formato & Equivalencia  \\ \hline
 $ += $ & $ op1 += op2 $ & $ op1 = op1 + op2 $  \\ \hline
 $ -= $ & $ op1 -= op2 $ & $ op1 = op1 - op2 $ \\ \hline
 $ *= $ & $ op1 *= op2 $ & $ op1 = op1 * op2 $ \\ \hline
 $ /= $ & $ op1 /= op2 $ & $ op1 = op1 / op2 $ \\ \hline
 $ \%= $ & $ op1 \%= op2 $ & $ op1 = op1 \% op2 $ \\ \hline

\end{tabular}%
}
\caption{Operadores de asignación en Java}
\label{tab:op_asig_java}

\end{table}

\subsubsection{Precedencia de operadores en Java}

La precedencia (ver Cuadro \ref{tab:prec_op_java})indica el orden en que es resuelta una expresión, la siguiente lista muestra primero los operadores de mayor precedencia.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
 Tipo de operador & Operadores   \\ \hline
 Operadores postfijos & $[] . (parentesis)$   \\ \hline
 Operadores unarios & $++expr --expr -expr ~ !$   \\ \hline
 Creación o conversión de tipo & $new (tipo)expr$  \\ \hline
 Multiplicación y división & $* / \%$  \\ \hline
 Suma y resta & $ + - $ \\ \hline
 Desplazamiento de bits & $<< >> >>>$ \\ \hline
 Relacionales & $< > <= >=$ \\ \hline
 Igualdad y desigualdad &  $==    !=$ \\ \hline
 AND a nivel de bits & $\&$ \\ \hline
 %XOR a nivel de bits & $\^$ \\ \hline
 OR a nivel de bits & $|$ \\ \hline
 AND lógico & $\&\&$ \\ \hline
 OR lógico & $\|$ \\ \hline
 Condicional terciaria & $ ? : $ \\ \hline
 Asignación & $= += -= *= /= \%=   \&= |=  >>=  <<=  >>>= $ \\ \hline %Faltó 
\end{tabular}%
}
\caption{Precedencia de operadores en Java}
\label{tab:prec_op_java}
\end{table}
\
\subsection{Valores literales}

A la hora de tratar con valores de los tipos de datos simples (y \textit{Strings}) se utiliza lo que se denomina “literales”. Los literales son elementos que sirven para representar un valor en el código fuente del programa.

En Java existen literales para los siguientes tipos de datos:

\begin{itemize}
\item  Lógicos (\textit{boolean}).
\item  Carácter (\textit{char}).
\item  Enteros (\textit{byte}, \textit{short}, \textit{int} y \textit{long}).
\item  Reales (\textit{double} y \textit{float}).
\item  Cadenas de caracteres (\textit{String}).
\end{itemize}

\subsubsection{Literales lógicos}

Son únicamente dos: las palabras reservadas \textit{true} y \textit{false}.

Ejemplo:
\mint[linenos=false]{java}|boolean activado = false;|


\subsubsection{Literales de tipo entero}

Son \textit{byte}, \textit{short}, \textit{int} y \textit{long} pueden expresarse en decimal (base 10), octal (base 8) o hexadecimal (base 16). Además, puede añadirse al final del mismo la letra L para indicar que el entero es considerado como \textit{long} (64 bits).

\subsubsection{Literales de tipo real}

Los literales de tipo real sirven para indicar valores float o double. A diferencia de los literales de tipo entero, no pueden expresarse en octal o hexadecimal. 

Existen dos formatos de representación: mediante su parte entera, el punto decimal ( . ) y la parte fraccionaria; o mediante notación exponencial o científica:

Ejemplos equivalentes:

\begin{alltt}
3.1415
0.31415e1
.31415e1
0.031415E+2
.031415e2
314.15e-2
31415E-4
\end{alltt}

Al igual que los literales que representan enteros, se puede poner una letra como sufijo. Esta letra puede ser una F o una D (mayúscula o minúscula indistintamente).

\begin{itemize}
\item   F 	Trata el literal como de tipo \textit{float}.
\item   D 	Trata el literal como de tipo \textit{double}.
\end{itemize}

Ejemplo:

\begin{alltt}
3.1415F
.031415d
\end{alltt}



\subsubsection{Literales de tipo carácter}

Los literales de tipo carácter se representan siempre entre comillas simples. Entre las comillas simples puede aparecer:

\begin{itemize}
\item  Un símbolo (letra) siempre que el carácter esté asociado a un código \textit{Unicode}. Ejemplos: ‘a’ , ‘B’ , ‘\{‘ , ‘ñ’ , ‘á’ .
\item Una “secuencia de escape”. Las secuencias de escape son combinaciones del símbolo \ seguido de una letra, y sirven para representar caracteres que no tienen una equivalencia en forma de símbolo.
\end{itemize}

Las posibles secuencias de escape se pueden ver en el Cuadro \ref{tab:sec_esc_java}

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
 Secuencia de escape &Significado  \\ \hline
  \textbackslash{'} & 	Comilla simple. \\ \hline
 \textbackslash{'' }	&		Comillas dobles. \\ \hline
  \textbackslash{\textbackslash } 	&		Barra invertida. \\ \hline
\textbackslash{b} 	&		Backspace (Borrar hacia atrás). \\ \hline
\textbackslash{n} 	&		Cambio de línea. \\ \hline
\textbackslash{f} 	&		Form feed. \\ \hline
\textbackslash{r} 	&		Retorno de carro. \\ \hline
\textbackslash{t} 	&		Tabulador. \\ \hline
\end{tabular}%
}
\caption{Secuencias de escape en Java}
\label{tab:sec_esc_java}

\end{table}

\subsubsection{Literales de tipo \textit{String}}

Los \textit{Strings} o cadenas de caracteres no forman parte de los tipos de datos elementales en Java, sino que son instanciados a partir de la clase \textit{java.lang.String}, pero aceptan su inicialización a partir de literales de este tipo.

Un literal de tipo \textit{String} va encerrado entre comillas dobles ( “ ) y debe estar incluido completamente en una sola línea del programa fuente (no puede dividirse en varias líneas). Entre las comillas dobles puede incluirse cualquier carácter del código \textit{Unicode} (o su código precedido del carácter \textbackslash ) además de las secuencias de escape vistas anteriormente en los literales de tipo carácter. Así, por ejemplo, para incluir un cambio de línea dentro de un literal de tipo \textit{String} deberá hacerse mediante la secuencia de escape \textbackslash{n} :

Ejemplo:
\begin{minted}{java}
System.out.println("Primera línea \n Segunda línea del string\n");
System.out.println("Hol\u0061");
\end{minted}

La visualización del \textit{String} anterior mediante \textit{println()} produciría la siguiente salida por pantalla:

\begin{alltt}
Primera línea
Segunda línea del string
Hola
\end{alltt}

La forma de incluir los caracteres: comillas dobles ( “ ) y barra invertida ( \textbackslash ) es mediante las secuencias de escape \textbackslash{''} y \textbackslash{\textbackslash} respectivamente (o mediante su código \textit{Unicode} precedido de \textbackslash ).

Si la cadena es demasiado larga y debe dividirse en varias líneas en el código fuente, o simplemente concatenar varias cadenas,  puede utilizarse el operador de concatenación de \textit{strings} + .de la siguiente forma:

\begin{alltt}
''Este String es demasiado largo para estar en una línea'' +
''del código fuente y se ha dividido en dos.''
\end{alltt}

\subsection{Estructuras de control}

Las estructuras de control son construcciones definidas a partir de palabras reservadas del lenguaje que permiten modificar el flujo de ejecución de un programa. De este modo, pueden crearse construcciones de decisión y ciclos de repetición de bloques de instrucciones.

Hay que señalar que, como en C/C++,  un bloque de instrucciones se encontrará encerrado mediante llaves \{.....\} si existe más de una instrucción.

\subsubsection{Estructuras condicionales}

Las estructuras condicionales o de decisión son construcciones que permiten alterar el flujo secuencial de un programa, de forma que en función de una condición o el valor de una expresión, el mismo pueda ser desviado en una u otra alternativa de código.

Las estructuras condicionales disponibles en Java son:
\begin{itemize}
\item Estructura if-else.
\item Estructura switch.
\end{itemize}

\textbf{if-else}

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
Forma simple:
    \begin{minted} [linenos=false]{java}
if (<expresión>)
    <Bloque instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}


El bloque de instrucciones se ejecuta si, y sólo si, la expresión (que debe ser lógica) se evalúa a verdadero, es decir, se cumple una determinada condición.

Ejemplo:

\begin{minted}{java}
if (cont == 0)
	System.out.println("he llegado a cero");
\end{minted}

La instrucción \textit{System.out.println(“he llegado a cero”); }sólo se ejecuta en el caso de que \textit{cont} contenga el valor cero.

% TABLA con más de una línea de códico
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
Forma bicondicional:
    \begin{minted} [linenos=false]{java}
if (<expresión>)
    <Bloque instrucciones 1>
else
	<Bloque instrucciones 2>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

El bloque de instrucciones 1 se ejecuta si, y sólo si, la expresión se evalúa como verdadero. Y en caso contrario, si la expresión se evalúa como falso, se ejecuta el bloque de instrucciones 2.

Ejemplo:

\begin{minted}{java}
if (cont == 0)
	System.out.println("he llegado a cero");
else
	System.out.println("no he llegado a cero");
\end{minted}

En Java, como en C/C++ y a diferencia de otros lenguajes de programación, en el caso de que el bloque de instrucciones conste de una sola instrucción no necesita ser encerrado en un bloque.


\textbf{instrucción switch}

% TABLA con más de una línea de códico
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
switch (<expresión>) {
case <valor1>: <instrucciones1>;
case <valor2>: <instrucciones2>;
...
case <valorN>: <instruccionesN>;
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

En este caso, a diferencia del \textit{if}, si $<instrucciones1>$, $<instrucciones2>$ ó $<instruccionesN>$ están formados por un bloque de instrucciones sencillas, no es necesario encerrarlas mediante las llaves ( ${ … }$ ).

En primer lugar se evalúa la expresión cuyo resultado puede ser un valor de cualquier tipo. El programa comprueba el primer valor (\textit{valor1}). En el caso de que el valor resultado de la expresión coincida con \textit{valor1}, se ejecutará el bloque $<instrucciones1>$. Pero también se ejecutarían el bloque $<instrucciones2> ... <instruccionesN>$ hasta encontrarse con la palabra reservada \textit{break}. Por lo que comúnmente se añade una instrucción \textit{break} al final de cada caso del \textit{switch}.


Ejemplo:

\begin{minted}{java}
switch (<expresión>) {

	case <valor1>: <instrucciones1>;
				break;
	case <valor2>: <instrucciones2>;
				break;
	...
	case <valorN>: <instruccionesN>;
}
\end{minted}

Si el resultado de la expresión no coincide con $<valor1>$, evidentemente no se ejecutarían $<instrucciones1>$, se comprobaría la coincidencia con $<valor2>$ y así sucesivamente hasta encontrar un valor que coincida o llegar al final de la construcción \textit{switch}. En caso de que no exista ningún valor que coincida con el de la expresión, no se ejecuta ninguna acción.

\textcolor{blue}{Ejemplo:}


\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}

public class DiaSemana {
	public static void main(String argumentos[]) {
		int dia;
		if (argumentos.length<1) {
			System.out.println("Uso: DiaSemana num");
			System.out.println("Donde num= nº entre 1 y 7");
		}
		else {
			dia=Integer.valueOf(argumentos[0]);
			// también: dia=Integer.parseInt(argumentos[0]);
			switch (dia) {
			case 1: System.out.println("Lunes");
			break;
			case 2: System.out.println("Martes");
			break;
			case 3: System.out.println("Miércoles");
			break;
			case 4: System.out.println("Jueves");
			break;
			case 5: System.out.println("Viernes");
			break;
			case 6: System.out.println("Sábado");
			break;
			case 7: System.out.println("Domingo");
			}
		}
	}
}
\end{minted}
\caption{Ejemplo de uso de switch en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Nótese que en el caso de que se introduzca un valor no comprendido entre 1 y 7, no se realizará ninguna acción. Esto puede corregirse agregando la opción por omisión:

\mint[linenos=false]{java}|default: instruccionesPorDefecto;|


donde la palabra reservada \textit{default}, sustituye a $case <expr>$ para ejecutar el conjunto de instrucciones definido en caso de que no coincida con ningún otro caso.

\textbf{Expresión switch}

En la versión de \textbf{Java 12 y posteriores}, se introdujo una nueva característica llamada \textit{expresión switch }, que permite un uso más conciso del switch. El estilo sería el siguiente.

\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
int resultado = switch (expresion) {
    case valor1 -> {
        // Código a ejecutar si la expresión es igual a valor1
        yield resultado1; // Opcional: valor a devolver
    }
    case valor2 -> {
        // Código a ejecutar si la expresión es igual a valor2
        yield resultado2; // Opcional: valor a devolver
    }
    // Otros casos aquí
    default -> {
        // Código a ejecutar si ninguno de los casos anteriores se cumple
        yield resultadoDefault; // Opcional: valor a devolver
    }
};

    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Esta sintaxis permite un código más limpio y expresivo y también es capaz de devolver un valor en función del caso que coincida.

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class DiaSemana {
    public static void main(String argumentos[]) {
        int dia;
        if (argumentos.length < 1) {
            System.out.println("Uso: DiaSemana num");
            System.out.println("Donde num= nº entre 1 y 7");
        } else {
            dia = Integer.valueOf(argumentos[0]);
            // También: dia = Integer.parseInt(argumentos[0]);
            String diaDeLaSemana = switch (dia) {
                case 1 -> "Lunes";
                case 2 -> "Martes";
                case 3 -> "Miércoles";
                case 4 -> "Jueves";
                case 5 -> "Viernes";
                case 6 -> "Sábado";
                case 7 -> "Domingo";
                default -> "Día no válido";
            };
            System.out.println(diaDeLaSemana);
        }
    }
}
\end{minted}
\caption{Ejemplo de uso de la \textbf{expresión} switch en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Ciclos}

Los ciclos o iteraciones son estructuras de repetición. Bloques de instrucciones que se repiten un número de veces \textbf{mientras} se cumpla una condición o \textbf{hasta} que se cumpla una condición.

Existen tres construcciones para estas estructuras de repetición:

\begin{itemize}
\item Ciclo for.
\item Ciclo do-while.
\item Ciclo while.
\end{itemize}

Como regla general puede decirse que se utilizará el ciclo for cuando se conozca de antemano el número exacto de veces que ha de repetirse un determinado bloque de instrucciones. Se utilizará el ciclo \textit{do-while} cuando no se conoce exactamente el número de veces que se ejecutará el ciclo pero se sabe que por lo menos se ha de ejecutar una. Se utilizará el ciclo \textit{while} cuando es posible que no deba ejecutarse ninguna vez. Con mayor o menor esfuerzo, puede utilizarse cualquiera de ellas indistintamente.

\textbf{Ciclo for}

% TABLA con más de una línea de códico
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
for  (<inicialización> ; <condición> ; <incremento>)
	<bloque instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}


\begin{itemize}
\item La cláusula inicialización es una instrucción que se ejecuta una sola vez al inicio del ciclo, normalmente para inicializar un contador.
\item La cláusula condición es una expresión lógica, que se evalúa al inicio de cada nueva iteración del ciclo. En el momento en que dicha expresión se evalúe a falso, se dejará de ejecutar el ciclo y el control del programa pasará a la siguiente instrucción (a continuación del ciclo \textit{for}).
\item La cláusula incremento es una instrucción que se ejecuta en cada iteración del ciclo como si fuera la última instrucción dentro del bloque de instrucciones. Generalmente se trata de una instrucción de incremento o decremento de alguna variable.
\end{itemize}

Cualquiera de estas tres cláusulas puede estar vacía, aunque siempre hay que poner los puntos y coma ( ; ).

El siguiente programa muestra en pantalla la serie de \textit{Fibonacci} hasta el término que se indique al programa como argumento en la línea de comandos. 
Siempre se mostrarán, por lo menos, los dos primeros términos

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// siempre se mostrarán, por lo menos, los dos primeros //términos
public class Fibonacci {
	public static void main(String argumentos[]) {
		int numTerm,v1=1,v2=1,aux,cont;
		if (argumentos.length<1) {
			System.out.println("Uso: Fibonacci num");
			System.out.println("Donde num = nº de términos");
		}
		else {
			numTerm=Integer.valueOf(argumentos[0]);
			System.out.print("1,1");
			for (cont=2;cont<numTerm;cont++) {
				aux=v2;
				v2+=v1;
				v1=aux;
				System.out.print(","+v2);
			}
			System.out.println();
		}
	}
}
\end{minted}
\caption{Ejemplo Fibonacci con ciclo \textit{for}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textbf{Ciclo do-while}

% TABLA con más de una línea de códico
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
do
	<bloque instrucciones>
while (<Expresión>);
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

En este tipo de ciclo, el bloque instrucciones se ejecuta siempre una vez por lo menos, y el bloque de instrucciones se ejecutará mientras $<Expresion>$ se evalúe como verdadero. Por lo tanto, entre las instrucciones que se repiten deberá existir alguna que, en algún momento, haga que la expresión se evalúe como falso, de lo contrario el ciclo sería infinito.

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//El mismo que antes (Fibonacci).
public class Fibonacci2 {
	public static void main(String argumentos[]) {
		int numTerm,v1=0,v2=1,aux,cont=1;
		if (argumentos.length<1) {
			System.out.println("Uso: Fibonacci num");
			System.out.println("Donde num = nº de términos");
		}
		else {
			numTerm=Integer.valueOf(argumentos[0]);
			System.out.print("1");
			do {
				aux=v2;
				v2+=v1;
				v1=aux;
				System.out.print(","+v2);
			} while (++cont<numTerm);
			System.out.println();
		}
	}
}
\end{minted}
\caption{Ejemplo Fibonacci con ciclo \textit{do-while}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este caso únicamente se muestra el primer término de la serie antes de iniciar el ciclo, ya que el segundo siempre se mostrará, porque el ciclo do-while siempre se ejecuta una vez por lo menos.

\textbf{Ciclo while}

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
while (<Expresión>)
    <bloque instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Al igual que en el ciclo \textit{do-while} del apartado anterior, el bloque de instrucciones se ejecuta mientras se cumple una condición (mientras \textit{Expresión} se evalúe verdadero), pero en este caso, la condición se comprueba antes de empezar a ejecutar por primera vez el ciclo, por lo que si \textit{Expresión} se evalúa como falso en la primera iteración, entonces el bloque de instrucciones no se ejecutará ninguna vez.


\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Fibonacci:
public class Fibonacci3 {
	public static void main(String argumentos[]) {
		int numTerm,v1=1,v2=1,aux,cont=2;
		if (argumentos.length<1) {
			System.out.println("Uso: Fibonacci num");
			System.out.println("Donde num = nº de términos");
		}
		else {
			numTerm=Integer.valueOf(argumentos[0]);
			System.out.print("1,1");
			while (cont++<numTerm) {
				aux=v2;
				v2+=v1;
				v1=aux;
				System.out.print(","+v2);
			}
			System.out.println();
		}
	}
}
\end{minted}
\caption{Ejemplo Fibonacci con ciclo \textit{while}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Como puede comprobarse, las tres construcciones de ciclo (\textit{for}, \textit{do-while} y \textit{while}) pueden utilizarse indistintamente realizando unas pequeñas variaciones en el programa.


\subsubsection{Saltos}

En Java existen dos formas de realizar un salto incondicional en el flujo normal de un programa: las instrucciones \textit{break} y \textit{continue}.

\paragraph{break} La instrucción break sirve para abandonar una estructura de control, tanto de la alternativa (\textit{switch}) como de las repetitivas o ciclos (\textit{for}, \textit{do-while} y \textit{while}). En el momento que se ejecuta la instrucción \textit{break}, el control del programa sale de la estructura en la que se encuentra.

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class Break {
	public static void main(String argumentos[]) {
		int i;
		for (i=1; i<=4; i++) {
			if (i==3) 
				break;
			System.out.println("Iteracion: "+i);
		}
	}
}
\end{minted}
\caption{Ejemplo de uso de \textit{break}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Aunque el ciclo, en principio indica que se ejecute 4 veces, en la tercera iteración, i contiene el valor 3, se cumple la condición de \textit{i==3} y por lo tanto se ejecuta el \textit{break} y se sale del ciclo \textit{for}.

\paragraph{continue} La instrucción \textit{continue} sirve para transferir el control del programa desde la instrucción \textit{continue} directamente a la cabecera del ciclo (\textit{for}, \textit{do-while} o
\textit{while}) donde se encuentra.

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class Continue {
	public static void main(String argumentos[]) {
		int i;
		for (i=1; i<=4; i++) {
			if (i==3) 
				continue;
			System.out.println("Itereación: "+i);
		}
	}
}
\end{minted}
\caption{Ejemplo de uso de \textit{continue}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Puede comprobarse la diferencia con respecto al resultado del ejemplo del apartado anterior. En este caso no se abandona el ciclo, sino que se transfiere el control a la cabecera del ciclo donde se continúa con la siguiente iteración.

Tanto el salto \textit{break} como en el salto \textit{continue}, pueden ser evitados mediante distintas construcciones pero en ocasiones esto puede empeorar la legibilidad del código. De todas formas existen programadores que no aceptan este tipo de saltos y no los utilizan en ningún caso; la razón es que - se dice - que atenta contra las normas de las estructuras de control.

\subsection{Arreglos}

Para manejar colecciones de objetos del mismo tipo estructurados en una sola variable se utilizan los arreglos.

En Java, los arreglos son en realidad objetos y por lo tanto se puede llamar a sus métodos. Existen dos formas equivalentes de declarar arreglos en Java:

\mint[linenos=false]{java}|tipo nombreDelArreglo[  ];|

o

\mint[linenos=false]{java}|tipo[  ] nombreDelArreglo;|

Ejemplo:

\begin{minted}{java}
int arreglo1[], arreglo2[], entero; //entero no es un arreglo
int[] otroArreglo;
\end{minted}

También pueden utilizarse arreglos de más de una dimensión:

Ejemplo:

\begin{minted}{java}
int matriz[][];
int [][] otraMatriz;
\end{minted}

Los arreglos, al igual que las demás variables pueden ser inicializados en el momento de su declaración. En este caso, no es necesario especificar el número de elementos máximo reservado. Se reserva el espacio justo para almacenar los elementos añadidos en la declaración.

Ejemplo:
\begin{minted}{java}
String Días[]={"Lunes","Martes","Miércoles","Jueves",
		"Viernes","Sábado","Domingo"};
\end{minted}

Una simple declaración de un vector no reserva espacio en memoria, a excepción del caso anterior, en el que sus elementos obtienen la memoria necesaria para ser almacenados. Para reservar la memoria hay que llamar explícitamente a \textit{new} de la siguiente forma:

\mint[linenos=false]{java}|new tipoElemento[ <numElementos> ];|

Ejemplo:

\begin{minted}{java}
int matriz[][];
matriz = new int[4][7];
\end{minted}

También se puede indicar el número de elementos durante su declaración:

Ejemplo:

\mint[linenos=false]{java}|int vector[] = new int[5];|

Para hacer referencia a los elementos particulares del arreglo, se utiliza el identificador del arreglo junto con el índice del elemento entre corchetes. El índice del primer elemento es el cero y el del último, el número de elementos menos uno.

Ejemplo:

\mint[linenos=false]{java}|j = vector[0]; vector[4] = matriz[2][3];|

El intento de acceder a un elemento fuera del rango del arreglo, a diferencia de lo que ocurre en C, provoca una excepción (error) que, de no ser manejado por el programa, será la máquina virtual quien aborte la operación. 

Para obtener el número de elementos de un arreglo en tiempo de ejecución se accede al atributo de la clase llamado \textit{length}. No olvidemos que los arreglos en Java son tratados como un objeto.

\textcolor{blue}{Ejemplo:}

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class Array1 {
	public static void main (String argumentos[]) {
		String colores[] = {"Rojo","Verde","Azul",
				"Amarillo","Negro"};
		int i;
		for (i=0;i<colores.length;i++)
			System.out.println(colores[i]);
	}
}
\end{minted}
\caption{Ejemplo de uso de arreglo.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Usando al menos Java 5.0 (jdk 1.5)  podemos simplificar el recorrido del arreglo:

\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class Meses {

	public static void main(String[] args) {
	    String meses[] = 
	       {"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", 
	       "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"};

	   //for(int i = 0; i < meses.length; i++ ) 
	   //   System.out.println("mes: " + meses[i]);
	   	    
	   // sintaxis para recorrer el arreglo y asignar
	   // el siguiente elemento a la variable mes en cada ciclo
	   // instruccion "for each" a partir de version 5.0 (1.5 del jdk) 
	   for(String mes: meses) 
	      System.out.println("mes: " + mes);

	}

}
\end{minted}
\caption{Ejemplo de uso de arreglo 2.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Enumeraciones}

Java desde la versión 5 incluye el manejo de enumeraciones. Las enumeraciones sirven para agrupar un conjunto de elementos dentro de un tipo definido. Antes, una manera simple de definir un conjunto de elementos como si fuera una enumeración era, por ejemplo:

\begin{minted}{java}
public static final int TEMPO_PRIMAVERA = 0;
public static final int TEMPO_VERANO = 1;
public static final int TEMPO_OTOÑO = 2;
public static final int TEMPO_INVIERNO = 3;
\end{minted}

Lo cual puede ser problemático pues no es realmente un tipo de dato, sino un conjunto de constantes enteras. Tampoco tienen un espacio de nombres definido por lo que tienen que definirse nombre. La impresión de estos datos, puesto que son enteros, despliega solo el valor numérico a menos que sea interpretado explícitamente por código adicional en el programa.

El manejo de enumeraciones en Java tiene la sintaxis de C, C++ y C\# :

%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}|enum <nombreEnum> { <elem 1>, <elem 2>, …, <elem n> }|\\
\hline
\end{tabular}
\end{center}

Por lo que para el código anterior, la enumeración sería:

\mint[linenos=false]{java}|enum Temporada { PRIMAVERA, VERANO, OTOÑO, INVIERNO }|

La sintaxis completa de enum es más compleja, ya que una enumeración en Java es realmente una clase, por lo que puede tener métodos en su definición. También es posible declarar la enumeración como pública, en cuyo caso debería ser declarada en su propio archivo. 

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
enum Temporada { PRIMAVERA, VERANO, OTOÑO, INVIERNO }

public class EnumEj {

	
	public static void main(String[] args) {
		Temporada tem;
		tem=Temporada.PRIMAVERA;
		System.out.println("Temporada: " + tem);
		
        System.out.println("\nListado de temporadas:");
		
        for(Temporada t: Temporada.values())
			System.out.println("Temporada: " + t);
			
	    }
}
\end{minted}
\caption{Ejemplo de enumeración en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Entrada desde consola en Java}

La entrada tradicional en Java desde consola era evitada en libros y cursos en su etapa introductoria, esto debido a que era necesario incluir manejos de \textit{Streams}  o flujos, lo que comúnmente requiere mayor experiencia con el lenguaje y la programación orientada a objetos. 

Sin embargo, a partir de la versión 1.5 del \textit{jdk} se incluye la clase  \textit{Scanner}  que proporciona comportamiento de lectura desde consola. 

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import java.util.Scanner;

public class ScannerTest {

   public static void main(String[] args) {

       String nom;
       int edad;
       Scanner in = new Scanner(System.in);

       System.out.print("Nombre:");
       // Lee una linea de consola
       nom = in.nextLine();

       System.out.print("Edad:");
       // Lee un entero de consola
       edad=in.nextInt(); 
       in.close();            

       System.out.println("Nombre :"+nom);
       System.out.println("Edad :"+edad);

    }
}
\end{minted}
\caption{Ejemplo de entrada de consola en Java con \textit{Scanner}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Operaciones similares a \textit{nexInt()} y\textit{ nextLine()} existen para el resto de los tipos de datos.

La versión 1.6 del \textit{jdk} incluye otra clase: \textit{Console} la cual proporciona el comportamiento de lectura de una linea desde consola y  lectura sin eco (tipo \textit{password}) en la consola.

\textcolor{blue}{Ejemplo\footnote{Ejecutar directamente de consola ya que puede no ejecutarse correctamente en el algunos IDEs.}:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import java.io.Console;

//no funciona en la consola de Eclipse
public class TestConsole {
 
    public static void main(String... args ) {
	
    	// Obtener un objeto de consola
    	Console console = System.console();
    	if (console == null) {
            System.err.println("No se obtuvo la consola.");
            System.exit(1);
        }

    	String usuario = console.readLine("Usuario:");
    	
    	//Lee password y lo recibe en un arreglo de caracteres
    	char[] password = console.readPassword("Password: ");
    	
    	if (usuario.equals("admin") 
    	 && String.valueOf(password).equals("secreto")) {
    	    console.printf("Bienvenido %1$s.\n", usuario);
    	    
    	} else {
    	    console.printf("Usuario o password inválido.\n");	    
    	}
    }
}
\end{minted}
\caption{Ejemplo de entrada de consola en Java con \textit{Console}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Como se pudo apreciar, esta clase también incluye operaciones de salida a consola. También simplifica la salida de caracteres especiales en la consola. 

\subsubsection{Argumentos de cantidad variable}

Ahora, si fueron observadores sabrán que el último ejemplo nos trajo un nuevo tópico: el uso de los $...$ en la operación \textit{main}. Este operador sirve para definir argumentos de cantidad variable, siendo el resultado almacenado en un arreglo del tipo especificado.  \textbf{Podemos combinar los argumentos variables con otros argumentos, pero solo podemos meter un argumento variable y debe ir al final. }

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class TestArgs {
	public static void main(String[] args) {    
		llamame1(new String[] {"a", "b", "c"});    
		llamame2("a", "b", "c");    
		// Otra opción:    
		// llamame2(new String[] {"a", "b", "c"});
	}

	public static void llamame1(String[] args) {    
		for (String s : args)       
			System.out.println(s);    
	}

	public static void llamame2(String... args) {    
		for (String s : args)      
			System.out.println(s);    
	}
}
\end{minted}
\caption{Ejemplo de entrada de argumentos de cantidad variable.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro ejemplo\footnote{Código original de \cite{deitel2012c}}, se presenta a continuación.

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}

public class VarargsTest 
{
// cálculo de promedio
public static double average( double... numbers )
     {
        double total = 0.0; // inicializar total
  
        for ( double d : numbers )              
           total += d;                          
  
        return total / numbers.length;
     } 
  
     public static void main( String args[] ) 
     {
        double d1 = 10.0;
        double d2 = 20.0;
        double d3 = 30.0;
        double d4 = 40.0;
  
        System.out.printf( "d1 = %.1f\nd2 = %.1f\nd3 = %.1f\nd4 = %.1f\n\n",
           d1, d2, d3, d4 );
  
        System.out.printf( "Promedio de d1 y d2 es %.1f\n", 
           average( d1, d2 ) ); 
        System.out.printf( "Promedio de d1, d2 y d3 es %.1f\n", 
           average( d1, d2, d3 ) );
        System.out.printf( "Average de d1, d2, d3 y d4 es %.1f\n", 
           average( d1, d2, d3, d4 ) );
     } 
  } 
\end{minted}
\caption{Ejemplo de entrada de argumentos de cantidad variable.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Paquetes}

Las clases en Java son organizadas mediante paquetes. Un paquete es entonces el mecanismo para agrupas clases que están relacionadas, ya sea porque sirven a un propósito común o porque dependen unas de otras para realizar sus responsabilidades. Se usan los paquetes cuando importamos clases para ser incorporadas en nuestro código, pero si queremos especificar el paquete al que pertenecen nuestras clases podemos hacerlo.

%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}|package [<ruta>]<nombre paquete>|\\
\hline
\end{tabular}
\end{center}

Si no se define el nombre del paquete, por omisión se considera el nombre del directorio donde la clase se encuentra definida.



\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby


\chapter{Introducción a Ruby}

\section{Introducción}

Ruby es un lenguaje definido para ser dinámico, reflexivo y orientado a objetos. Combina una sintaxis inspirada en Perl y similar a las características orientadas a objetos de Smalltalk. También comparte ciertas características con Phyton, Lisp, Dylan, y CLU. 

Ruby fue creado por \textbf{Yukihiro  Matsumoto} con la idea de crear un lenguaje que balanceara la programación funcional con la programación imperativa. 

%https://www.overleaf.com/learn/latex/Wrapping_text_around_figures
\begin{wrapfigure}{O}{0.05\textwidth}
    \centering
    \includegraphics[scale=.6]{imagenes/ruby-lang-matz.png}
\end{wrapfigure}

El lenguaje fue liberado desde un inicio como \textit{open source} (1995) y en los últimos años ha crecido su aceptación masivamente.

Matsumoto dice haber puesto énfasis en crear un lenguaje productivo y divertido, siguiendo los principios de buen diseñó de interfaz con el usuario. Remarca que el diseño de sistemas necesita –también- enfatizar las necesidades humanas, en lugar de las de la computadora.

Ruby es actualmente un lenguaje interpretado aunque se pretende que en futuras versiones sea semi-compilado y ejecutado por una máquina virtual, de manera similar a Java. Además existe un número amplio de implementaciones de Ruby con diferentes aproximaciones.

\section{Características}

%https://www.overleaf.com/learn/latex/Wrapping_text_around_figures
\begin{wrapfigure}{O}{0.05\textwidth}
    \centering
    \includegraphics[scale=.25]{imagenes/2000px-Ruby-logo-R.svg-56a811b75f9b58b7d0f05e83.jpg}

\end{wrapfigure}

Ruby es principalmente un lenguaje orientado a objetos, pero también es descrito como un lenguaje multiparadigma: permite programación procedural, con orientación a objetos y declaraciones funcionales. 

Un resumen de sus características  puede verse enseguida:
\begin{itemize}
\item Orientado a objetos
\item 4 niveles de alcance de variables: global, clase, instancia y local
\item Manejo de excepciones
\item Expresiones regulares nativas al nivel del lenguaje (\textit{perl-like})
\item Sobrecarga de operadores
\item Recolector automático de basura
\item Biblioteca dinámica compartida en la mayoría de las plataformas
\item Soporta introspección, reflexión y metaprogramación
\item Soporta \textit{continuations} y \textit{generators}
\end{itemize}


\subsection{Comparado con C}

Similitudes
\begin{itemize}
\item Puedes programar proceduralmente si lo deseas, pero aún será orientado a objetos internamente.
\item La mayoría de los operadores son los mismos. Pero no cuenta con ++ o --.
\item Se pueden tener constantes, aunque no hay una instrucción \textit{const}.
\item Las cadenas van entre comillas y son mutables.
\item Se cuenta con un depurador en línea.
\end{itemize}

Diferencias
\begin{itemize}
\item Los objetos tienen un tipo fuerte y las variables no tienen tipo.
\item No cuenta con macros o preprocesador.
\item No tiene enmascaramiento.
\item No tiene apuntadores, ni aritmética de apuntadores.
\item No tiene \textit{typedef}, \textit{sizeof}, ni enumeraciones.
\item No archivos de encabezados.
\item Es interpretado en tiempo de ejecución, por lo que no hay código compilado o \textit{bytecode} de ningún tipo (hasta la versión 1.8).
\item Cuenta con recolector de basura.
\item Los argumentos son pasados por referencia, no por valor.
\item No usa ‘;’ obligatoriamente para finalizar instrucciones
\item Condiciones para \textit{if} y \textit{while} van sin paréntesis.
\item Paréntesis para llamadas a métodos son frecuentemente opcionales.
\item Usualmente no se usan llaves, se finalizan las instrucciones de múltiples líneas con una palabra clave.
\item No hay declaraciones de variables. Asignas nombre conforme los necesitas.
\item Sólo falso y nulo evalúan como falso. Cualquier otro valor es verdadero (incluyendo 0 –cero-)
\item No hay tipo \textit{char}.
\item Cadenas no terminan con un valor nulo.
\item Los arreglos automáticamente se agrandan conforme vas necesitando más elementos.
\end{itemize}


\subsection{Comparado con C++}

Similitudes
\begin{itemize}
\item Public, protected y private realizan actividades similares.
\item Puedes poner tu código en módulos, similar a espacios de nombre en C++.
\item Excepciones trabajan de forma similar.
\end{itemize}

Diferencias
\begin{itemize}
\item No hay referencias explícitas. En Ruby cada variable es un nombre automáticamente desreferenciado para un objeto.
\item El constructor es llamado initialize en lugar de usar el nombre de la clase.
\item Todos los métodos son siempre virtuales.
\item Nombres de atributos de clase siempre empiezan con @@.
\item No es posible acceder directamente variables miembros. Todos los atributos deben ser accedidos a mediante métodos.
\item Se usa self en lugar de \textit{this}.
\item Algunos métodos terminan con ‘?’ o ‘!’. Es parte del nombre del método.
\item No hay herencia múltiple.
\item Existen algunas reglas con nombres (e.g., nombre de clases empiezan con mayúscula, variables inician con minúscula.)
\item Solo dos tipos de clases contenedoras: \textit{Array} y \textit{Hash}.
\item No hay conversiones  de tipos automáticas.
\item Multihilos son implementados en el intérprete (\textit{green threads}). No son hilos nativos.
\item Existe una biblioteca para pruebas de unidad como parte estándar del lenguaje.
\end{itemize}

\subsection{Comparado con Java}

Similitudes
\begin{itemize}
\item La memoria es manejada automáticamente mediante un recolector de basura.
\item Los objetos son fuertemente tipados.
\item Hay métodos públicos, privados y protegidos.
\item Tiene herramientas de documentación embebidas (la de Ruby se llama RDoc). La documentación generada por rdoc se ve muy similar a la generada por javadoc.
\end{itemize}

Diferencias
\begin{itemize}
\item No necesitas compilar tu código fuente. Directamente lo ejecutas.
\item Hay distintos conjuntos de herramientas para interfaz gráfica.
\item Se usa la palabra clave \textit{end} después de definir clases, en vez de tener que poner llaves encerrando el código.
\item Tienes require en vez de \textit{import}.
\item Todas las variables de instancia son privadas. Desde afuera, todo se accede usando métodos.
\item Los paréntesis en las llamadas a los métodos usualmente son opcionales y a menudo son omitidos.
\item Todo es un objeto, incluyendo los números como 2 y 3,14159.
\item No hay validación estática de tipos de datos.
\item Los nombres de variables son sólo etiquetas. No tienen un tipo de dato asociado.
\item No hay declaración de tipo de datos. Simplemente se asigna a nuevos nombres de variable a medida que se necesita (por ejemplo $a = [1,2,3]$ en vez de $int[] a = {1,2,3};)$.
\item  No hay transformación de tipos (\textit{casting}). Simplemente se llama a los métodos. Tus pruebas unitarias deberían avisarte antes de que ejecutes el código si habrá una excepción.
\item Es $foo = Foo.new("hola")$ en vez de $Foo foo = new Foo("hola")$.
\item El constructor siempre se llama “initialize” en vez del nombre de la clase.
\item Tienes \textit{mixins} en vez de interfaces.
\item Es \textit{nil} en vez de \textit{null}.
\end{itemize}

\section{Herramientas}

Existen dos herramientas básicas en Ruby:
\begin{itemize}
\item \textbf{ruby}. Es el intérprete del lenguaje. Puede recibir expresiones del lenguaje como parámetros o archivos con programas.
\item \textbf{irb} (o fxri en algunas versiones para Windows). Este es Ruby interactivo (\textit{Interactive RuBy}) que permite recibir expresiones del lenguaje e irlas interpretando línea por línea, como cualquier lenguaje interpretado.
Además:
\item \textbf{ri}. Documentación de clases estándar de ruby.
\end{itemize}

También es posible integrar al interprete al IDE de Eclipse. Para esto se debe agregar el plugin llamado \textit{Ruby Development Tools} (RDT) aparte de tener instalado el interprete en la computadora. El plugin puede ser encontrado en: \url{http://rubyeclipse.sourceforge.net/}. Tiene que agregarse, como cualquier otro plugin en la herramienta, mediante la opción de actualización del software en el menú de ayuda de Eclipse. 

El plugin debe configurarse indicando la ubicación del intérprete:

\includegraphics[scale=.35]{imagenes/rubyEclipse.png}

\section{Ruby: Fundamentos del lenguaje}

\subsection{Convenciones léxicas}

\subsubsection{Espacios en blanco}

Mientras una expresión del tipo $a + b$ es interpretada como $a+b$, donde $a$ es una variable. El resultado puede ser diferente en casos ambiguos. Por ejemplo, si $a$ es el nombre de una función, entonces una expresión:

$a +b$

es interpretada como:

$a (+b)$

\subsubsection{Final de instrucciones}

Ruby interpreta $;$ y el espacio en blanco como el final de una instrucción. Debido a esto, Ruby interpreta los símbolos $+$, $-$  y \textbackslash como continuación de una instrucción.

\subsubsection{Comentarios}

Comentarios en Ruby son representados con $\#$ :

\mint[linenos=false]{ruby}|# Este es un comentario|

Comentarios de más de una línea usan $=begin$ y $=end$, los cuales deben estar al comienzo de una línea:


\begin{minted}{ruby}
=begin 
Este es un comentario
=end
\end{minted}

\subsubsection{Identificadores}

Cualquier nombre de constante, variables y métodos usado como identificador es distinguido por Ruby si usa minúsculas o mayúsculas.


\subsection{Literales}

\subsubsection{Enteros}

Los números enteros  son instancias de la clase \textit{Fixnum} o \textit{Bignum}.

\begin{minted}{ruby}
123                    # decimal
0377                   # octal
0xff                   # hexadecimal
0b1011                 # binary
?a                     # código para 'a'
12345678901234567890   # Bignum: entero de longitud infinita
\end{minted}

\subsubsection{Flotantes}

Los números de punto flotante son instancias de la clase Float.

\begin{minted}{ruby}
123.4                    
1.0e6                    # notación científica
4e+20                    # exponencial
\end{minted}


\subsubsection{Cadenas}

Una cadena es un arreglo de bytes y una instancia de la clase String:

\begin{minted}{ruby}
"una cadena”    # permite sustitución y notación con \
‘otra cadena’     # no permite sustitución y solo \ \ ó \’.
\end{minted}

\subsubsection{Concatenación}

Cadenas adyacentes son concatenadas :

\mint[linenos=false]{ruby}|''una'' ''cadena''      # es igual a ''una cadena''|

\subsection{Variables}

En Ruby existen 5 tipos de variables, usando caracteres especiales para diferenciar entre los distintos tipos de variables, lo que ayuda a identificar el tipo de variable visualmente:


\begin{itemize}
\item  Variable global
\item  Variable de instancia
\item  Variable de clase
\item  Variable local
\item   Constante
\end{itemize}

y además:
\begin{itemize}
\item  Pseudo-variable
\end{itemize}


\subsubsection{Variable global}

Visibles a través de todo el programa y deben iniciar con el símbolo \$, por ejemplo:

\mint[linenos=false]{ruby}|$soyGlobal|

Una variable global no inicializada tiene el valor de \textit{nil}. Existen además variables globales predefinidas que contienen información sobre el programa en ejecución.

\subsubsection{Variable de instancia}

Las variables de instancia pertenecen a un objeto y son lo que también es conocido en objetos como atributos. Estas son visibles dentro de un objeto en particular y deben  comenzar con $@$, por ejemplo:

\mint[linenos=false]{ruby}|@soyVariableDeInstancia|

Al igual que las variables globales, estas tienen el valor de \textit{nil} si no han sido inicializadas.

\subsubsection{Variable de clase}

Las variables de clase son visibles, como su nombre lo dice, en la clase y para todos los objetos de la misma. Comienzan con $@@$, por ejemplo:

\mint[linenos=false]{ruby}|@@variableDeClase|
	
Estas variables deben ser inicializadas antes de que puedan ser usadas en los métodos. El uso de una variable de clase no inicializada produce un error. Además, estas clases son compartidas por descendientes de las clases donde fueron definidas.

\subsubsection{Variable local}

Son válidas dentro del ámbito local definido y deben empezar con una minúscula o con el símbolo $\_$. El ámbito puede ser el que defina una clase, módulo, definición,do –end. 

\subsubsection{Constante}

Deben empezar con una letra mayúscula y pueden ser definidas dentro de una clase o módulo y serán visibles dentro de ese ámbito. Una constante definida fuera de un clase o módulo será vista globalmente. Es posible reasignar un valor a una constante, pero esto producirá una advertencia (pero no un error). 


\subsubsection{Pseudo-variable}

Pseudo-variables tienen la apariencia de variables locales pero su comportamiento es el de constantes. Ejemplo de estas variables son \textit{self}, \textit{true}, \textit{false}, \textit{nil}.


\subsection{Operadores}

\subsubsection{Asignación}

La asignación función con el operador $=$. Asignar variables locales también sirve como declaración de la variable. La variable existe hasta el final del alcance donde la variable es declarada. 

También se cuenta con asignación abreviada como en los lenguajes C/C++ y Java:


\begin{minted}{ruby}
+=  -=  *=  /=  %=  **=  <<=  >>=  &=  |=  ^=  &&=  ||=
\end{minted}

\subsubsection{Asignación paralela}

\mint[linenos=false]{ruby}|destino[, destino...][, *destino] = expr[, expr...][, *expr]|

Identificadores destino reciben la asignación de la correspondiente expresión en el lado derecho. Si el último destino  (lado izquierdo) tiene como prefijo un *, el resto de los valores en el lado derecho se asigna en ese destino como un arreglo. Si el * esta en el último elemento del lado derecho, el conjunto de elementos son expandidos antes de su asignación.

\subsubsection{Operadores lógicos}

$\&\&$ o $and$.	Regresa \textit{true} si ambos operandos son verdaderos.  
Si el operando izquierdo es falso, regresa ese valor, en caso contrario regresa el valor del operando derecho.

$||$ o $or$. Regresa \textit{true} si cualquiera de los operandos es verdadero. 
Si el valor del operando izquierdo es \textit{true}, regresa el valor de ese operando, de otro modo regresa el valor del operando derecho.

Un aspecto interesante aquí es que los operadores \textit{and} y \textit{or} tienen una precedencia muy baja, de hecho tienen la menor de las precedencias entre los operadores.

\subsection{Operador ternario}

El operador ternario $?:$ es el operador condicional similar al de C/C++ y Java.

\mint[linenos=false]{ruby}|a? b : c|

\subsection{Operador \textit{defined?}}

Este es un operador que puede determinar si una expresión esta definida. Regresa una descripción de la expresión, o nulo si la expresión no esta definida.

\mint[linenos=false]{ruby}|defined? variable|

Por ejemplo:

\begin{minted}{ruby}
defined? a
defined? $_
\end{minted}

Puede ser usado para verificar una llamada a un método, opcionalmente incluyendo sus argumentos.

\subsubsection{Prioridad de operadores}

A continuación se presenta los operadores más comunes de Ruby en orden de precedencia, de mayor a menor:

\begin{minted}{ruby}
::
[]
**
+(unario) -(unario) 
* / %
+ -
<< >>
&
| ^
> >= < <=
<=> ==  != 
&&
||
.. ...    # Operadores de rango (… excluyendo el límite derecho)
?:
=   # (y operadores abreviados como +=, -=, etc.)
not
and or
\end{minted}

\subsubsection{Operadores  que no pueden ser redefinidos}

Los siguientes operadores no pueden ser redefinidos (no son métodos):

\begin{minted}{ruby}
...
!
not
&&
and
||
or
::
=
+=, -=,  # (y el resto de las asignaciones abreviadas)
? :
\end{minted}

\subsection{Arreglos}

Un arreglo en Ruby es una clase contenedora que contiene una colección de objetos. \textbf{Cualquier} tipo de objetos pueden ser almacenados en un arreglo, inclusive pudiendo contener elementos de distinto tipo en un mismo arreglo. Otra característica es que el arreglo aumenta de tamaño conforme se añaden elementos. Un arreglo es representado con sus elementos entre corchetes $[ ]$ :

\mint[linenos=false]{ruby}|[ ]		#Arreglo vacío  |

\mint[linenos=false]{ruby}|[1, 2, 3]	#Arreglo de 3 elementos |

Los arreglos pueden ser asignados:
\mint[linenos=false]{ruby}|ar1= []|

\mint[linenos=false]{ruby}|ar2= [1, 2, 3]      # => [1, 2, 3]|



Un arreglo puede añadir fácilmente un elemento mediante el operador $<<$. Ruby dinámicamente ajusta el tamaño del arreglo al añadir o remover los elementos:

\mint[linenos=false]{ruby}|ar3=  ar2 << "otro"   # => [1, 2, 3, "otro"]  |

El operador $<<$ modifica el operando izquierdo, por lo que la modificación de un arreglo puede hacerse directamente como:

\mint[linenos=false]{ruby}|ar3<<"otro mas"   # => [1, 2, 3, "otro", "otro mas"]|

De hecho, en la penúltima expresión \textit{ar3} en realidad está recibiendo la referencia de \textit{ar2} al cual se le añadió la cadena “otro”.

También es posible asignar a una posición fuera del arreglo actual. Por ejemplo: 


\mint[linenos=false]{ruby}|ma=[3,4,5]      # => [3, 4, 5] |

Y luego:

\mint[linenos=false]{ruby}|ma[3]=10        # => [3, 4, 5, 10]|

E inclusive: 

\begin{minted}{ruby}
ma[11]="Al infinito y mas alla"     # => [3, 4, 5, 10, nil, nil, nil, 
                        # nil, nil, nil, nil, "Al infinito y mas allá"]
\end{minted}


Como en C++ y Java, en Ruby el índice de un arreglo comienza con cero. 

\begin{minted}{ruby}
a = [1, 2, 3, [4, 5, 6]]   # => [1, 2, 3, [4, 5, 6]]

a[0]        			# => 1
\end{minted}

El método \textit{size} puede ser utilizado para conocer el número de elementos del arreglo:

\begin{minted}{ruby}
a.size        # => 4
a[3]          # => [4, 5, 6]
a[3].size     # => 3
a[3][0]       # => 4
\end{minted}

El tamaño del arreglo es validado:

\mint[linenos=false]{ruby}|a[5]          # => nil  |


Es posible hacer uso de valores negativos como índices, y estos se tomarán de la última posición (-1) hasta la posición negativa del tamaño del arreglo (también posición 0:
\begin{minted}{ruby}
a[-1]         	# => [4, 5, 6]
a[a.size*-1]     # => 1
\end{minted}


\subsection{Probando Ruby}
¿Porque no empezar a probar ruby siguiendo el tutorial el línea? Éste se encuentra disponible en : \url{https://ruby.github.io/TryRuby/}

\includegraphics[scale=.3]{imagenes/Ruby_online.png}

\subsection{Estructuras de control}

\subsubsection{Condicional if}

Se ejecuta si la condición es verdadera.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
if condicional [then]
  instrucciones
[elsif condicional [then]
  instrucciones]...
[else
  instrucciones]
end
    \end{minted}
El \textit{if} puede ser usado como un modificador de una declaración:

  \begin{minted} [linenos=false]{ruby}
code if condicional
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplos:

\begin{minted}{ruby}
if x < 5 then
  declaracion1
end

if x < 5 then
 declaracion1
else
 declaracion2
end

declaracion1 if y == 3

x = if a>0 then b else c end
\end{minted}

\subsubsection{Condicional \textit{unless}}
Ejecuta código si la condición es falsa, en caso contrario ejecuta otro bloque de instrucciones.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
unless condicional [then]
  instrucciones
[else
    \end{minted}
El \textit{unless} puede ser usado como un modificador de una declaración:
 \mint[linenos=false]{ruby}|instrucciones unless condicional|\\
\\ \hline
\end{tabular}
\end{center}

Ejemplos:

\begin{minted}{ruby}
unless x >= 5 then
 declaracion1
end

unless x < 5 then
 declaracion1
else
 declaracion2
end

declaracion1 unless y != 3

x = unless a<=0 then c else b end
\end{minted}

\subsubsection{\textit{Case}}

Compara la expresión especificada en \textit{case} con la expresión especificada en \textit{when} y ejecuta el código correspondiente. La clausula \textit{else} se ejecuta en el caso de que ningún segmento \textit{when} sea ejecutado.


% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
case expresión
[when expresión[, expresión...] [then]
  instrucciones]...
[else
  instrucciones]
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo\footnote{Recordar que el tipo \textit{char} no existe, aquí / / indica una expresión regular que en este caso solo contiene el patrón \textit{char}.  Finalmente, es un objeto de tipo \textit{Regexp}.}:
\begin{minted}{ruby}
case cad
  when "algun valor"
    puts "opcion 1"
  when "otro valor"
    puts "opcion 2"
  when /char/ 
    puts "opcion 3"
  else
    puts "opcion 4"
end
\end{minted}

\subsubsection{Ciclo \textit{while}}
Se ejecuta el conjunto de instrucciones mientras la condición es verdadera. La condición puede ser separada del conjunto de instrucciones mediante la palabra reservada \textit{do}, una línea nueva, el símbolo' \textbackslash ' , o un ';'.


% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
while condicional [do]
  instrucciones 
end
    \end{minted}
El \textit{while} puede ser usado como un modificador de una declaración:

\mint[linenos=false]{ruby}|instrucciones while condicional  |
o:
   \begin{minted} [linenos=false]{ruby}
begin 
  instrucciones 
end while condicional
    \end{minted}

\\ \hline
\end{tabular}
\end{center}

Ejecuta instrucciones mientras la condición es verdadera. En el caso del entre las clausulas \textit{begin} y \textit{end}, éste se ejecuta una vez \textbf{antes} de evaluar la condición.

\subsubsection{Ciclo \textit{until}} 
El ciclo \textit{until} se ejecuta el conjunto de instrucciones mientras la condición es falsa (hasta que la condición se cumpla). Puede ser separada del código por la palabra reservada \textit{do}, un salto de línea o un $';'$. De igual forma que el \textit{while}, \textit{until} puede ser usado como modificador de una declaración.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
until condicional [do]
  instrucciones 
end
    \end{minted}
o:
\mint[linenos=false]{ruby}|instrucciones until condicional  |
o:
   \begin{minted} [linenos=false]{ruby}
begin  
  instrucciones 
end until condicional
    \end{minted}

\\ \hline
\end{tabular}
\end{center}

\subsubsection{Ciclo \textit{for}}
Ejecuta el conjunto de instrucciones por cada elemento en la expresión. La expresión en el for puede ir separada por la palabra reservada do, un salto de línea, o un $';'$.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
for variable in expresion [do]
  instrucciones 
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\subsubsection{Instrucciones break, next, redo, retry}

\paragraph{\textit{break}}
Termina un ciclo \textit{while} o \textit{until}. También finaliza un método con un bloque asociado si es usado dentro del bloque, con el método regresando el valor de nulo.

\paragraph{\textit{next}}
Salta al punto en que se evalúa la condición de un ciclo. También termina la ejecución de un bloque si es llamado dentro de éste.

\paragraph{\textit{redo}}
Salta al punto inmediatamente posterior a la evaluación del ciclo.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
for i in 0..5
   if i < 2 then
      puts "El valor de la variable es #{i}"
      redo
   end
end
\end{minted}
\caption{Ejemplo \textit{redo} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\paragraph{\textit{retry}}
En una iteración se reinicia la llamada a la iteración. Los argumentos son reevaluados.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}

for i in 1..5
   retry if  i > 2
   puts "El valor de la variable es #{i}"
end
\end{minted}
\caption{Ejemplo \textit{retry} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Instrucciones \textit{BEGIN} y \textit{END}}

\paragraph{\textit{BEGIN}}
Permite declarar un conjunto de instrucciones a ejecutarse antes de que el programa se ejecute.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
BEGIN {
  instrucciones
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\paragraph{\textit{END}}
Permite declarar un conjunto de instrucciones a ejecutarse antes de finalizar la ejecución del interprete.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
END {
  instrucciones
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Algunos ejemplos:


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}

# Ciclo 1 (while)
i=0
while i < list.size do
  print "#{list[i]} "
  i += 1
end

# Ciclo 2 (until)
i=0
until i == list.size do
  print "#{list[i]} "
  i += 1
end

# Ciclo 3 (for)
for x in list do
  print "#{x} "
end

# Ciclo 4 (loop)
i=0
n=list.size-1
loop do
  print "#{list[i]} "
  i += 1
  break if i > n
end

# Ciclo 6 (loop)
i=0
n=list.size-1
loop do
  print "#{list[i]} "
  i += 1
  break unless i <= n
end
  
# Ciclo 7 (for)
n=list.size-1
for i in 0..n do
  print "#{list[i]} "
end

10.times do
  puts "hello"
end
Programa 37
\end{minted}
\caption{Ejemplos ciclos en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}

car = "Patriot"

manufacturer = case car
   when "Focus" then "Ford"
   when "Navigator" 
        "Lincoln"
   when "Camry" 
        "Toyota"
   when "Civic" 
        "Honda"
   when "Patriot" then "Jeep"
   when "Jetta" then "VW"
   when "Ceyene" then "Porsche"
   when "Outback" 
        "Subaru"
   when "520i": "BMW"
   when "Tundra": "Nissan"
   else "Desconocido"
end

puts "El " + car  + " es fabricado por "  + manufacturer
\end{minted}
\caption{Ejemplo de \textit{case} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}




%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}

calif = 70
result = case calif 
when 0..59 then "Reprobado"
when 61..70 then "Aprobado... apenas" 
when 71..80 
    "Aprobado"
when 81..100
   "Excelente"
else "Resultado inválido"
end
puts result
\end{minted}
\caption{Ejemplo 2 de \textit{case} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}

for j in 1..5 do
     for i in 1..5 do
         print i,  " "
     end
puts
end
\end{minted}
\caption{Ejemplo de \textit{for} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
for i in 1..8 do
    puts i
end

\end{minted}
\caption{Ejemplo 2 de \textit{for} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Entrada y Salida básica en Ruby}

Ruby proporciona instrucciones básicas de entrada y salida. Para Desplegar en la consola, las instrucciones básicas son \textit{puts}, \textit{print} y \textit{printf}:

\begin{itemize}
\item \textit{puts}. Despliega en la consola y añade un enter al final.
\item \textit{print}. Despliega en la consola pero no añade el enter o salto de línea al final.
\item \textit{printf}. Permite formatear la salida de variables de forma similas a C y Java 5.
\end{itemize}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
puts "puts funciona"
puts " con saltos de linea."

print "print funciona"
print " sin saltos de linea."

printf("\n\nprintf formatea números como %7.2f, y cadenas como %s.",3.14156,"esta")
\end{minted}
\caption{Ejemplo de salida en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

La manera más simple de leer una cadena en Ruby es ocupando la función \textit{gets}:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
print "Introduce tu nombre: "
nom= gets

\end{minted}
\caption{Ejemplo de entrada simple en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
\subsection{Argumentos de cantidad variable}
def varargs(arg1, *rest) 
"Got #{arg1} and #{rest.join(', ')}" 
end 
varargs("one") → "Got one and " 
varargs("one", "two") → "Got one and two" 
varargs "one", "two", "three" → "Got one and two, three" 

\fi
%%%%%%%%%%
% DRAFT
%%%%%%%%%%

\subsection{Módulos en Ruby}
Un \textbf{módulo} es definido con la sintaxis:

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
module <nombre-módulo>
  <código>
end 
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

De hecho, un módulo, aunque es similar a una clase no puede tener instancias ni subclases y añade un nuevo alcance para variables locales. Un módulo que es definido con el nombre de otro previamente definido añadirá sus definiciones al módulo inicial. En el diseño de Ruby, la clase \textit{Module} de \textit{module} es la superclase de la clase \textit{Class} de \textit{class} ! \cite{slagell2007ruby}.

Cuando existe ambigüedad, es posible referirse a un método o identificador dentro de un módulo usando el operador $::$, por ejemplo:

\mint[linenos=false]{ruby}|nombre-módulo::método |


También es posible referirse directamente a los elementos dentro de un módulo sin necesidad de usar el nombre del módulo y el operador $::$ en cada ocasión. Para esto podemos incluir (\textit{include}) el módulo. Esta característica da además lugar a los \textit{mixins} que se verán posteriormente. Es importante notar que \textit{include} hace referencia a un módulo y no a un archivo. Si el módulo esta en un diferente archivo, este debe ser solicitado mediante la instrucción \textit{require} antes de poder ser incluido \cite{thomas2005programming}.


\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%



%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython

\chapter{Introducción a Python}
\section{Introducción}
Python es un lenguaje dinámico y con características de orientado a objetos que es muy popular para desarrollo en Web, aunque cuenta también con características de programación funcional. Es similar a lenguajes como Ruby, Perl y Scheme pero también tiene influencias de lenguajes como Java y C.

Fue desarrollado en 1990 por \textit{Guido van Rossum} y es  un lenguaje que se ejecuta en las principales plataformas de hardware y sistemas operativos. Actualmente, junto con Ruby, Python es uno de los lenguajes orientados a objetos más usados para desarrollo de web dinámico \footnote{Un artículo interesante de despedida a Guido por Dropbox donde mencionan su trabajo en Python \href{https://blog.dropbox.com/topics/company/thank-you--guido.html}{en el blog de Dropbox}}.

Existen tres principales implementaciones de Pyhton:


\begin{itemize}
\item  \textit{Python / Cpython}. También llamada solamente Python, debido a que es la implementación más popular. La razón es que es la que tiene un desarrollo más completo, actualizado y de rápida ejecución\footnote{Ver: \href{https://www.python.org/}{python.org}}.
\item  \textit{Jython}. Es una implementación de Pyhton para ejecutarse en máquinas virtuales de Java (JVM), de manera similar a Scala. Puede hacer uso de la biblioteca de clases de Java. 
\item  \textit{IronPython}. Es una implementación de Python para la CLR (\textit{Common Language Runtime}) de Microsoft (.NET). Puede usar las bibliotecas de clases de .NET
\end{itemize}

\section{Herramientas}

El principal programa para usar Python lleva precisamente este nombre. \textit{python} es al mismo tiempo el intérprete y el compilador del lenguaje. El programa genera código de bytes que es almacenado en programas $.pyc$ o $.pyo$. Estos archivos son generados automáticamente cuando el archivo fuente es actualizado.

Python puede ejecutar código de 2 formas:

1. Interactivamente. Se ejecuta \textit{python} desde el \textit{prompt} de la consola:

\begin{alltt}
> python
Python 3.1.1 (r311:74543, Aug 24 2009, 18:44:04) 
[GCC 4.0.1 (Apple Inc. build 5493)] on darwin
Type "copyright", "credits" or "license()" for more information.
>>> 
\end{alltt}

2. Ejecución interpretada de archivos. \textit{python} seguido del nombre del \textit{script} a ejecutar.

\begin{alltt}
> python programa.py
\end{alltt}

Además, Python incluye un sencillo ambiente de desarrollo llamado IDLE (\textit{Integrated DeveLopment Environment}), el cual ofrece un \textit{shell} similar al intérprete de Python con ligeras funcionalidades añadidas; además de incluir un editor de texto, visores y un depurador interactivo.
Python puede ser usado desde otros IDEs, tales como Eclipse y NetBeans.


\section{Fundamentos de Python}

\subsection{Convenciones léxicas}

Un programa en Python está formado por una secuencia de líneas lógicas que pueden estar formadas por una o más líneas físicas. Una línea no lleva un delimitador como en otros lenguajes. En cambio, si la línea es muy larga, dos líneas físicas puede unirse con una diagonal ' \textbackslash ' . Aunque Python automáticamente une dos líneas físicas si un paréntesis, corchete o llave no ha sido cerrado.

La \textbf{identación} es importante para Pytthon. A diferencia de muchos lenguajes, Python no usa llaves u otros medios (como \textit{begin-end}) para delimitar bloques de instrucciones. La identación es la forma en que los bloques son delimitados en Python.

\subsection{Literales}

Python tiene tipos definidos para tipos de datos básicos. Estos son objetos que también pueden ser usados como literales.

Por ejemplo, las literales enteras pueden ser escritas  en decimal:

\begin{alltt}
>>> 123
123   
\end{alltt}

o hexadecimal:

\begin{alltt}
>>> 0x17
23  
\end{alltt}

Números flotantes se escriben con un punto y tienen el equivalente a un \textit{double} en C.


\subsection{Variables}
Una variable es un espacio para almacenar datos modificables, en la memoria de una computadora, en Python una variable se define por la sintaxis:

\mint[linenos=false]{python}| nombre_de_la_variable= valor_de_la_variable |

Cada variable tiene un nombre y un valor, el cual define a la vez el tipo de datos de la variable. Para nombrarlos es necesario un nombre descriptivo y en minúsculas. Pueden utilizarse nombres compuestos pero las palabras se separan por guiones bajos. 
%Además antes y después del signo $=$ debe haber uno y sólo un espacio en blanco. 
%Algunas formas incorrectas de escribir los nombres de las variables son:

%\begin{minted}{python}
%MiVariable = 12
%mi_variable    =   12 
%mi_variable = 12 
%mivariable =  12
%\end{minted}

Existen otros tipos de datos que no requieren ser modificados a lo largo del programa, y son llamadas constantes. Los nombres de las constantes deben estar escritos con mayúsculas, y se deben separar las palabras por guiones bajos al igual que los nombres de las variables. Para imprimir un valor de pantalla, en Python, se utiliza la palabra clave \textit{print}:

\begin{minted}{python}
mi_variable = 15
print (mi_variable)
\end{minted}

Esto imprimirá el valor de la variable $mi\_variable$ en la pantalla.

Cuando una variable tiene el valor de nulo, se usa la palabra reservada \textit{None}.

\subsection{Operadores}
\subsubsection{Operadores aritméticos}
Los operadores aritméticos que son utilizados en Python son mostrados en el Cuadro \ref{tab:op_arit_python}

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Símbolo & Significado     & Ejemplo & Resultado \\ \hline
+       & Suma            & 10+5    & 15        \\ \hline
-       & Resta           & 12-7    & 5         \\ \hline
-       & Negación        & -5      & -5        \\ \hline
*       & Multiplicación  & 7*5     & 35        \\ \hline
**      & Exponente       & 2**3    & 8         \\ \hline
/       & División        & 12.5/2  & 6.25      \\ \hline
//      & División entera & 12.5//2 & 6.0       \\ \hline
\%      & Módulo          & 27\%4   & 3         \\ \hline
\end{tabular}
\caption{Operadores aritméticos en Python}
\label{tab:op_arit_python}

\end{table}

El siguiente es un ejemplo donde se utilizan los operadores aritméticos:

\begin{minted}{python}
>>>monto_bruto = 175 
>>>tasa_interes = 12 
>>> monto_interes = monto_bruto * tasa_interes / 100 
>>> tasa_bonificacion = 5 
>>> importe_bonificacion = monto_bruto * tasa_bonificacion / 100 
>>> monto_neto = (monto_bruto - importe_bonificacion) + monto_interes 
>>> monto_neto 
187.25 
\end{minted}

\subsubsection{Operadores relacionales}
Ver Cuadro \ref{tab:op_rel_python} con el listado de los operadores relacionales.

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Símbolo         & Significado       & Ejemplo           & Resultado \\ \hline
==              & Igualdad          & 5==7              & Falso     \\ \hline
!=              & Diferencia        & 4 != 5            & Verdadero \\ \hline
\textless{}     & Menor que         & 5 \textless 7     & Verdadero \\ \hline
\textgreater{}  & Mayor que         & 4\textgreater{}8  & Falso     \\ \hline
\textless{}=    & Menor o igual que & 5\textless{}=5    & Verdadero \\ \hline
\textgreater{}= & Mayor o igual que & 4\textgreater{}=5 & Falso     \\ \hline
\end{tabular}
\caption{Operadores relacionales en Python}
\label{tab:op_rel_python}

\end{table}

Curiosamente, mientras muchos lenguajes únicamente permiten usar a los operadores relacionales para comparar pares de elementos. En Python permiten formar expresiones con elementos adicionales.

\begin{minted}{python}
>>> 5>3>10
False
>>> 5>10>1
False
>>> 5>3>2
True
>>> 5>2>3
False
>>> 5>2<3
True
\end{minted}


\subsubsection{Operadores lógicos}
Y para evaluar más de una condición simultáneamente se utilizan los operadores lógicos presentados en el Cuadro \ref{tab:op_log_python}

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Símbolo            & Ejemplo                            & Resultado \\ \hline
and                & 5==7 and 7\textless{}12            & Falso     \\ \hline
or                 & 7\textgreater{}5 or 9\textless{}12 & Verdadero \\ \hline
xor (o excluyente) & 4==4 xor 9\textgreater{}3          & Falso     \\ \hline
\end{tabular}
\caption{Operadores lógicos en Python}
\label{tab:op_log_python}

\end{table}


\subsection{Tipos de datos}

Una variable  puede contener valores de diversos tipos. Entre ellos:
\begin{minted}{python}
Cadena de texto (String)
mi_cadena = "Hola mundo"
Número entero
edad = 35
Número hexadecimal
edad = 0x23 
Número real
precio = 7435.28 
Booleano (verdadero / falso)
verdadero = True 
	falso = False 
\end{minted}

Estos son algunos tipos de datos sencillos, además en Python existen otros tipos de datos complejos que admiten una colección de datos, como las \textbf{tuplas}, las \textbf{listas} y los \textbf{diccionarios}. 


\subsubsection{Listas}
% https://www.geeksforgeeks.org/python-lists/?ref=lbp

Python no tiene el concepto de arreglos. La secuencia de elementos más usada en el lenguaje son las listas. Las listas son colecciones de elementos de tipos arbitrarios y sin un tamaño fijo\cite{lutz2013learning}.

Son similares a los arreglos en otros lenguajes, con la diferencia de que son de tamaño dinámico y pueden contener elementos de distinto tipo.

\mint[linenos=false]{python}| mi_lista = ['cadena de texto',15,2.8,'otro dato',25] |

A los datos de las listas se accede mediante el índice entre corchetes. Sus datos son mutables.

\begin{minted}{python}
mi_lista[2] = 3.5 
print (mi_lista)  # Devuelve ['cadena de texto', 15, 3.5, 'otro dato', 25]
\end{minted}

También pueden agregarse nuevos datos a la lista,

\begin{minted}{python}
mi_lista.append('Nuevo dato') 
print (mi_lista)   
	#Devuelve ['cadena de texto', 15, 3.5, 'otro dato', 25, 'Nuevo dato'] 
\end{minted}




Ejemplos:

\begin{minted}{python}
>>> lista=[123, 'xxx', 3.14]
>>> len(lista)
3
>>> lista[0]
123
>>> lista + [4, 5, 6]
[123, 'xxx', 3.14, 4, 5, 6]
>>> lista * 2
[123, 'xxx', 3.14, 123, 'xxx', 3.14]
>>> lista
[123, 'xxx', 3.14]

>>> lista=lista+[4,5,6]
>>> lista
[123, 'xxx', 3.14, 4, 5, 6]
>>> lista.append('zzz')
>>> lista
[123, 'xxx', 3.14, 4, 5, 6, 'zzz']
>>> lista.pop(2)
3.14
>>> lista
[123, 'xxx', 4, 5, 6, 'zzz']
>>> orden=['c', 'a', 'b']
>>> orden.sort()
>>> orden
['a', 'b', 'c']
>>> orden.reverse()
>>> orden
['c', 'b', 'a']
>>> lista
[123, 'xxx', 4, 5, 6, 'zzz']
>>> lista[100]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> lista[100]=1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range


>>> matriz=[[1, 2, 3],
... [4, 5, 6],
... [7, 8, 9]]
>>> matriz
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> matriz[1]
[4, 5, 6]
>>> matriz[1][2]
6
\end{minted}







\subsubsection{Tuplas}

Una tupla es una variable que permite almacenar varios datos inmutables de tipos diferentes. 

\mint[linenos=false]{python}|mi_tupla = ('Cadena de texto', 15 , 2.8 ,'otro dato', 25) |

Se puede acceder a cada uno de estos datos mediante su índice correspondiente, siendo el 0 el índice del primer elemento.

\begin{minted}{python}
print (mi_tupla[1])    #Devuelve 15 
print (mi_tupla)    # Devuelve  ('Cadena de texto', 15, 2.8, 'otro dato', 25) 
\end{minted}

\subsubsection{Conjuntos}

Podemos también crear un conjunto

\begin{minted}{python}
>>> s={1, 2, 3}
>>> print(s)
{1, 2, 3}
>>> s.add(4)
>>> s
{1, 2, 3, 4}
>>> s.add(2)
>>> s
{1, 2, 3, 4}
>>> s.discard(2)
>>> s
{1, 3, 4}
>>> s.remove(4)
>>> s
{1, 3}
>>> s.discard(4)
>>> s.remove(4)
Traceback (most recent call last):
  File "<pyshell#16>", line 1, in <module>
    s.remove(4)
KeyError: 4
\end{minted}



\subsubsection{Diccionarios}

A diferencia de las listas y las tuplas, los diccionarios permiten utilizar una clave  para declarar y acceder a un valor.

\begin{minted}{python}
mi_diccionario = {'clave_1': 12, 'clave_2': 10} 
print (mi_diccionario['clave_1'])        # Devuelve   12 
\end{minted}

Un diccionario permite eliminar cualquier elemento,

\begin{minted}{python}
del(mi_diccionario['clave_2']) 
print (mi_diccionario)      # Devuelve {'clave_1': 12} 
\end{minted}

Al igual que las listas permite modificar los elementos,

\begin{minted}{python}
mi_diccionario['clave_1'] = 24 
print (mi_diccionario)    #Devuelve    {'clave_1': 24} 
\end{minted}


\subsection{Estructuras de control}
Una estructura de control es un bloque de código que permite agrupar instrucciones de manera controlada. Las principales estructuras de control son de dos tipos:

\begin{itemize}
\item Estructuras de control condicionales.
\item Estructuras de control iterativas.
\end{itemize}
    
\subsubsection{Estructuras de control condicionales}    
Para evaluar más de una condición simultáneamente se utilizan los operadores lógicos presentados anteriormente.

Las estructuras de control condicionales, se definen mediante el uso de tres palabras reservadas \textit{if} , \textit{elif}  y \textit{else} .

Ejemplos:    

\begin{minted}{python}
      
	>>> def cruzar(semaforo): 
	...     	if semaforo == "verde": 
	...           		print ("Cruzar la calle") 
	...     	else: 
	...             	print ("No cruzar la calle") 
      
      >>>def decidir_pago (compra) 
      …	if compra <= 100: 
      ...         		print ("Pago en efectivo") 
      ... 	elif compra > 100 and compra < 300: 
      ...        		print ("Pago con tarjeta de débito") 
      ... 	else: 
      ...        		print ("Pago con tarjeta de crédito")

\end{minted}

\textbf{Estructura múltiple condicional match \/ case}

Hasta la versión 3.10, Python no tenía una característica que implementara lo que hace la instrucción \textit{switch} en otros lenguajes de programación. En su lugar, tendrías que usar la palabra clave \textit{elif} para ejecutar múltiples declaraciones condicionales.
A partir de la versión 3.10, Python ha implementado una característica de \textit{switch case} llamada \textit{emparejamiento de patrones estructurales}. Se puede implementar esta característica con las palabras clave \textit{match} y \textit{case}.
Aquí se muestra un ejemplo de cómo se ve en Python 3.10:

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

lang = input("¿Qué lenguaje de programación quieres aprender? ")
match lang:
    case "JavaScript":
        print("Puedes convertirte en un desarrollador web.")
    case "Python":
        print("Puedes convertirte en un científico de datos")
    case "PHP":
        print("Puedes convertirte en un desarrollador backend")
    case "Solidity":
        print("Puedes convertirte en un desarrollador de Blockchain")
    case "Java":
        print("Puedes convertirte en un desarrollador de aplicaciones móviles")
    case _:
        print("El lenguaje no importa, lo que importa es resolver problemas.")

\end{minted}
\caption{Ejemplo de match case en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este código, \textit{match} es la palabra clave que inicia la declaración del \textit{switch}, y case se usa para definir cada caso posible. Si ninguno de los casos coincide con el valor de \textit{lang}, se ejecutará el bloque de código después de case \_:, que es el caso predeterminado.


\subsubsection{Estructuras de control iterativas}
En Python se dispone de dos estructuras cíclicas:

\paragraph{\textit{while}}
Ejecuta una misma acción mientras una determinada condición se cumpla.
Ejemplo:
\begin{minted}{python}
      >>> def imp_anios(anio): 
      ...     while (anio <= 2012): 
      ...             print "Informes del año", str (anio) 
      ...             anio += 1 
      ... 
\end{minted}

Al probar este programa teniendo como dato de entrada $anio = 2009$, se obtiene:
\begin{minted}{python}
      >>> imp_anios(2009) 
      Informes del año 2009 
      Informes del año 2010 
      Informes del año 2011 
      Informes del año 2012 
\end{minted}

Con la última línea del programa $anio += 1$, estamos incrementando en uno 	la variable \textit{anio}. Esto hace que el ciclo en algún momento termine. Si ocurriera que el valor que se evalúa para el ciclo no es un valor numérico	que no puede incrementarse; en ese caso, podremos utilizar una estructura de control condicional, anidada dentro del ciclo, y frenar la ejecución cuando el condicional deje de cumplirse, con la palabra clave reservada \textit{break}: 

Ejemplo:

\begin{minted}{python}
>>> def edad():
	while True:
		edad = input("Edad: ")
		if int(edad)>100:
			break

>>> edad()
Edad: 4
Edad: 5
Edad: 101
>>> 
\end{minted}

Este programa continuará hasta que el usuario introduzca su nombre.

\paragraph{\textit{for}}
El ciclo \textit{for}, en Python, es aquel que nos permitirá iterar sobre una variable compleja, del tipo lista o tupla.
      
Ejemplo:
\begin{minted}{python}
>>> mi_lista = ['Juan', 'Antonio', 'Pedro', 'Herminio'] 
	>>> for nombre in mi_lista: 
	...     print nombre 
	... 
	
\end{minted}

Este programa devuelve como resultado:

\begin{minted}{python}
    Juan 	
	Antonio 
	Pedro 
	Herminio 
\end{minted}

Otra forma de iterar con el \textit{for} es la siguiente:
\begin{minted}{python}
>>> for anio in range(2001, 2009): 
	...     	print "Informes del Año", str(anio) 
	...
\end{minted}

\paragraph{\textit{Instrucciones de control de ciclos}}

Como en otros lenguajes, se tienen instrucciones para modificar el comportamiento del flujo de ejecución, ya sea para saltar o detener la ejecución de un ciclo:

\begin{itemize}
\item \textit{break}. Dada una condición, la instrucción \textit{break} detiene la ejecución y salta el flujo fuera del ciclo.
\item \textit{continue}. Dada una condición, el flujo salta al inicio del ciclo y permite la siguiente iteración, si la condición del ciclo sigue siendo verdadera.
\end{itemize}



\subsection{Entrada y Salida básica en Python}

Las funciones principales de entrada y salida de datos son:
 
\begin{itemize}
\item La función print() es interna del lenguaje Python y se utiliza para imprimir en la pantalla.  Para concatenar varios datos a imprimir en pantalla se utilizan comas, e.g. $print ("Hola ", alguien,"!")$. 
\item La función \textit{a= input (''Introduzca un valor'')} \footnote{Antes de Python 3 era llamada raw\_input} despliega un mensaje en pantalla para solicitar un dato que será almacenado en la variable a como texto. La función \textit{input}, devuelve el valor ingresado por teclado tal como se escribe.
\end{itemize}

\begin{minted}{python}
>>> variable=input("Edad:")
Edad:45
>>> variable
'45'
>>> type(variable)
<class 'str'>
>>> int(variable)
45

>>> nombre=input("Nombre:")
Nombre:carlos a
>>> nombre
'carlos a'
\end{minted}

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
s=" ¡Hola, Mundo! "
print(s)
print(s[1])
print(s[7:12])

# elimina caracteres en blanco del lado izquierdo y derecho de la cadena
print(s.strip())
print(len(s))
print(s.lower())
print(s.upper())

#sustituye "l" por "j"
print(s.replace("l", "j"))

#separa una cadena y regresa una lista de cadenas
str = "Un ejemplo de string....!"
print (str.split( ))
print (str.split('e',1))
print (str.split('e'))

print("Nombre:")
n=input()
print("Hola, "+n)


\end{minted}
\caption{Ejemplo de entrada en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Funciones}

Aunque ya hemos usado funciones en Python no se han explicado formalmente.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
def <nombre_función> ( [<parametros>] ) :
    <cuerpo de la función>
    [return <expresión>]
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Como puede verse la instrucción de retorno es opcional. En caso de no regresarse nada explícitamente, se regresa $None$.

\subsubsection{Valores por omisión en parámetros}

Un argumento por omisión es un parámetro que asume un valor si el valor no es proporcionado en la el argumento de la llamada de la función. 

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
# Ejemplo de valores por omisión

def fun(x, y=50):
	print("x: ", x)
	print("y: ", y)

fun(10)
\end{minted}
\caption{Ejemplo valores por omisión en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Al igual que en C++, los valores por omisión deben estar a la extrema derecha en la lista de argumentos.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Importante} 
\end{center} 
\\ \hline
Hay que tener en cuenta que el ligado a los valores por omisión ocurre en la definición de la función.
 
\\ \hline
\end{tabular}
\end{center}

Usualmente este comportamiento no es el deseado:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

def f(x = None):
    if x is None:
        x = []
    x.append(1)
    return x

print(f())
print(f())
print(f())
print(f(x = [9,9,9]))
print(f())
print(f())

\end{minted}
\caption{Ejemplo  en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


%%%%%%%%%%
% ADVANCED
%%%%%%%%%%
\ifadvanced

\subsubsection{Palabras clave de argumentos intercambiables}

Este concepto implica poner el nombre del argumento en la llamada con sus valores, de manera que no se tenga que recordar el orden de los parámetros.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
def estudiante(nombre, apellido):
	print(nombre, apellido)

# Argumentos clave
estudiante(nombre='Ada', apellido='Lovelace')
estudiante(apellido='Turing', nombre='Alan')

\end{minted}
\caption{Ejemplo palabras clave de argumentos en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Argumentos de cantidad variable}

En Python, podemos tener argumentos de cantidad variable usando $*$ o $**$. En el primer caso para argumentos tradicionales sin palabra clave y el segundo caso para argumentos con palabras clave (ver ejemplo anterior).

Argumentos de longitud variable sin palabras clave

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

# *argvar  como variable para los argumentos

def fun(*argvar):
  for arg in argvar:
    print(arg)
  print(type(argvar)) # argvar es una tupla

fun('Hola', 'Bienvenido', 'a', 'POO')

\end{minted}
\caption{Ejemplo Argumentos de longitud variable sin palabras clave en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

# *kwargs como variable para los argumentos con palabras clave

def fun(**kwargs):
  for clave, val in kwargs.items():
    print("%s == %s" % (clave, val))
  print(type(kwargs))  #kwargs es un diccionario

fun(uno='Prueba', dos='de', tres='argumentos')

\end{minted}
\caption{Ejemplo Argumentos de longitud variable con palabras clave en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Funciones de primera clase in Python}

Los \textbf{objetos de primera clase} en un lenguaje son manejados uniformemente. Pueden ser usados dentro de una estructura de datos, pasados como argumentos, o usados en estructuras de control. Un lenguaje como Python que soporta \textbf{funciones de primera clase} es aquel que trata a sus funciones como objetos de primera clase.  Las funciones de primera clase en Python:
\begin{itemize}
\item Una función es una instancia de la clase $function$ y $object$.
\item Una función puede asignarse a una variable.
\item Una función puede pasarse como parámetro a otra función.
\item Se puede regresar una función como valor de retorno de una función.
\item Se puede almacenar una función en estructuras de datos, por ejemplo en una lista.
\end{itemize}

\textbf{Funciones como objetos}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

#Funciones como objetos

def saludar(texto):
	return texto.upper()

print (saludar('Hola'))

gritar = saludar

print (gritar('¡Hola!'))

\end{minted}
\caption{Ejemplo funciones como objetos en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textbf{ Funciones como argumentos de otras funciones}
También conocidas como funciones de orden superior.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

def gritar(text):
	return text.upper()

def susurrar(text):
	return text.lower()

def saludar(func):
	# almacenando la función en una variable
	saludar = func("""Hola, hemos creado una función
	pasada como un argumento.""")
	print (saludar)

saludar(gritar)
saludar(susurrar)

\end{minted}
\caption{Ejemplo de función como argumento de otra función en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textbf{Función regresando a otra función }

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

def crea_sumar(x):
	def sumar(y):
		return x+y

	return sumar

suma_15 = crea_sumar(15)

print (suma_15(10))

print (suma_15(15))

\end{minted}
\caption{Ejemplo de función regresando a otra función  en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



% \subsubsection{When to use yield instead of return in Python?}
% \subsubsection{Generators in Python}
% \subsubsection{lambda}
% \subsubsection{closures}

\fi
%%%%%%%%%%
% ADVANCED_END
%%%%%%%%%%

\subsection{Módulos en Python}
En Python cada uno de los archivos $.py$ se denominan módulos. 

El contenido de cada módulo, podrá ser utilizado a la vez, por otros módulos. Para ello, es necesario importar los módulos que se quieran utilizar. Para importar un módulo, se utiliza la instrucción \textit{import}, seguida del nombre del paquete (si aplica) más el nombre del módulo (sin el $.py$) que se desee importar.  

\subsubsection{Importación de un módulo completo:}
Se puede importar un módulo completo utilizando la palabra clave \textit{import} seguida del nombre del módulo. Por ejemplo:

\mint[linenos=false]{python}| import modulo |

Esto carga todo el contenido del archivo ''modulo.p'' en el programa actual. Luego, se puede acceder a las funciones, variables y clases definidas en ese módulo utilizando la notación de punto, como modulo.funcion(), modulo.variable, o modulo.Clase.

\subsubsection{Importación de módulos con alias:}
Se puede asignar un alias al módulo importado para hacer que el código sea más legible o evitar conflictos de nombres. Para hacerlo, se utiliza la palabra clave \textit{as}. Por ejemplo:

\mint[linenos=false]{python}| import modulo as alias |

Esto permite utilizar alias en lugar de modulo para acceder a sus elementos.

\subsubsection{Importación selectiva:}
Se puede importar solo partes específicas de un módulo utilizando la declaración \textit{from}. Por ejemplo:

\mint[linenos=false]{python}| from modulo import funcion, variable |

Esto importará solo la función "funcion" y la variable variable del módulo "modulo.py". Luego, se pueden utilizar directamente sin el prefijo del módulo.

\subsubsection{Importación de todos los elementos:}
También se pueden importar todos los elementos de un módulo utilizando el asterisco *, pero esto no se recomienda en general debido a que puede hacer que el código sea menos legible y propenso a conflictos de nombres. Por ejemplo:

\mint[linenos=false]{python}| from modulo import * |

Esto importará todas las funciones, variables y clases definidas en \textit{modulo.py}.

Es importante recordar que Python buscará los módulos en los directorios especificados en la variable de entorno \textit{sys.path}. Se debe asegurar que el módulo que se intenta importar se encuentre en alguno de los directorios de esta lista o en el directorio actual del script que se esta ejecutando.


Ejemplo:
\begin{minted}{python}
import modulo   # importar un módulo que no pertenece a un paquete 
import paquete.modulo1  # importar un módulo que está dentro de un paquete 
import paquete.subpaquete.modulo1

from math import sqrt, sin, cos
\end{minted}


Además, Python tiene sus propios módulos, los cuales forman parte de su biblioteca de módulos estándar, que también pueden ser importados.

A su vez, los módulos pueden agruparse formando paquetes. 

\subsection{Paquetes en python}

Un paquete es una carpeta que contiene archivos $.py$. Pero para que una carpeta pueda ser considerada un paquete, esta debe contener una archivo de inicio $\_\_init\_\_.py$. Este archivo no necesita contener ninguna instrucción, de hecho puede estar completamente vacío. Sin embargo, considerar que este archivo es invocado cuando el paquete es importado por lo que puede contener código necesario para la inicialización del paquete. 

Además dentro de los paquetes pueden estar contenidos otros subpaquetes y los módulos no necesariamente pueden estar en un paquete.


\subsection{Probando Pyhton}

¿Por qué no empezar a probar python siguiendo el tutorial el línea? Éste se encuentra disponible en :  \url{https://try-python.appspot.com/} 

\includegraphics[scale=.4]{imagenes/TryPython.png}


\subsection{Pyhton estáticamente tipado}

A partir de Python 3.5, se introdujo la funcionalidad de tipado estático en Python a través del uso de anotaciones de tipo. Esto permite al desarrollador especificar el tipo de una variable o parámetro en su declaración, lo que ayuda a prevenir errores de tipo en tiempo de ejecución.

Las anotaciones de tipo se escriben como una expresión después de una variable o parámetro, precedida por un dos puntos (:), por ejemplo:

\begin{minted}{python}
def saludar(nombre: str) -> str:
    return "Hola, " + nombre
\end{minted}

En este caso, se esta declarando que la variable 'nombre' es de tipo $string$, y la función 'saludar' retorna un $string$.

Otro ejemplo:
\begin{minted}{python}

def f(n: int = 10) -> int:
    return n*n
print("Buen uso", f(8))
print("Mal uso", f(.9)) 
print(f())
\end{minted}

El código anterior corre sin problema a pesar de pasar un valor flotante donde se espera un entero. 

Es importante mencionar que las anotaciones de tipo son solo informativas y no se realiza ninguna comprobación en tiempo de ejecución, para comprobar el tipo de una variable o parámetro se requiere de una biblioteca externa llamada 'mypy'.




\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%



%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp


\chapter{Introducción a C\#}
\section{Introducción}
C\# (C \textit{Sharp}) fue presentado en el verano del 2000 en su versión 1.0, junto con el framework .NET por Microsoft. Aunque le versión final del compilador no fue liberada hasta enero del 2002. La idea de .NET es la de proporcionar una nueva plataforma para el desarrollo de aplicaciones para Windows, independiente del lenguaje\footnote{ Programa en cualquier lenguaje y corre en Windows es la idea. Contrario a la propuesta de Java, de compila una vez, corre donde sea. Sin embargo, ambos conceptos están convergiendo. JVM ahora ejecuta otros lenguajes como Scala y .NET tiene una versión libre (Mono).}. Sin embargo, C\# siempre ha sido considerado el lenguaje representativo de .NET.

En la práctica se dice que el lenguaje es similar a C++ y Java. Uno no puede negar, que C\# fue lanzado en el mejor momento de Java, cuando este lenguaje iba ganando muchos adeptos en la academia y las empresas.

James Gosling (el desarrollador de Java) ha llamado a C\# una imitación de Java con lo que Anders Hejlsberg (el lider del proyecto de C\#) no esta de acuerdo y dice que es más parecido a C++. C\# es un lenguaje de programación multiparadigma que es capaz de trabajar bajo los siguientes paradigmas : estructurado, imperativo, orientado a objetos, funcional, genérico, orientado a componentes, \textit{task-driven}, \textit{event-driven} reflexivo concurrente y declarativo.

El origen de su nombre es es un dato curioso pues originalmente se iba a llamar \textit{Cool} (\textit{C-like Object Oriented Language}) pero por cuestiones de derechos fue llamado C\#, el cual proviene de la nota musical “C-\textit{Sharp}” (C sostenido) que indica que la nota  escrita es un semitono más alta (o mejor). En comparación con C++ donde ++ significa que C fue incrementado o mejorado en uno, C\# se podría interpretar como C++ ++ y \# representa los 4 signos + implicando que se trata de un incremento o mejora de C++. 

Aunque tuvo un lento arranque, no se puede negar que C\# ha ido adquiriendo fuerza con el tiempo y se ha constituido en una opción real de desarrollo de software desde hace un buen tiempo.

\section{Herramientas}

Es posible usar una versión libre de C\#, el proyecto Mono, que ofrece un framework multiplataforma de .NET. Existen versiones de este framework para Linux, Mac OS X y Windows entre otros.

Puede instalarse únicamente las herramientas para la terminal e integrarlas al IDE de su preferencia (o usar la consola). También se tiene un IDE llamado \textit{MonoDevelop}. Para más información ver: 

\url{http://mono-project.com/}

Una vez instalado Mono, debe poder ejecutarse el compilador:

$\$ mcs <programa.cs>$

producirá código .NET 1.1

$\$ gmcs <programa.cs>$

generará código .NET 2.0

El compilador generará un ejecutable .exe. Ejecutar una aplicación desde mono implicaría usar la máquina de mono:

$\$ mono <programa.exe>$

En Windows también podría ejecutarse directamente, como una aplicación ejecutable, aunque dependiente del \textit{runtime} de .NET

\section{Fundamentos de C\#}

\subsection{Literales}

C\# tiene caracteres denominados secuencias de escape para facilitar la escritura con el teclado de símbolos que carecen de representación visual.

Enteros: decimal, hexadecimal, entero largo, entero largo sin signo
Coma flotante: float, double, decimal.
Caracteres: char
String: string

\subsection{Variables}

Las variables son identificadores asociados a valores. Se declaran indicando el tipo de dato que almacenará y su identificador.
Un identificador puede: 

\begin{itemize}
\item  Empezar por ” ”.
\item  Contener caracteres \textit{Unicode} en mayúsculas y minúsculas.
\end{itemize}

Un identificador no puede:

\begin{itemize}
\item  Empezar por un número.
\item  Empezar por un símbolo, ni aunque sea una palabra clave. 
\item  Contener más de 511 caracteres.
\end{itemize}

También se puede declarar una variable sin especificar el tipo de dato, mediante la palabra \textit{var}.

\subsection{Constantes}

Las constantes son valores inmutables, y por tanto no se pueden cambiar. Estas se declaran con la palabra clave \textit{const}.

Otra tipo es \textit{readonly}, no requiere de asignación al mismo tiempo que se declara.

\subsection{Operadores}

Los operadores aritméticos funcionan igual que en C y C++.
El resultado de los operadores relacionales y lógicos es un valor booleano.
Los operadores a nivel de bits no se pueden aplicar a tipos \textit{bool}, \textit{float}, \textit{double} o decimal.

\begin{itemize}
\item Aritméticos
\item Lógicos
\item A nivel de bits
\item Concatenación
\item Incremento, decremento
\item Desplazamiento
\item Relacional
\item Asignación
\item Acceso a miembro
\item Indexación
\item Conversión
\item Condicional
\item Creación de objeto
\item Información de tipo
\end{itemize}

\subsection{Estructuras de control}

Las estructuras de control \textit{if}, \textit{switch}, \textit{while}, \textit{do-while} y \textit{for} son básicamente las mismas de lenguajes estilo C/C++ y Java.

El \textit{for} permite la declaración de variables en su inicialización, a diferencia del estándar actual de C++.

Agrega un \textit{foreach} que funciona de manera similar a la variación de \textit{for} en Java pero cambiando el nombre de la instrucción al ya mencionado:

\mint[linenos=false]{csharp}| foreach (int x in intList) { … } |

\subsection{Entrada y Salida básica}

Salida básica a consola puede hacerse con los métodos de consola $WriteLine()$ y $Write()$.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System;
namespace Ejemplo
{
        class Test {
                public static void Main(string[] args) {
                        Console.WriteLine("C# es cool");
                }
        }
}
\end{minted}
\caption{Ejemplo.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

La entrada simple por consola puede hacerse con los métodos $ReadLine()$, $Read()$ y $ReadKey()$. $Readline()$ recibe la siguiente línea en un flujo de entrada estándar y regresa dicha cadena. $Read()$ recibe el siguiente carácter del flujo de entrada estándar y regresa el carácter ASCII. Finalmente, $ReadKey()$ obtiene la siguiente tecla presionada por el usuario.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System; 
namespace Ejemplo
{
        class Entrada {
                public static void Main(string[] args) {
                        int entradaUsuario;

                        Console.WriteLine("Presiona una tecla para continuar...");
                        Console.ReadKey();
                        Console.WriteLine();
                        Console.Write("Leyendo entrada con Read(): ");
                        entradaUsuario = Console.Read();
                        Console.WriteLine("Valor ASCII = {0}",entradaUsuario);
                }
        }
}
\end{minted}
\caption{Ejemplo.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


%\subsection{Módulos}

\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%


%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala


\chapter{Introducción a Scala}
\section{Introducción}
Scala es un lenguaje con características funcionales y orientadas a objetos que se ejecuta sobre la máquina virtual de Java y tiene gran interacción con éste lenguaje. 

¿Es Scala orientado a objetos o funcional? En realidad se trata de una nueva generación de lenguajes multiparadigma. Puede considerarte 100\% orientado a objetos pero incluye también un buen número de características del paradigma funcional.  \textbf{Scala es multiparadigma y multiplataforma}.

Fue creado por Martin Odersky, quien inició el proyecto en 2001 liberando la primera versión en 2003. Odersky trabajó desde 1995 con la máquina virtual de java y lideró el desarrollo de \textit{javac} de la versión 1.1 a la 1.4 \cite{pollak2009beginning}.

Odersky y Phillip Wader también trabajaron en un lenguaje llamado Pizza que trabajaba con la JVM y contenía clases genéricas entre otras características. Pizza evolucionó para proporcionar clases genéricas en Java.

Scala esta disponible en \url{www.scala-lang.org} . Iniciado como proyecto académico ha encontrado acogida en la industria. Por ejemplo, Twitter fue originalmente desarrollado en Ruby, pero después movió  partes de su código a Scala.


%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Actividad: lectura de artículo}\\ 
\hline
   \url{https://www.computerworld.com.au/article/315254/-z_programming_languages_scala} \\
\hline
\end{tabular}
\end{center}

\section{Herramientas}

Para ejecutar Scala debe tenerse instalada la JVM. Scala puede ser obtenido del sitio mencionado anteriormente.

Scala es accesible desde la consola de comandos tecleando $scala$. Deberias de ver una introducción como:

\begin{alltt}
 Welcome to Scala version 2.7.3.final (Java HotSpot(TM) 64-Bit Server VM, Java 
1.6.0_07). 
Type in expressions to have them evaluated. 
Type :help for more information. 
scala>    
\end{alltt}

Scala puede ejecutar código de tres formas:

  
\begin{enumerate}
\item  Interactivamente
\item  Ejecución interpretada de archivos
\item  En modo compilado en archivos de clases como en Java
\end{enumerate}

Scala puede ser iniciado en su modo interactivo simplemente ejecutando $scala$ desde una terminal del sistema\footnote{Asumiendo que se encuentra instalado y accesible desde cualquier directorio.}:

\begin{alltt}
$scala
Welcome to Scala version 2.7.5.final (Java HotSpot(TM) Client VM, Java 1.5.0_19).
Type in expressions to have them evaluated.
Type :help for more information.

scala> 
\end{alltt}

Como cualquier intérprete, es posible empezar ejecutar expresiones directamente:

\begin{minted}{scala}
scala> 5+10
res0: Int = 15

scala> res0 * 2
res1: Int = 30

scala> val hola= "Hola Mundo!"
hola: java.lang.String = Hola Mundo!

scala> print ("Hola Mundo!")
Hola Mundo!
\end{minted}

Recordar que Scala se basa en Java, por lo que es simple importar las bibliotecas de la API de Java:

\begin{minted}{scala}
scala> val fecha= new Date
fecha: java.util.Date = Mon Aug 31 13:43:32 CDT 2009
\end{minted}

Por otro lado, la ejecución de scripts se hace utilizando el mismo intérprete, pero indicando, en el momento de ejecución, el nombre del programa:

\mint[linenos=false]{scala}|>scala programa.scala|

Finalmente, como se mencionó, es posible compilar los programa en Scala y obtener archivos $.class$, usando el programa $scalac$:

\mint[linenos=false]{scala}|>scalac programa.scala|

Se necesita que los archivos fuente contengan una o más clases definidas.

También es posible compilar usando \textit{fsc}. \textit{fsc} (\textit{fast Scala compiler}) es un compilador que se queda como proceso corriendo, esperando por mas compilaciones, ayudando a realizar múltiples compilaciones en un menor tiempo, pero usando por lo tanto mas recursos al permanecer en ejecución.

\section{''Hola, Mundo''}
Veamos ahora el clásico "Hola, Mundo" en Scala:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
object HolaMundo {
  def main(args: Array[String])  ={
    println("Hola, Mundo!")
  }
}
\end{minted}
\caption{Ejemplo "Hola, Mundo" en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otra posibilidad es definir un objeto que extienda App\footnote{Ver: \href{http://alvinalexander.com/scala/how-to-launch-scala-application-with-object-main-method-trait}{How to launch a Scala application with an object (main, app)} }:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
object HolaMundo extends App{
    println("Hola, Mundo!")
}
\end{minted}
\caption{Ejemplo 2 de "Hola, Mundo" en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Fundamentos de Scala}

\subsection{Convenciones léxicas}
Scala utiliza la misma convección de comentarios de Java, C\#, C, etc.; es decir utiliza $//comentario$ y $/*comentario*/$. Scala utiliza la regla de \textbf{mayor coincidencia}, que se refiere al uso de de paréntesis en los números:

\mint[linenos=false]{scala}|(1).(((2).*(3))./(x))  |

ya que $1.$ es una coincidencia valida y es mayor que 1, haciendo que este sea un \textit{Double} y no un \textit{Int} y al tener $(1).+(2)$ se consideran enteros tanto 1 como 2. 

\subsection{Literales}
Existen diferentes valores literales como enteros, punto flotante, booleanos, caracteres, cadenas, símbolos, funciones, tuplas, etc. Las literales enteros pueden ser expresadas en decimal, hexadecimal u octal. Los límites de estas literales se muestran en la siguiente el Cuadro \ref{tab:literales_scala}

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
	\begin{tabular}{|l|l|l|}
		\hline
		\rowcolor[HTML]{9B9B9B} 
		Tipo  & Valor mínimo & Valor máximo \\ \hline
		Long  & $-2^{63}$           & $2^{63}-1$            \\ \hline
		Int   & $-2^{31}$           & $2^{31}-1$            \\ \hline
		Short & $-2^{15}$           & $2^{15}-1$            \\ \hline
		Char  & $0$            & $2^{16}-1$            \\ \hline
		Byte  & $-2^{7}$           & $2^{7}-1$            \\ \hline
	\end{tabular}
	\caption{Literales en Scala}
	\label{tab:literales_scala}
\end{table}


 Los valores flotantes pueden llevar la letra f o F al final del valor para indicar que son de este tipo, también pueden tener la letra d o D para indicar que son \textit{Double}, y pueden utilizar la letra e o E de exponencial para escribir un número en notación científica, por ejemplo: .14, 3.14f, 3.14F, 3.14d, 3.14D, 3.14e+5, 3.14e-5, 3.14e+5f, 3.14e-5F, etc. Los valores tipo flotantes consisten de todos los IEEE 754 de 32-bits mientras que los dobles son de IEEE 754 de 64-bits.
   
 Los literales tipo booleanos constan de \textit{true} y \textit{false}, por ejemplo:

\begin{minted}{scala}
scala> val b1 = true
b1: Boolean = true
scala> val b1 = false
b1: Boolean = false
\end{minted}

Un carácter es o bien un carácter \textit{Unicode} o una secuencia escrito entre ' '. Un carácter Unicode entre 0 y 255 también puede estar representado por un octal, es decir, por una barra invertida (\textbackslash) seguida de una secuencia de hasta tres caracteres octales, por ejemplo: 'A' y '\textbackslash u0041' ('A' en \textit{Unicode}),  o '\textbackslash n' y '\textbackslash 012' (en octal). En el siguiente cuadro (\ref{tab:se_scala}) se muestran los caracteres que reconoce Scala.

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Secuencia         & Significado          & Secuencia                        & Significado      \\ \hline
\textbackslash{}b & Retroceso            & \textbackslash{}r                & Retorno de carro \\ \hline
\textbackslash{}t & Tabulador horizontal & \textbackslash{}"                & Comillas dobles  \\ \hline
\textbackslash{}n & Salto de línea       & \textbackslash{}'                & Comillas simples \\ \hline
\textbackslash{}f & Salto de página      & \textbackslash{}\textbackslash{} & Barra invertida  \\ \hline
\end{tabular}
\caption{Secuencias de escape en Scala}
\label{tab:sec_scala}
\end{table}

El \textit{string} es una secuencia de caracteres entre doble comillas o triple. Scala permite utilizar cadenas multi-lineas sin utilizar espacios en blanco extras en la cadena de salida:

\begin{minted}{scala}
def hello(name: String) = s "Bienvenido!"  
  Hola, $nombre!
  |Nos alegra verte.
  |  Deja espacio en blanco extra.
hello("programa en Scala")
\end{minted}

Las literales funciones se pueden escribir de dos formas:

\begin{minted}{scala}
val f1: (Int,String) => = (i,s) => s+i
val f2: Function2[Int,String,String] = (i,s) => s+i
\end{minted}

son funciones que reciben un \textit{Int}  y un \textit{String} y devuelven un \textit{String}. También se pueden regresar dos o más valores en un método usando la biblioteca \textit{Tuple} para agrupar 2 elementos, la sintaxis es escribir los elementos dentro de paréntesis separados por comas, por ejemplo:

\begin{minted}{scala}
val t1: (Int,String) = (1,"Dos")
val t2: Tuple2[Int,String] = (1,"Dos")
\end{minted}

Se puede utilizar la sintaxis literal para construir la variable $t$ y poder tener acceso a cada uno de los elementos de la siguiente forma:

\begin{minted}{scala}
val t = ("Hola",1,3.4)
println("Tupla completa: " + t)
println("Primer elemento de la tupla: " + t._1)
println("Segundo elemento de la tupla: " + t._2) 
println("tercer elemento de la tupla: " + t.3)
\end{minted}

Declarar tres valores $t1, t2, t3$ y asignarlos a una tupla:

\begin{minted}{scala}
val (t1,t2,t3) = ("Hola","!",0x22)
println("Tupla: " + t1 + ", " + "t2" + ", " + t3)
\end{minted}

O se puede construir una tupla a partir de otra:

\begin{minted}{scala}
val (t4,t5,t6) = ("Hola",1,0x22)
println("Tupla: " + t4 + ", " + "t5" + ", " + t6)
\end{minted}

Otra forma de definir una tupla es con $- \textgreater{} $ , por ejemplo (1,"Uno") es lo mismo que    $1- \textgreater{} "Uno"$.

\subsection{Variables}

Scala utiliza dos tipos de variables, inmutables o mutables. Las variables inmutables solo pueden ser de lectura mientras que las variables mutables son de lectura y escritura.  Las variables inmutables son declaradas con la palabra clave \textit{val}:

\begin{minted}{scala}
scala> val array: Array[String] = new Array(5)               
   array: Array[String] = Array(null,null,null,null,null)
\end{minted}


Scala es como Java, ya que la mayoría de las variables son referenciados a objetos \textit{head-allocated}, por lo que la referencia del arreglo no se puede cambiar para apuntar a un arreglo diferente, sin embargo, los elementos del arreglo si son mutables. Si se trata de modificar el tamaño del arreglo después de ser inicializada entonces el programa marcara un error:
    
\mint[linenos=false]{scala}|array = new Array(2)|

Los elementos de una variable inmutable debe ser inicializada en el momento que se declara. Pero se pueden modificar sus valores después de ser inicializada:
    
\mint[linenos=false]{scala}|scala>array(0)=3.23|

Las variables mutables se declaran con la palabra clave \textit{var} y debe ser inicializada inmediatamente después de ser declarada:

\begin{minted}{scala}
scala> var variable: Double = 100.0
variable: Double = 100.0
\end{minted}

Puede darse la excepción de que las variables mutables o inmutables no sean declaradas en el momento, pero es cuando se utiliza como constructor de una clase.

\subsection{Operadores}

Scala utiliza los operadores condicionales de Java y se pueden observar en la siguiente tabla:

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Operador        & Operación         \\ \hline
\&\&            & and               \\ \hline
||              & or                \\ \hline
\textgreater{}  & mayor que         \\ \hline
\textless{}     & menor que         \\ \hline
\textgreater{}= & mayor o igual que \\ \hline
\textless{}=    & menor o igual que \\ \hline
==              & igualdad          \\ \hline
!=              & diferente         \\ \hline
\end{tabular}
\end{table}

La mayoría de los operadores se comportan como lo hacen en Java y otros lenguajes. Sin embargo los operadores == y != en java comparan sólo referencias a objetos y  realiza una comprobación de igualdad lógica, pero Scala aparte de realizar una comparación lógica también llama al método igual.

\subsection{Estructuras de control}

\subsubsection{Condicional \textit{if}}
La condicional es superficialmente muy similar al de Java, hace la comparación lógica y realiza el bloque correspondiente. Sin embargo, casi todas las declaraciones en Scala son expresiones que devuelven valores, por lo que se puede asignar el resultado a una expresión:


\begin{minted}{scala}
val configFile = new java.io.File("somefile.txt") 
val configFilePath = if(configFile.exists(){ configFile.getAbsolutePath()               
}else{
    configFile.createNewFile()
    configFile.getAbsolutePath()
}
\end{minted}

\subsubsection{Condicional \textit{match}}

Pattern match o coincidencia de patrones es una estructura similar al switch de Java para ser usado en lugar de una serie de estructuras condicionales if.

%https://docs.scala-lang.org/tour/pattern-matching.html
\begin{minted}{scala}

import scala.util.Random

val x: Int = Random.nextInt(10)

x match {
  case 0 => "cero"
  case 1 => "uno"
  case 2 => "dos"
  case _ => "otro"
}
\end{minted}

Recordemos que en Scala todo puede ser considerado una expresión. Si par un case se requiere más de una línea, todas las líneas se consideran un bloque sin necesidad de usar llaves para indicar el bloque.

\subsubsection{Ciclo \textit{for}}
Se puede recorrer un arreglo de tal manera:

\begin{minted}{scala}
val dogBreeds = List ("Doberman", "Dachshund", "Great Dane", "Scottish Terrier")
for (breed <- dogBreeds)
   println(breed)
\end{minted}

Es decir, para cada elemento de la lista \textit{dogBreeds} se crea una variable temporal llamada \textit{breed} con el valor del elemento y lo muestra en pantalla. Al operador $<-$ se le conoce como expresión generadora. También se puede utilizar un rango de la forma tradicional:

\mint[linenos=false]{scala}| for(i<-1 to 10)println(i) |

\subsubsection{Ciclo \textit{while} y \textit{do-while}}
El ciclo \textit{while} y \textit{do-while} son parecidos al de Java, realiza cierta tarea siempre que la condición sea verdadera, por ejemplo:

\begin{minted}{scala}
import java.util.Calendar
def isFridayThirteen(cal: Calendar):Boolean={
   val dayofWeek = cal.get(Calendar.DAY_OF_WEEK)
   val dayofMonth = cal.get(Calendar.DAY_OF_MONTH)
   (dayofWeek==Calendar.FRIDAY) && (dayofMonth == 13)
}
while(!isFridayThirteen(Calendar.getInstance())){
    println("Today isn't Friday the 13th. Lame.")
    Thread.sleep(86400000)
}
\end{minted}


%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft

\subsection{Entrada y Salida básica }
\subsubsection{Módulos ¿?}

\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%

\subsubsection{Bloques de código}

Como en Scala todo puede ser considerado una expresión. Inclusive un bloque de código regresa un resultado, dicho bloque de código entonces puede ser usado por un método o una variable


\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%


%%%%%%%%%%
% D
%%%%%%%%%%
\ifd

\chapter{Introducción a D}
\section{Introducción}

Es un nuevo lenguaje de propósito general altamente influenciado por C++. Sin embargo, D es de más alto nivel pero se dice que conserva un rendimiento similar a C++ y ofrece la productividad de lenguajes como Ruby y Python. Creado por \textbf{Walter Bright} para la compañía \textbf{Digital Mars}.

A diferencia de la nueva ola de lenguajes, D no es un lenguaje tipo \textit{script} ni incluye una máquina virtual para su ejecución. Sigue permitiendo acceso directo a las APIs del sistema operativo y al hardware.

D  se puede considerar una reingenieria de C++ e influenciado por lenguajes como Java, Eiffel. D es un lenguaje de programación multiparadigma. Incluye paradigmas: Imperativo, Orientado a objetos, Funcional y Concurrente.

%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Actividad: lectura de artículo científico}\\ 
\hline
\url{http://www.computerworld.com.au/article/253741/-z_programming_languages_d} \\
\hline
\end{tabular}
\end{center}

D es uno de los lenguajes usados por Facebook a partir de 2013, en sustitución de C++\footnote{http://forum.dlang.org/thread/l37h5s$2gd8$1@digitalmars.com}.

D, a diferencia de C++, utiliza una sintaxis y unas construcciones mucho más sencillas y lógicas. El rendimiento de C++, uno de sus puntos fuertes, también se ve reflejado en D y en algunas ocasiones incluso lo supera.

Características de D:

Gestión automática de memoria(recolección de basura): esto quiere decir que el programador seguirá creando los nuevos objetos con \textit{new} pero ya no tendrá que preocuparse de borrarlos con \textit{delete} porque existirá un \textbf{recolector de basura} que se encargará de eliminar automáticamente los objetos para los que ya no exista ninguna referencia. Sin embargo, si el programador lo desea, la recolección de basura puede ser controlada: los programadores pueden agregar y excluir rangos de memoria de ser observados por el recolector, pueden pausar y reanudar el recolector y forzar un ciclo generacional o de recolección completa.

\begin{itemize}
\item  \textbf{Gestión de errores mediante manejo de excepciones:} el sistema de manejo de excepciones es superior al de C++ al incorporar algunas características de lenguajes más recientes. Cuando una excepción producida en código D no se captura, se muestra un mensaje de error con información de la excepción.
\item \textbf{Guardias de ámbito para asegurar la ejecución de código a la salida de un ámbito:} hay recursos como los archivos, los cerrojos y \textit{mutex} que se siguen teniendo que liberar manualmente; pero hay otros. Realmente, usando las guardias de ámbito, la instrucción \textit{finally} nunca es necesaria aunque se sigue manteniendo en el lenguaje. Las guardias de inclusión no sustituyen a la instrucción \textit{except}; para capturar excepciones y realizar operaciones en la captura debemos seguir usándola.
\item \textbf{Estructuración del código en módulos y paquetes:} la estructuración del código y las bibliotecas se hace usando módulos y paquetes. Un módulo no es más que un archivo fuente de código D (generalmente con extensión .d). Al contrario de lo que sucede en otros lenguajes, cuando importamos los símbolos de un módulo no hace falta anteponer el nombre del módulo con un punto antes de llamar a un símbolo.
\item \textbf{Compatibilidad de llamada con C:} Debido a la difusión del lenguaje, la mayoría de las APIs de sistemas operativos y bibliotecas de sistemas están escritas en C u ofrecen una interfaz para el mismo. D puede acceder a bibliotecas de C. Como los tipos de datos de D suelen tener una correspondencia muy directa con los de C este proceso suele ser bastante sencillo; sin embargo para conversiones de archivos de cabecera .h más complicados se dispone de la herramienta htod que realiza la conversión de tipos y sintáxis de forma automática, tomando como entrada un archivo .h de C y generando un archivo .d que podemos incluir en nuestros proyectos.
\item \textbf{Delegados, funciones anidadas y funciones literales:} existe un tipo de dato llamado \textbf{delegado} que puede usarse para pasar referencias a un método de una clase como parámetros para otras funciones y métodos. En concepto son similares a los punteros a método de C++ pero con una sintáxis tanto de declaración como de creación y uso mucho más sencilla. D permite tener funciones anidadas y funciones anónimas. Las funciones anidadas son las que están definidas dentro de otra función y son muy útiles para estructurar nuestro código de una forma más jerárquica. Las funciones anónimas son funciones sin nombre que suelen utilizarse como argumento para una función que espera recibir una función como argumento.
\item \textbf{Declaración anticipada de funciones innecesaria:} para que una función pueda llamar a otra no es necesario que esta última haya sido declarada con anterioridad a la primera.
\end{itemize}

D retiene la habilidad de C++ de hacer código de bajo nivel, permitiendo incluir código en ensamblador.

\section{Herramientas}

Actualmente se encuentra accesible la versión  2.x, la cual fue presentada en junio de 2007. Existen diferentes implementaciones del lenguaje. La principal es desarrollada por la misma compañía (Digital Mars) en versiones Mac OSX  Windows, Linux y FreeBSD. Otras distribuciones están disponibles, por ejemplo un compilador D.NET, obviamente para .NET

Si se usa la implementación de Digital Mars, entonces el compilador es  \textit{dmd}. La extensión usada para archivos de código fuente es $.d$. Existen otras extensiones relevantes ($.dd$ para archivos de \textit{Ddoc} – similar a \textit{javadoc}-, $.di$ para archivos de interfaces, y $.def$  para archivos de definición de módulos, entre otros).

\section{Fundamentos de D}
\subsection{Convenciones léxicas}

Todos los archivos D tendrán extensión $.d$. 

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
import std.stdio;
void main(string[] args){
	   writeln("Hola, Mundo!");
}
\end{minted}
\caption{Ejemplo "Hola, Mundo!" en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Se importa la biblioteca \textit{io} que ofrece las operaciones básicas de E/S. \textit{writeln}  que se utiliza en el programa anterior para la impresión de una linea de texto. El único módulo que que utiliza este programa es \textit{std.stdio}, que maneja la entrada y salida de datos.

Los comentarios en D pueden ser multilínea: el cual inicia con /* y cierra con */, y los comentarios de una sola linea  con //

Los identificadores en D son los nombres que se les asigna para distinguir a las variables, funciones o cualquier otro elemento definido por el usuario. Un identificador  comienza con una letra A a la Z, o de la a a la z o un guión bajo (\_)seguido de cero o mas letras, subrayado y los dígitos (0 a 9).

D no permite caracteres de puntuación  tales como @, \$ y \% dentro de los identificadores. D es un lenguaje sensible a mayúsculas y minúsculas. 

\subsection{Literales}

Los tipos de valores constantes que forman parte del código fuente son llamados literales. Las literales pueden ser alguno de los tipos de datos básicos y pueden dividirse en Números Enteros, Números punto Flotante, Caracter, \textit{Strings} y Valores Booleanos.

\begin{itemize}
\item Las literales enteros pueden ser: Decimal, Octal, Binario, Hexadecimal. Una literal entera también puede tener un sufijo que es una combinación de U o L, de \textit{unsigned} y \textit{Long}. Para escribir una literal hexadecimal integral se usa el prefijo 0x o 0X seguido por una secuencia de letras 0-9, a-f, A-F, o \_.
\item Literales de Punto Flotante: pueden ser especificados sistema decimal como 1.568 o en sistema hexadecimal. En el sistema decimal, un exponente puede ser representado agregando el carácter E o e seguido del valor del exponente, por ejemplo 2.3e4, aunque también 2.3e4  y 2.3e + 4 son lo mismo (A+ carácter pueden especificarse antes del valor del exponente). Por default la literal de punto flotante es \textit{double}. F o f significa flotante.
\item Literal Booleana: Existen dos valores posibles para las literal booleana (\textit{True} y \textit{False}).
\item Literal Carácter: encerradas entre comillas simples( ‘ ’ ). Una literal de este tipo puede ser un carácter o una secuencia de escape(‘\textbackslash t’). 
\end{itemize}
    
% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Secuencia de escape              & Significado               \\ \hline
\textbackslash{}\textbackslash{} & caracter \textbackslash{} \\ \hline
\textbackslash{}'                & caracter '                \\ \hline
\textbackslash{}"                & caracter "                \\ \hline
\textbackslash{}b                & backspace                 \\ \hline
\textbackslash{}f                & Form feed                 \\ \hline
\textbackslash{}n                & Nueva línea               \\ \hline
\textbackslash{}r                & Return                    \\ \hline
\textbackslash{}t                & Tabulador horizontal      \\ \hline
\textbackslash{}v                & Tabulador vertical        \\ \hline
\end{tabular}
\end{table}

\textcolor{blue}{Ejemplo} donde se utilizan las secuencias de escape:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
import std.stdio;
int main(string[] args){
	writefln("Hello\tWorld%c\n",'\x21');
	writefln("Have a good day%c",'\x21');
	return 0;
}
\end{minted}
\caption{Ejemplo en D donde se utilizan las secuencias de escape.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\begin{itemize}
\item Literal \textit{String}: son encerradas en comillas dobles,un \textit{String} puede contener caracteres similares a las literales carácter (secuencias de escape, caracteres universales
\item Literal de Arreglo y asociación de arreglo: \textit{Strings} son un particular tipo de arreglos. Una literal de arreglo es representada como una secuencia de valores separada por una coma encerrada por corchetes cuadrados. El tamaño del arreglo es la longitud de la lista separada por comas. El arreglo es no immutable, significa que puede modificarse después de su inicialización.
\item Literal  de Funciones: en algunos lenguajes, cada función tiene un nombre que se elije en el momento de la definición, subsecuentemente la función es llamada con ese nombre. Otros lenguajes tiene la posibilidad de definir funciones anónimas(funciones lambda).  Esta característica vuelve poderoso al lenguaje al usar funciones de orden superior, estas funciones toman como parámetros y/o retornan otras funciones. D cuenta con literal de Funciones para definir funciones anónimas.
\item 
\end{itemize}

\subsection{Variables}

Una variables es sólo un nombre dado a un área de almacenamiento que nuestro programa puede manipular. Cada variable en D tiene un tipo específico, el cual determina el tamaño. Tipos básicos de variables en D: \textit{char, int, float, doble, void}.

La siguiente tabla detalla los tamaños de almacenamiento de los tipos enteros(\textit{int}):

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Tipo   & Tamaño  & Rango de valor                             \\ \hline
bool   & 1 byte  & false o true                               \\ \hline
byte   & 1 byte  & -128 a 127                                 \\ \hline
ubyte  & 1 byte  & 0 a 255                                    \\ \hline
int    & 4 bytes & -2,147,483,648 a 2,147,483,647             \\ \hline
uint   & 4 bytes & 0 a 4,294,967,295                          \\ \hline
short  & 2 bytes & -32,768 to 32,767                          \\ \hline
ushort & 2 bytes & 0 a 65,535                                 \\ \hline
long   & 8 bytes & -9223372036854775808 a 9223372036854775807 \\ \hline
ulong  & 8 bytes & 0 a 18446744073709551615                   \\ \hline
\end{tabular}
\end{table}

La siguiente tabla detalla los tamaños de almacenamiento de los tipos de punto flotante:

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Tipo    & Tamaño   & Rango de valor                                            \\ \hline
float   & 4 bytes  & 1.17549e-38 a 3.40282e+38                                 \\ \hline
double  & 8 bytes  & 2.22507e-308 a 1.79769e+308                               \\ \hline
real    & 10 bytes & 3.3621e-4932 a 1.18973e+4932                              \\ \hline
ifloat  & 4 bytes  & 1.17549e-38i a 3.40282e+38i                               \\ \hline
idouble & 8 bytes  & 2.22507e-308i a 1.79769e+308i                             \\ \hline
ireal   & 10 bytes & 3.3621e-4932 a 1.18973e+4932                              \\ \hline
cfloat  & 8 bytes  & 1.17549e-38+1.17549e-38i a 3.40282e+38+3.40282e+38i       \\ \hline
cdouble & 16 bytes & 2.22507e-308+2.22507e-308i a 1.79769e+308+1.79769e+308i   \\ \hline
creal   & 20 bytes & 3.3621e-4932+3.3621e-4932i a 1.18973e+4932+1.18973e+4932i \\ \hline
\end{tabular}
\end{table}

La siguiente tabla detalla los tamaños de almacenamiento de los tipos carácter (\textit{char}):

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Tipo  & Tamaño  \\ \hline
char  & 1 byte  \\ \hline
wchar & 2 bytes \\ \hline
dchar & 4 bytes \\ \hline
\end{tabular}
\end{table}

El tipo \textit{void} se utiliza en dos situaciones:


\begin{enumerate}
\item La función devuelve void: funciones que no devuelven nada o que devuelven nulo. Una función sin valor de retorno tiene el tipo de retorno void.
\item Argumentos de la función vacio: Una función que no acepta parámetros, vació, con ningún parámetro.
\end{enumerate}

Definición de variables en D:

\begin{minted}{d}
int i, j, k;
char c, ch;
float f, salary;
double d;
\end{minted}

Las variables también pueden ser inicializadas desde su declaración:

\begin{minted}{d}
exter int d = 3, f = 5;
int d = 3, f = 5; 
byte z = 22; 
char x = 'x';
\end{minted}

En este \textcolor{blue}{ejemplo} las variables han sido definidas en el tope del programa pero se redefinen e inicializan nuevamente dentro del main:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
import std.stdio;
	int a = 10, b =10;
	int c;
	float f;
	int main (){
		writeln("Value of a is : ", a);
		/* variable re definition: * /
		int a, b;
		int c;
		float f;
		/* Initialization * /
		a = 30;
		b = 40;
		writeln("Value of a is : ", a);
		c = a + b;
		writeln("Value of c is : ", c);
		f = 70.0/3.0;
		writeln("Value of f is : ", f);
		return 0;
	}
\end{minted}
\caption{Ejemplo de alcance en la definición de variables en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Con la siguiente salida:

\begin{alltt}
	Value of a is : 10
	Value of a is : 30
	Value of c is : 70
	Value of f is : 23.3333    
\end{alltt}

\subsection{Operadores}

Un operador es un símbolo que llama al compilador para ejecutar una operación especifica, lógica o matemática. D provee los siguientes tipos de operadores: 

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\begin{tabular}{|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
Tipo                                                                         & Operadores                                                                                                   \\ \hline
Operadores Aritméticos:                                                      & +, -, *, /, \%, ++, –                                                                                        \\ \hline
Operadores Relacionales:                                                     & ==, !=, \textgreater{}, \textless{}, \textgreater{}=, \textless{}=                                           \\ \hline
Operadores Lógicos:                                                          & \&\&, ||, !                                                                                                  \\ \hline
Operadores Bit a bit: & \&, | y \textasciicircum{}                                                                                   \\ \hline
Operadores de Asignación:                                                    & =, +=, -+, *=, /=, \%=, \textless{}\textless{}=, \textgreater{}\textgreater{}=, \&=, \textasciicircum{}=, |= \\ \hline
Operadores Misc:                                                             & sizeof, \&(direccion de una variable), * (apuntador), ? :                                                    \\ \hline
\end{tabular}
\end{table}

\subsubsection{Precedencia de operadores}

Ver Cuadro \ref{tab:my-table}

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\caption{Precedencia de operadores en D}
\label{tab:my-table}
\begin{tabular}{|l|l|}
\hline
\rowcolor[HTML]{9B9B9B} 
\multicolumn{1}{|c|}{\cellcolor[HTML]{9B9B9B}\textbf{Categoría}} & \multicolumn{1}{c|}{\cellcolor[HTML]{9B9B9B}\textbf{Operador}}                                    \\ \hline
Postfijo                                                         & {[}{]} -\textgreater . ++ - -                                                                     \\ \hline
Unario                                                           & +-!$\sim$++\_\_ type*\&sizeof                                                                     \\ \hline
Multiplicativo                                                   & * / \%                                                                                            \\ \hline
Aditivo                                                          & + -                                                                                               \\ \hline
Shift                                                            & \textless{}\textless \textgreater{}\textgreater{}                                                 \\ \hline
Relacional                                                       & \textless \textless{}= \textgreater \textgreater{}=                                               \\ \hline
Igualdad                                                         & == !=                                                                                             \\ \hline
Lógicos                                                          & AND \&\&                                                                                          \\ \hline
Lógicos                                                          & OR ||                                                                                             \\ \hline
Condicional                                                      & ?:                                                                                                \\ \hline
Asignación                                                       & = += -= *= /= \%=\textgreater{}\textgreater{}= \textless{}\textless{}= \&= \textasciicircum{}= |= \\ \hline
Coma                                                             & ,                                                                                                 \\ \hline
\end{tabular}
\end{table}

\subsection{Arreglos}   
% https://dlang.org/spec/arrays.html#dynamic-arrays

Los arreglos en D pueden ser estáticos o dinámicos.

Un arreglo estático se declara de la siguiente forma:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{d}| <tipo> [<tamaño] <variable>  |\\
\hline
\end{tabular}
\end{center}

De tal forma que un arreglo de 10 enteros quedaría de la siguiente forma:

\mint[linenos=false]{d}| int [10] arr |

Un arreglo dinámico pos su parte de declararía de manera similar pero sin indicar el tamaño específico.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{d}| <tipo> [ ] <variable>  |\\
\hline
\end{tabular}
\end{center}

Por lo que la declaración de un arreglo dinámico entero sería de la siguiente forma:

%multiple lines
\begin{minted}{d}
int [] a;
\end{minted}

Los arreglos son objetos por lo que podemos obtener el número de elementos de un arreglo del atributo $length$. 

\textcolor{blue}{Ejemplo:}

%multiple lines
\begin{minted}{d}
int[10] a = [ 1,2,3,4,5,6,7,8,9,10 ];
int[] b1, b2, b3, b4;

b1 = a;
b2 = a[];
b3 = a[0 .. a.length];
b4 = a[0 .. $];
writeln(b1);
writeln(b2);
writeln(b3);
writeln(b4);

\end{minted}


La longitud de un arreglo dinámico se puede hacer asignando un nuevo valor al atributo $length$:

%multiple lines
\begin{minted}{d}
int [] a;

a.length=10;

\end{minted}


\subsection{Estructuras de control}

\textit{if}: una sentencia consiste de una expresión booleana seguida de una o mas declaraciones.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
if (<expresión_boleana>){
     /* se ejecuta si la expresión boleana es verdadera */
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
import std.stdio;
      int main (){
             /* Definición de variable local */
          int a = 10;
 
          if( a < 20 ){
                 writefln("a es menor que 20" );
             }
             writefln("valor de a es : %d", a);
         return 0;
      }
\end{minted}
\caption{Ejemplo de estructura de control \textit{if} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textit{if...else}: una sentencia \textit{if} puede estar seguida de una sentencia \textit{else} opcional, que se ejecuta cuando la expresión booleana es falsa.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
if (<expresión_boleana>){
      
} else {
        
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
	import std.stdio;
      int main (){
             int a = 100;
      
             if( a < 20 ){
                 writefln("a es menor que 20" );
             }
             else{
                 writefln("a no es menor que 20" );
             }
             writefln("el valor de a es : %d", a);
 	   return 0;
      }
\end{minted}
\caption{Ejemplo de estructura \textit{if.. else} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textit{Switch}: Permite a una variable ser evaluada con una lista de valores.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
      switch(<expresión>){
      case <expresión-constante>  :
            <instrucciones>;
             break; /* opcional */
      case <expresión-constante>  :
            <instrucciones>;
             break; /* opcional */
        
          default : /* Opcional */
             <instrucciones>;
      }
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
      import std.stdio;
       
      int main (){
         char grade = 'B';
      
         switch(grade){
         case 'A' :
            writefln("Excelente!" );
            break;
         case 'B' :
         case 'C' :
            writefln("Bien hecho" );
            break;
         case 'D' :
            writefln("Pasaste" );
            break;
         case 'F' :
            writefln("Trata de nuevo" );
            break;
         default :
            writefln("Reprobado" );
         }
         writefln("Calificación  %c", grade );
       
         return 0;
      }
\end{minted}
\caption{Ejemplo de estructura \textit{switch} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textit{while}: repite una(s) instruccion(es) mientras la condición es verdadera. Comprueba la condición antes de el cuerpo del ciclo.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
while(<condición>) {
	<instrucciones>;
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
	import std.stdio;
	int main ()	{
		int a = 10;

		while( a < 20 ){
			writefln("Valor de a: %d", a);
			a++;
		}
		return 0;
	}

\end{minted}
\caption{Ejemplo de estructura \textit{while} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textit{for}: ejecuta una secuencia de instrucciones múltiples veces.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
for ( <ini>; <condición>; <incremento> ){
	<instrucciones>;
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

 
\begin{enumerate}
\item ini se ejecuta primero y solo una vez.
\item La condición es evaluada. Si es verdadera, el cuerpo del ciclo se ejecuta. Si es falsa el cuerpo del ciclo no se ejecuta y cede el control a la siguiente instrucción después del ciclo.
\item Después de ejecutar el ciclo, se ejecuta la instrucción incremento.
\item La condición es evaluada nuevamente.
\end{enumerate}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
	import std.stdio;
       int main (){
           for( int a = 10; a < 20; a = a + 1 ){
               writefln("Valor de a: %d", a);
           }
           return 0;
       }

\end{minted}
\caption{Ejemplo de estructura \textit{for} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textit{do while}: similar a \textit{while} con la diferencia que la condición se evalúa al final del ciclo.


% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
do {
    <instrucciones>;
} while( <condición> );

    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
import std.stdio;
int main (){
    int a = 10;
    do{
        writefln("Valor de a: %d", a);
        a = a + 1;
    }while( a < 20 );
    return 0;
}
\end{minted}
\caption{Ejemplo de estructura \textit{do while} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

D soporta los controles de instrucciones \textit{break} y \textit{continue}.
    \textit{break}: para terminar un ciclo o un instrucción de un \textit{switch} y transferir la ejecución a la instrucción inmediata después del ciclo o del \textit{switch}.

%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{d}|break;|\\
\hline
\end{tabular}
\end{center}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
    import std.stdio;
	int main (){
		int a = 10;
		while( a < 20 ){
			writefln("valor de a: %d", a);
			a++;
			if( a > 15){
				break;
			}
		}
		return 0;
	}
\end{minted}
\caption{Ejemplo de \textit{break} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textit{continue}: Forza la terminación del cuerpo de un ciclo y pasa el control, en el caso del \textit{for} evalúa la condición y realiza el incremento;  en el caso del \textit{while} y \textit{do...while }pasa el control para evaluar la condicional.

%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{d}|continue;|\\
\hline
\end{tabular}
\end{center}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
      import std.stdio;
      int main (){
          int a = 10;
          do{
              if( a == 15){
                  a = a + 1;
                  continue;
              }
          writefln("valor de a: %d", a);
          a++;
          }while( a < 20 );
          return 0;
      }
\end{minted}
\caption{Ejemplo de \textit{continue} en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


%\subsection{Entrada y salida básica en D}

\subsection{Enumeraciones}

Una enumeración es usada para valores de nombres de constantes. Un tipo de enumeración es declarada usando la palabra clave \textit{enum}.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
	enum <nombre_enum> {
		<lista de enumeración>
	}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Donde, \textit{nombre\_ enum} especifica el nombre de tipo enumeración, \textit{lista de enumeración} es la lista de identificadores separados por coma. 
Cada símbolo de la lista enumeración representa un valor entero. Por omisión, el valor del primer símbolo de la lista es 0.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
	import std.stdio;
	enum Days { sun, mon, tue, wed, thu, fri, sat };
	int main(string[] args)
	{
		Days day;
		day = Days.mon;
		writefln("Current Day: %d", day);
		writefln("Friday : %d", Days.fri);
	return 0;
	}
\end{minted}
\caption{Ejemplo de enumeración en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Propiedades:

\begin{itemize}
\item \textit{init}: inicializa el primer valor en la enumeración.
\item \textit{min}: regresa el valor más pequeño de la enumerción.
\item \textit{max}: regresa el valor más grande de la enumeración.
\item \textit{sizeof}: retorna el tamaño de la enumeración.
\end{itemize}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
import std.stdio;
// Inicializado con valor 1
enum Days { sun =1, m on, tue, wed, thu, fri, sat };
int m ain(string[] args){
	writefln("Min : %d", Days.m in);
	writefln("Max : %d", Days.m ax);
	writefln("Size of: %d", Days.sizeof);
	return 0;
}
\end{minted}
\caption{Ejemplo 2 de enumeración en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textcolor{blue}{Ejemplo} de enumeración anónima:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
	import std.stdio;
	// Initialized sun with value 1
	enum { sun , m on, tue, wed, thu, fri, sat };
	int m ain(string[] args){
		writefln("Sunday : %d", sun);
		writefln("Monday : %d", m on);
		return 0;
	}
\end{minted}
\caption{Ejemplo de enumeración anónima en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Módulos}

El nombre de un modulo es el mismo que su nombre del archivo sin la extensión .d. Cuando explícitamente se especifica, el nombre del modulo es definido por la palabra clave \textit{module} la cual debe aparecer como  la primera linea como se muestra a continuación:

\begin{minted}{d}
    module empleado;
	class Empleado {
		// La definición de la clase va aquí.
	}
\end{minted}

La línea de module es opcional, cuando no se especifica es el mismo que el nombre del archivo sin la extensión .d.

D soporta Unicode en nombres de código fuente y del módulo. Sin embargo, el soporte Unicode de los sistemas de archivos puede variar. Por ejemplo, aunque la mayoría de los sistemas de archivos de Linux soportan Unicode, los nombres de los archivos en los sistemas de archivos de Windows no pueden distinguir entre letras mayúsculas y minúsculas. Además, la mayoría de los sistemas de archivos limitan los caracteres que se pueden utilizar en los nombres de archivos y directorios. Por razones de portabilidad, es recomendable utilizar solo letras ASCII minúsculas en los nombres de archivo.

Una combinación de módulos relacionados se llama paquete. Los archivos fuente que están dentro del mismo directorio se consideran pertenecientes al mismo paquete. El nombre del directorio se convierte en el nombre del paquete, que también debe ser especificado como la primera parte de los nombre del módulo.

Por ejemplo, si $empleado.d$ y $oficina.d$ están dentro del directorio \texttt{compañia}, el paquete se define para $empleado$ y $oficina$.


\begin{minted}{d}
	module compañia.empleado;
	
	class Empleado {
	}
	
	module compañia.oficina;
	
	class Oficina {	
	}
\end{minted}

La palabra clave de \textit{import}, es para la introducción de un módulo en el módulo actual:

\mint[linenos=false]{d}|import std.stdio; |


El nombre del módulo puede contener el nombre del paquete también. Por ejemplo, el \textit{std}. indica que \textit{stdio} es un módulo del paquete \textit{std}.

\subsection{Entrada y Salida básica en D}

La  salida básica a consola en D se hace con write y writeln

\mint[linenos=false]{d}|         write("Dato ", n, ": ", foo, "\n"); |

\mint[linenos=false]{d}|write("Salida sin salto de línea"); |


La lectura por otro lado podemos hacerla con la función $readln()$ que regresa la entrada estándar a un arreglo de caracteres.

\begin{minted}{d}
char[] nom;
nom = readln();
writef("Hola ", nom);
\end{minted}

O se puede usar la lectura formateada que ofrece la función $readf()$

  %readf(" %s", &time);


Las funciones se encuentran en la biblioteca de entrada y salida $std.stdio$.


\subsection{Prueba D}

Una especie de tutorial interactivo puede encontrarse en : \url{https://tour.dlang.org/}

\includegraphics[scale=.25]{imagenes/tryD.png}


\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%

\newpage

\part{Programación Orientada a Objetos}

\chapter{Introducción a la programación orientada a objetos \cite{weitzenfeld1994paradigma, muller1997introduccion}}

\section{Programación no estructurada}

Comúnmente, las personas empiezan a aprender a programar escribiendo programas pequeños y sencillos consistentes en un solo programa principal. 

\begin{center}
    \includegraphics[]{imagenes/programacion.png}
\end{center}

Aquí "programa principal" se refiere a una secuencia de comandos o instrucciones que modifican datos que son a su vez globales en el transcurso de todo el programa. 

\section{Programación procedural}

Con la programación procedural se pueden combinar las secuencias de instrucciones repetitivas en un solo lugar. 

Una llamada de procedimiento se utiliza para invocar al procedimiento. 

Después de que la secuencia es procesada, el flujo de control procede exactamente después de la posición donde la llamada fue hecha.

\begin{center}
  \includegraphics[]{imagenes/programacionProcedural.png}
\end{center}

Al introducir parámetros, así como procedimientos de procedimientos (subprocedimientos) los programas ahora pueden ser escritos en forma más estructurada y con menos errores. 

Por ejemplo, si un procedimiento ya es correcto, cada vez que es usado produce resultados correctos. Por consecuencia, en caso de errores, se puede reducir la búsqueda a aquellos lugares que todavía no han sido revisados. 

De este modo, un programa puede ser visto como una secuencia de llamadas a procedimientos. El programa principal es responsable de pasar los datos a las llamadas individuales, los datos son procesados por los procedimientos y, una vez que el programa ha terminado, los datos resultantes son presentados. 

Así, el flujo de datos puede ser ilustrado como una gráfica jerárquica, un árbol, como se muestra en la figura para un programa sin sub-procedimientos. 

\begin{center}
    \includegraphics[]{imagenes/procedimientos.png}
\end{center}

\section{Programación modular}

En la programación modular, los procedimientos con una funcionalidad común son agrupados en módulos separados. 

Un programa por consiguiente, ya no consiste solamente de una sección. Ahora está dividido en varias secciones más pequeñas que interactúan a través de llamadas a procedimientos y que integran el programa en su totalidad.


Cada módulo puede contener sus propios datos. Esto permite que cada módulo maneje un estado interno que es modificado por las llamadas a procedimientos de ese módulo. 

Sin embargo, solamente hay un estado por módulo y cada módulo existe cuando más una vez en todo el programa.

\begin{center}
  \includegraphics[]{imagenes/modulos.png}
\end{center}

\section{Datos y Operaciones separados}

La separación de datos y operaciones conduce usualmente a una estructura basada en las operaciones en lugar de en los datos: \textbf{los Módulos agrupan las operaciones comunes en forma conjunta. }

Al programar entonces se usan estas operaciones proveyéndoles explícitamente los datos sobre los cuáles deben operar. 

La estructura de módulo resultante está por lo tanto orientada a las operaciones más que sobre los datos. Se podría decir que las operaciones definidas especifican los datos que serán usados. 

\textbf{En la programación orientada a objetos, la estructura se organiza por los datos. }Se escogen las representaciones de datos que mejor se ajusten a tus requerimientos. Por consecuencia, los programas se estructuran por los datos más que por las operaciones. 

Los datos especifican las operaciones válidas. Ahora, los módulos agrupan representaciones de datos en forma conjunta. 

\section{Programación orientada a objetos}

	La programación orientada a objetos resuelve algunos de los problemas que se acaban de mencionar. De alguna forma se podría decir que obliga a prestar atención a los datos.

En contraste con las otras técnicas, ahora tenemos una telaraña de objetos interactuantes, cada uno de los cuáles manteniendo su propio estado.

\begin{center}
  \includegraphics[]{imagenes/objetos.png}
\end{center}

Por ejemplo, en la programación orientada a objetos deberíamos tener tantos objetos de pila  como sea necesario. En lugar de llamar un procedimiento al que le debemos proveer el manejador de la pila correcto, mandaríamos un mensaje directamente al objeto pila en cuestión. 

En términos generales, cada objeto implementa su propio módulo, permitiendo por ejemplo que coexistan muchas pilas. Cada objeto es responsable de inicializarse y destruirse en forma correcta. 

\textit{¿No es ésta solamente una manera más elegante de técnica de programación modular? 
}

Podría ser, si esto fuera todo acerca de la orientación a objetos. De hecho se puede tratar de programar de esta forma sin POO. Pero eso no es todo lo que es la POO. 

\section{Tipos de Datos Abstractos}

Algunos autores describen la programación orientada a objetos como programación de tipos de datos abstractos y sus relaciones. Los tipos de datos abstractos son como un concepto básico de orientación a objetos.

\subsection{Los problemas}

	La primera cosa con la que uno se enfrenta cuando se escriben programas es el problema.

Típicamente, uno se enfrenta a problemas ''de la vida real''  y nos queremos facilitar la existencia por medio de un programa para manejar dichos problemas. 

Sin embargo, los problemas de la vida real son nebulosos y la primera cosa que se tiene que hacer es tratar de entender el problema para separar los detalles esenciales de los no esenciales: tratando de obtener tu propia perspectiva abstracta, o modelo, del problema. Este proceso de modelado se llama abstracción y se ilustra en la Figura:

\begin{center}
    \includegraphics[scale=.6]{imagenes/abstraccion.png}
\end{center}

El modelo define una perspectiva abstracta del problema. Esto implica que el modelo se enfoca solamente en aspectos relacionados con éste y que uno trata de definir propiedades del mismo. Estas propiedades incluyen 

 
\begin{itemize}
\item    los datos que son afectados 
\item    las operaciones que son identificadas
\end{itemize}

por el problema. 

Para resumir, la abstracción es la estructuración de un problema nebuloso en entidades bien definidas por medio de la definición de sus datos y operaciones. Consecuentemente, estas entidades combinan datos y operaciones. No están desacoplados unos de otras.

\subsection{Tipos de Datos Abstractos y Orientación a Objetos}

Los TDAs permiten la creación de instancias con propiedades bien definidas y comportamiento bien definido. En orientación a objetos, nos referimos a los TDAs como clases. Por lo tanto, una clase define las propiedades de objetos en un ambiente orientado a objetos. 

Los TDAs definen la funcionalidad al poner especial énfasis en los datos involucrados, su estructura, operaciones, así como en axiomas y precondiciones. Consecuentemente, la programación orientada a objetos es ''programación con TDAs'': al combinar la funcionalidad de distintos TDAs para resolver un problema. Por lo tanto, instancias (objetos) de TDAs (clases) son creadas dinámicamente, usadas y destruidas.

\section{Conceptos de básicos de objetos}

La programación tradicional separa los datos de las funciones, mientras que la programación orientada a objetos define un conjunto de objetos donde se combina de forma modular los datos con las funciones.

Aspectos principales:

\begin{enumerate}
\item Objetos.
\begin{itemize}
\item  El objeto es la \textbf{entidad básica} del modelo orientado a objetos.
\item  El objeto integra una \textbf{estructura de datos }(atributos) y un \textbf{comportamiento} (operaciones).
\item  Se distinguen entre sí por medio de su propia identidad, aunque internamente los valores de sus atributos sean iguales.
\end{itemize}
\item Clasificación.
\begin{itemize}
\item  Las clases \textbf{describen} posibles objetos, con una estructura y comportamiento común.
\item  Los objetos que contienen los mismos atributos y operaciones pertenecen a la misma clase.
\item  La estructura de clases \textbf{integra} las \textbf{operaciones} con los 
\end{itemize}
\textbf{atributos} a los cuales se aplican.
\item Instanciación 
\begin{itemize}
\item   El proceso de \textbf{crear} objetos que pertenecen a una clase se denomina instanciación. (El objeto es la instancia de una clase). 
\item  Pueden ser instanciados un número indefinido de objetos de cierta clase.
\end{itemize}
\item Generalización. 
\begin{itemize}
\item En una jerarquía de clases, se \textbf{comparten} atributos y operaciones entre clases basados en la generalización de clases.
\item La jerarquía de generalización se construye mediante la herencia.
\item Las clases más generales se conocen como superclases. (clase padre)
\item Las clases más especializadas se conocen como subclases. (clases hijas)
\item La herencia puede ser simple o múltiple.
\end{itemize}
\item Abstracción.
\begin{itemize}
    \item La abstracción se concentra en lo primordial de una entidad y no en sus propiedades secundarias.
    \item Además en lo que el objeto hace y no en cómo lo hace.
    \item Se da énfasis a cuales son los objetos y no cómo son usados.  
\end{itemize}
\item Encapsulación.
\begin{itemize}
    \item Encapsulación o encapsulamiento es la \textbf{separación} de las \textbf{propiedades externas} de un objeto de los \textbf{detalles de implementación} internos del objeto.
    \item Al separar la interfaz del objeto de su implementación, se limita la complejidad al mostrarse sólo la información relevante.
    \item Disminuye el impacto a cambios en la implementación, ya que los cambios a las propiedades internas del objeto no afectan su interacción externa.
\end{itemize}
\item Modularidad
\begin{itemize}
    \item El encapsulamiento de los objetos trae como consecuencia  una gran modularidad.
    \item Cada módulo se concentra en una sola clase de objetos.
    \item Los módulos tienden a ser pequeños y concisos.
    \item La modularidad facilita encontrar y corregir problemas.
    \item La complejidad del sistema se reduce facilitando su mantenimiento.
\end{itemize}
\item Extensibilidad.
\begin{itemize}
    \item La extensibilidad permite hacer cambios en el sistema sin afectar lo que ya existe.
    \item Nuevas clases pueden ser definidas sin tener que cambiar la interfaz del resto del sistema.
    \item La definición de los objetos existentes puede ser extendida sin necesidad de cambios más allá del propio objeto.
\end{itemize}
\item Polimorfismo (de subtipos).
\begin{itemize}
    \item El polimorfismo es la característica de definir las \textbf{mismas operaciones} con \textbf{diferente comportamiento} en diferentes clases.
    \item Se permite llamar una operación sin preocuparse de cuál implementación es requerida en que clase, siendo responsabilidad de la jerarquía de clases y no del programador.
\end{itemize}
\item Reusabilidad de código.
\begin{itemize}
    \item La orientación a objetos apoya el reuso de código en el sistema.
    \item Los componentes orientados a objetos se pueden utilizar para estructurar bibliotecas resuables.
    \item El reuso reduce el tamaño del sistema durante la creación y ejecución.
    \item Al corresponder varios objetos a una misma clase, se guardan los atributos y operaciones una sola vez por clase, y no por cada objeto.
    \item La herencia es uno de los factores más importantes contribuyendo al incremento en el reuso de código dentro de un proyecto.
\end{itemize}
\end{enumerate}

\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Actividad: lectura de artículo científico} 
\end{center} 
\\ \hline
Wegner, Peter. ''Classification in object-oriented systems.''  ACM Sigplan Notices 21.10 (1986): 173-182.
\\ \hline
\end{tabular}
\end{center}

\section{Lenguajes de programación orientada a objetos}

	\textbf{Simula I} (1967) fue originalmente diseñado para problemas de simulación y fue el primer lenguaje en el cual los datos y procedimientos estaban unificados en una sola entidad. Su sucesor \textbf{Simula} (1973) , derivó definiciones formales a los conceptos de objetos y clase.

	\textbf{Simula} sirvió de base a una generación de lenguajes de programación orientados a objetos. Es el caso de \textbf{C++} (1985), \textbf{Eiffel} (1986) y \textbf{Beta}. 
(1987)

	\textbf{Ada} (1983), se derivan de conceptos similares, e incorporan el concepto de jerarquía de herencia. \textbf{CLU} -\textit{clusters}- (1986) también incorpora herencia.

	\textbf{Smalltalk} es descendiente directo de \textbf{Simula}, generaliza el concepto de objeto como única entidad manipulada en los programas. Existen tres versiones principales: \textbf{Smalltalk-72}, introdujo el paso de mensajes para permitir la comunicación entre objetos. \textbf{Smalltalk-76} que introdujo herencia. \textbf{Smalltalk-80} se inspira en \textbf{Lisp}.

	\textbf{Lisp} contribuyó de forma importante a la evolución de la programación orientada a objetos.

	\textbf{Flavors} (1986) maneja herencia múltiple apoyada con facilidades para la combinación de métodos heredados.

	\textbf{CLOS} (1989), es el estándar del sistema de objetos de \textbf{Common Lisp}.

	Los programas de programación orientada a objetos pierden eficiencia ante los lenguajes imperativos, pues al ser interpretado estos en la arquitectura \textit{von Neumann} resulta en un \textbf{excesivo} manejo dinámico de la memoria por la constante creación de objetos, así como una fuerte carga por la división en múltiples operaciones (métodos) y su ocupación. Sin embargo se gana mucho en \textbf{comprensión} de código y \textbf{modelado} de los problemas.

\subsection{Características de los algunos LPOO\protect\footnote{Lenguajes de Programación Orientada a Objetos}}

En el Cuadro \ref{tab:principales-LPOO} podemos ver algunas características de lenguajes de programación orientados a objetos.

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\caption{Características de LPOO}
\label{tab:principales-LPOO}
\begin{tabular}{|
>{\columncolor[HTML]{9B9B9B}}l |l|l|l|l|l|}
\hline
\multicolumn{1}{|c|}{\cellcolor[HTML]{9B9B9B}\textbf{}} & \multicolumn{1}{c|}{\cellcolor[HTML]{9B9B9B}\textbf{Ada 95}} & \cellcolor[HTML]{9B9B9B}Eiffel & \cellcolor[HTML]{9B9B9B}Smalltalk & \cellcolor[HTML]{9B9B9B}C++ & \cellcolor[HTML]{9B9B9B}Java \\ \hline
\textbf{Paquetes}                                       & Sí                                                           & No                             & No                                & No                          & Sí                           \\ \hline
\textbf{Herencia}                                       & Simple                                                       & Múltiple                       & Simple                            & Múltiple                    & Simple                       \\ \hline
\textbf{Control de tipos}                               & Fuerte                                                       & Fuerte                         & Sin tipos                         & Fuerte                      & Fuerte                       \\ \hline
\textbf{Enlace}                                         & Dinámico                                                     & Dinámico                       & Dinámico                          & Dinámico                    & Dinámico                     \\ \hline
\textbf{Concurrencia}                                   & Sí                                                           & No                             & No                                & No                          & Sí                           \\ \hline
\textbf{Recolección de basura}                          & No                                                           & Sí                             & Sí                                & No                          & Sí                           \\ \hline
\textbf{Afirmaciones}                                   & No                                                           & Sí                             & No                                & No                          & Sí*                        \\ \hline
\textbf{Persistencia}                                   & No                                                           & No                             & No                                & No                          & No                           \\ \hline
\textbf{Generecidad}                                    & Sí                                                           & Sí                             & Sí                                & Sí                          & Sí*                             \\ \hline
\end{tabular}
*Afirmaciones y generecidad en Java fueron incluidos a partir de la versión 5 (1.5) del lenguaje.
\end{table}



\chapter{Abstracción de datos: Clases y objetos}

\section{Clases}

Se mencionaba anteriormente que la base de la programación orientada a objetos es la abstracción de los datos o los TDAs. La abstracción de los datos se da realmente a través de las clases y objetos.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
\textbf{Def. Clase.} Se puede decir que una clase es la implementación real de un TDA, proporcionando entonces la estructura de datos necesaria y sus operaciones. Los datos son llamados \textbf{atributos} y las operaciones se conocen como \textbf{métodos}\cite{muller1997introduccion}. 
\\ \hline
\end{tabular}
\end{center}

La unión de los atributos y los métodos dan forma al \textbf{comportamiento} (comportamiento común) de un grupo de objetos. La clase es entonces como la definición de un esquema dentro del cual encajan un conjunto de objetos.

El comportamiento debe ser descrito en términos de \textbf{responsabilidades} \cite{timothy2008introduction}. Resolviendo el problema bajo esos términos permite una mayor independencia entre los objetos, al elevar el nivel de abstracción. 

En Programación Estructurada el programa opera \textbf{sobre} estructuras de datos. En contraste en Programación Orientada a Objetos, el programa solicita a las estructuras de datos que ejecuten un servicio.

Ejemplos de clases: 

\begin{itemize}
\item automóvil, 
\item persona, 
\item libro, 
\item revista, 
\item reloj, 
\item silla, 
\item ...   
\end{itemize}


\section{Objetos e instancias}

Una de las características más importantes de los lenguajes orientados a objetos es la \textbf{instanciación}. Esta es la capacidad que tienen los nuevos tipos de datos, para nuestro caso en particular las clases de ser \textbf{instanciadas} en cualquier momento.

El instanciar una clase produce un objeto o instancia de la clase requerida. Todos los objetos son \textbf{instancia} de una clase\cite{timothy2008introduction}.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
\textbf{Def. Objeto.} Un objeto es una instancia de una clase. Puede ser identificado en forma única por su nombre y define un estado, el cuál es representado por los valores de sus atributos en un momento en particular \cite{muller1997introduccion}.
\\ \hline
\end{tabular}
\end{center}

El estado de un objeto cambia de acuerdo a los métodos que le son aplicados. Nos referimos a esta posible secuencia de cambios de estado como el comportamiento del objeto: 

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
\textbf{Def. Comportamiento.} El comportamiento de un objeto es definido por un conjunto de métodos que le pueden ser aplicados \cite{muller1997introduccion}.
\\ \hline
\end{tabular}
\end{center}

\subsection{Instanciación}

Los objetos pueden ser creados de la misma forma que una estructura de datos:

\begin{enumerate}
\item  \textbf{Estáticamente}. En \textbf{tiempo de compilación} se le asigna un área de memoria.
\item  \textbf{Dinámicamente}. Se le asigna un área de memoria en \textbf{tiempo de ejecución }y su existencia es temporal. Es necesario liberar espacio cuando el objeto ya no es útil; para esto puede ser que el lenguaje proporcione mecanismos de recolección de basura.
\end{enumerate}

En Java, los objetos sólo existen de manera dinámica, además de que incluye un recolector de basura para no dejar como responsabilidad del usuario la eliminación de los objetos de la memoria.



%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage


\section{Clases en C++}

Una clase entonces, permite encapsular la información a través de atributos y métodos que la utilizan, ocultando la misma y la implementación del comportamiento de las clases.

La definición de una clase define nuevos TDAs y la definición en C++ consiste de la palabra reservada \textit{class}, seguida del nombre de la clase y finalmente el cuerpo de la clase encerrado entre llaves y finalizando con “;”. Notar la similitud de las clases con las estructuras de C.


El cuerpo de la clase contiene la declaración de los atributos de la clase (variables) y la declaración de los métodos (funciones). Tanto los atributos como los métodos pertenecen exclusivamente a la clase y sólo pueden ser usados a través de un objeto de esa clase.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
class <nombre_clase> {
	<cuerpo de la clase>
};
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:
\begin{minted}{cpp}
class Ejemplo1 {
	int x;
 	float y;
 	void fun(int a, float b) {
		x=a;
		y=b;
 	}
};
\end{minted}

\section{Miembros de una clase en C++}


	Una clase está formada por un conjunto de miembros que pueden ser datos, funciones, clases anidadas, enumeraciones, tipos de dato, etc. (amigos)Por el momento nos vamos a centrar en los datos y las funciones (atributos y métodos).

	Es importante señalar que un miembro no puede ser declarado más de una vez\footnote{Aunque existe el concepto de sobrecarga que se verá más adelante}. Tampoco es posible añadir miembros después de la declaración de la clase.

Ejemplo:

\begin{minted}{cpp}
class Ejemplo2{
	int i;
	int i;   //error
	int j;
	int func(int, int);
};
\end{minted}

\subsection{Atributos miembro}


	Todos los atributos que forman parte de una clase deben ser declarados dentro de la misma.
	
\subsection{Métodos miembro}

	Los métodos al igual que los atributos, deber ser definidos en la clase, pero el cuerpo de la función puede ir dentro o fuera de la clase. Si un método se declara completo dentro de la clase, se considera como inline. 

	La declaración dentro de la clase no cambia con respecto a la declaración de una función, salvo que se hace dentro de la clase. Veamos un ejemplo parecido al inicial de esta sección, pero ahora con el cuerpo de un método fuera del cuerpo de la clase.
	
Ejemplo:
\begin{minted}{cpp}
//código en ejemplo3.h
class Ejemplo3 {
	public:
	int x;
 	float y;
 	int funX(int a) {
		x=a;
		return x;
	}
	float funY(float);
};
\end{minted}

Podemos ver que en la definición de la clase se incluye un método en línea y un prototipo de otro método. 

Para definir un método miembro de una clase fuera de la misma, se debe escribir antes del nombre del método, el nombre de la clase con la que el método esta asociado. Para esto se ocupa el operador de resolución de alcance (o de ámbito)  $::$.

Continuación del ejemplo:	
\begin{minted}{cpp}
float Ejemplo3::funY(float b){
	y=b;
	return y;
}
\end{minted}

	Reiteramos que al declarar los métodos fuera de la clase no puede mencionarse la declaración de un método que no esté contemplado dentro de la clase. Si esto fuera válido, cualquier método podría ganar acceso a la clase con sólo declarar una función adicional.
	
Ejemplo:


\begin{minted}{cpp}
//error en declaración de un método
class x{
	public:
	int a;
	f();
};
	
int x::g() {	//error, el metodo debe ser f()
	return a*=3.1234;
}
\end{minted}

	La declaración de una función miembro es considerada dentro del ámbito de su clase. Lo cual significa que puede usar nombres de miembros de la clase directamente sin usar el operador de acceso de miembro de la clase.

	Recordar que por convención en la programación orientada a objetos las funciones son llamadas métodos y la invocación o llamada se conoce como mensaje.
	
\subsection{Un vistazo al acceso a miembros}	

Otra de las ventajas de la POO es la posibilidad de encapsular datos, ocultándolos de otros objetos si es necesario. Para esto existen principalmente dos calificadores que definen a los datos como \textbf{públicos} o \textbf{privados}.

\subsubsection{Miembros públicos} 
Se utiliza cuando queremos dar a usuarios de una clase (e.g., otras clases) el acceso a miembros de esa clase, los miembros deben ser declarados públicos.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
public:
	<definición de miembros>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\subsubsection{Miembros privados} 
Si queremos ocultar ciertos miembros de una clase de los usuarios de la misma, debemos declarar a los miembros como privados. De esta forma nadie más que los miembros de la clase pueden usar a los miembros privados. Con excepción de las funciones amigas. Por omisión los miembros se consideran privados. En una estructura se consideran públicos por omisión.

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
private:
	<definición de miembros>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Normalmente, los atributos de la clase deben ser privados; así como los métodos que no sean necesarios externamente o que puedan conducir a un estado inconsistente del objeto\footnote{Un estado inconsistente sería ocasionado por una modificación indebida de los datos, por ejemplo una modificación sin validación.}.

	En el caso de los atributos, estos al ser privados deberían de contar con métodos de modificación y de consulta pudiendo incluir alguna validación.

	Es una buena costumbre de programación accesar a los atributos solamente a través de las funciones de modificación, sobre todo si es necesario algún tipo de verificación sobre el valor del atributo.

Ejemplo:
\begin{minted}{cpp}
//código en ejemplo3.h
class Fecha {
   	private:
	  int dia;
	  int mes;
	  int an;

	public:
	  bool setDia(int);   //poner día
	  int getDia();	//devuelve día
	  bool setMes(int);
	  int getMes();
	  bool setAn(int);
	  int getAn();
};
\end{minted}

\section{Objetos de clase en C++}

Ya se ha visto como definir una clase, declarando sus atributos y sus operaciones, mismas que pueden ir dentro de la definición de la clase (\textit{inline}) o fuera. Ahora vamos a ver como es posible crear objetos o instancias de esa clase. 

Hay que recordar que una de las características de los objetos es que cada uno guarda un estado particular de acuerdo al valor de sus atributos\footnote{A diferencia de la programación modular, donde cada módulo tiene un solo estado.}.

Lo más importante de los lenguajes orientados a objetos es precisamente el objeto, el cual es una identidad lógica que contiene datos y código que manipula esos datos. En C++, un objeto es una variable de un tipo definido por el usuario\cite{far1996programacion}.  Un \textcolor{blue}{ejemplo} completo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
#include <iostream>
using namespace std;

class Ejemplo3 {
	public:
		int i;
		int j;
};

int main() {
	Ejemplo3 e1;
	Ejemplo3 e2;
	e1.i=10;
	e1.j=20;

	e2.i=100;
	e2.j=20;
	cout<<e1.i<<endl;
	cout<<e2.i<<endl;
	
	return 0;
}
\end{minted}
\caption{Ejemplo de clases en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo}, una cola:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
class Cola{
	private:
	  int q[10];
	  int sloc, rloc;

	public:
	  void ini() {  //funci¢n en l¡nea
		sloc=rloc=-1;
	  }
	  bool set(int);
	  int get();
};

#include <iostream>
#include "Cola.h"

using namespace std;

bool Cola::set(int val){
	if(sloc>=10){
		cout<<"la cola esta llena";
		return false;
	}
	sloc++;
	q[sloc]=val;
	return true;
}
int Cola::get(){
	if(rloc==sloc)
		cout<<"la cola esta vacia";
	else {
		rloc++;
		return q[rloc];
	}
}


//cola definida en un arreglo
#include <iostream>
#include "Cola.h"

using namespace std;

int main(){
	Cola a,b, *pCola= new Cola;  // *pCola=NULL y después asignarle
	
	a.ini();
	b.ini();
	pCola->ini();
	a.set(1);
	b.set(2);
	pCola->set(3);
	a.set(11);
	b.set(22);
	pCola->set(33);
	cout<<a.get()<<endl;
	cout<<a.get()<<endl;
	cout<<b.get()<<endl;
	cout<<b.get()<<endl;
	cout<<pCola->get()<<endl;
	cout<<pCola->get()<<endl;
	
   	delete pCola;
   	return 0;
}
\end{minted}
\caption{Ejemplo 2 de clases en C++, una estructura de cola simple.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Nota} 
\end{center} 
\\ \hline
Tomar en cuenta las instrucciones siguientes para el precompilador en el manejo de múltiples archivos.
\\ \hline
\end{tabular}
\end{center}

\begin{minted}{cpp}
#ifndef CCOLA_H
#define CCOLA_H
<definición de la clase>
#endif
\end{minted}

\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%

%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage

\section{Clases en Java}

La definición en \textbf{Java}, de manera similar a C++, consiste de la palabra reservada \textit{class}, seguida del nombre de la clase y finalmente el cuerpo de la clase encerrado entre llaves. 

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
class <nombre_clase> {
	<cuerpo de la clase>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo\footnote{ Algunos ejemplos como este no son programas completos, sino simples ejemplos de clases. Podrán ser compilados pero no ejecutados directamente. Para que un programa corra debe contener o ser una clase derivada de \textit{applet}, o tener un método \textit{main}.}:

\begin{minted}{java}
public class Ejemplo1 {
	int x;
	float y;
	void fun(int a, float b) {
		x=a;
		y=b;
	}
}
\end{minted}

\section{Miembros de una clase en Java}

Los miembros en Java son esencialmente los atributos y los métodos de la clase.

Ejemplo:
\begin{minted}{java}
class Ejemplo2{
	int i;
	int i;   //error
	int j;
	int func(int, int){}
}
\end{minted}

\subsection{Atributos miembro}

Todos los atributos que forman parte de una clase deben ser declarados dentro de la misma.

La sintaxis mínima es la siguiente:

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
 \mint[linenos=false]{java}|tipo nombreAtributo; |\\

Los atributos pueden ser inicializados desde su lugar de declaración:

 \mint[linenos=false]{java}|tipo nombreAtributo = valor;|\\

o, en el caso de variables de objetos:
   \mint[linenos=false]{java}|tipo nombreAtributo = new Clase();|\\
\\ \hline
\end{tabular}
\end{center}

\subsection{Métodos miembro}

Un método es una operación que pertenece a una clase. No es posible declarar métodos fuera de la clase. Además, en Java no existe el concepto de método prototipo como en C++.

	Sin embargo, igual que en C++, la declaración de una función ó método miembro es considerada dentro del ámbito de su clase. 

	La sintaxis básica para declarar a un método:
	
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
tipoRetorno nombreMétodo ( [<parámetros>] ) {
	<instrucciones>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Un aspecto importante a considerar es que el paso de parámetros en Java es realizado exclusivamente por valor. Datos básicos y objetos son pasados por valor. Pero los objetos no son pasados realmente, se pasan las referencias a los objetos (i.e., una copia de la referencia al objeto).

\subsection{Un vistazo al acceso a miembros}

Si bien en Java existen también los miembros públicos y privados, estos tienen una sintaxis diferente a C++. En Java se define el acceso a cada miembro de manera unitaria, al contrario de la definición de acceso por grupos de miembros de C++.

\subsubsection{Miembros públicos}

%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}|public <definición de miembro>|\\
\hline
\end{tabular}
\end{center}

\subsubsection{Miembros privados}

%TABLA para notas, primera linea coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}|private <definición de miembro>|\\
\hline
\end{tabular}
\end{center}

Si se omite el nivel de acceso de un miembro, se considera como \textit{acceso de paquete}. Es decir, se tiene acceso al miembro únicamente dentro del paquete en el que la clase esta declarada\footnote{Fuente: \href{https://docs.oracle.com/javase/specs/jls/se7/html/jls-6.html\#jls-6.6.1}{Java documentation}}.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Recordatorio} 
\end{center} 
\\ \hline
 Es una buena costumbre de programación acceder a los atributos solamente a través de las funciones de modificación, sobre todo si es necesario algún tipo de verificación sobre el valor del atributo. Estos métodos de acceso y modificación comúnmente tienen el prefijo \textit{get} y \textit{set}, respectivamente.
\\ \hline
\end{tabular}
\end{center}

Ejemplo:
\begin{minted}{java}
class Fecha {
	private int dia;
	private int mes, an;
	
	public boolean setDia(int d){}   //poner día
	public int getDia()	{} //devuelve día
	public boolean setMes(int m){}
	public int getMes(){}
	public boolean setAño(int a) {}
	public int getAño() {}
}
\end{minted}


\section{Objetos de clase en Java}
En Java todos los objetos son creados dinámicamente, por lo que se necesita reservar la memoria de estos en el momento en que se van a ocupar. El operador de Java está basado también en el de C++ y es \textit{new}\footnote{La instrucción \textit{new}, ya había sido usada para reservar memoria a un arreglo, ya que estos son considerados objetos.}.

\subsection{Asignación de memoria al objeto}
El operador \textit{new} crea automáticamente un área de memoria del tamaño adecuado, y regresa la referencia del área de memoria. Esta referencia debe de recibirla un identificador de la misma clase de la que se haya reservado la memoria. 

% TABLA con más de una línea de código
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
 \mint[linenos=false]{java}|<identificador> = new Clase();|\\

o en el momento de declarar a la variable de objeto:

 \mint[linenos=false]{java}|Clase <identificador> = new Clase();|\\

\\ \hline
\end{tabular}
\end{center}

El concepto de \textit{new} va asociado de la noción de constructor, pero esta se verá más adelante, por el momento basta con adoptar esta sintaxis para poder completar ejemplos de instanciación.

Un \textcolor{blue}{ejemplo} completo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class Ejemplo3 {
	public int i, j;
	
	public static void main(String argv[]) {
		Ejemplo3 e3= new Ejemplo3();
        	Ejemplo3 e1= new Ejemplo3();

        	e1.i=10;
        	e1.j=20;
        	e3.i=100;
        	e3.j=20;
        	System.out.println(e1.i);
        	System.out.println(e3.i);
	}
 } 
\end{minted}
\caption{Ejemplo de clase en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo}, una estructura de cola:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class Cola{
	private int q[];
	private int sloc, rloc;

	public void ini() { 
		sloc=rloc=-1;
        q=new int[10];
	}

    public boolean set(int val){
		if(sloc>=10){
			System.out.println("la cola esta llena");
			return false;
		}
		sloc++;
		q[sloc]=val;
		return true;
	}

	public int get(){
        if(rloc==sloc) {
            System.out.println("la cola esta vacia");
            return -1;
        }
		else {
			rloc++;
			return q[rloc];
		}
	}
}

public class PruebaCola {
	public static void main(String argv[]){

		Cola a= new Cola(); // new crea realmente el objeto
		Cola b= new Cola(); // reservando la memoria
		Cola pCola= new Cola();  

        //Inicializacion de los objetos
		a.ini();
		b.ini();
		pCola.ini();

		a.set(1);
		b.set(2);
		pCola.set(3);
		a.set(11);
		b.set(22);
		pCola.set(33);

		System.out.println(a.get());
		System.out.println(a.get());
		System.out.println(b.get());
		System.out.println(b.get());
		System.out.println(pCola.get());
		System.out.println(pCola.get());
	}
}
\end{minted}
\caption{Ejemplo de clase con una estructura de Cola simple en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%



%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage

\section{Clases en Ruby}

La definición en \textbf{Ruby}, de manera similar a Java y C++, consiste de la palabra reservada \textit{class}, seguida del nombre de la clase y finalmente el cuerpo de la clase\cite{matsumoto2002ruby}. 
	
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
class <nombre_clase> 
	<cuerpo de la clase>
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Si la clase es contenida en un archivo la convención es que el nombre del archivo coincida con el nombre de la clase pero iniciando en minúsculas. Una clase $Prueba$ estará idealmente en un archivo $prueba.rb$ (en Windows se usa $.rbw$)

Ejemplo\footnote{ Algunos ejemplos como este no son programas completos, sino simples ejemplos de clases. Ruby es un lenguaje interpretado. No existe un método principal que inicie la ejecución. El intérprete recibe una lista de instrucciones y éste comienza ejecutando de la línea inicial hasta la última línea. }:

\begin{minted}{ruby}
class Ejemplo01
	def fun a,b
		x=a
		y=b 
	end
end
\end{minted}

\section{Miembros de una clase en Ruby}

Los miembros en Ruby son esencialmente los atributos y los métodos de la clase.

\subsection{Métodos miembro}

Un método es una operación que pertenece a una clase. Los métodos son muy importantes en Ruby. En Ruby no existen funciones, pues todo el código es representado en métodos (asociados a objetos). Aunque Ruby permite definir código similar al concepto de funciones en otros lenguajes, en realidad ese código es un método asociado (por omisión) a un objeto.

	La sintaxis básica para declarar a un método:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
def <nombreMétodo> [( <parámetros> ) ]
	<instrucciones>
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Un aspecto importante a considerar es que la lista de parámetros, al igual que el uso de variables, \textbf{no} requiere definir el tipo de dato, pues este se determina en el momento de la llamada al método.

Es posible añadir los símbolos ! o ? al final del nombre de un método. ! indica que el método requiere más atención que la variante con el mismo nombre sin el !.  Generalmente usado para indicar que se esta modificando al objeto sobre el cual es llamado el método. Son llamados también \textbf{métodos peligrosos}. Por ejemplo, es posible tener 2 métodos con el mismo nombre, pero el que termina en ! modifica al objeto y el otro (llamado \textbf{método seguro}) regresa una \textbf{copia} modificada del objeto. El símbolo ? indicaría que el método retorna un resultado booleano.

Otro aspecto interesante es que podemos regresar un valor en un método en Ruby con $return$ o simplemente regresar el valor de la última línea de un método. Por lo que la instrucción $return$ puede usarse únicamente para finalizaciones tempranas de un método.

En Ruby es posible que un método definido para una clase quede indefinido:	

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{ruby}|undef <nombreMétodo> [( <parámetros> ) ] |\\
\hline
\end{tabular}
\end{center}

Por ejemplo:

\begin{minted}{ruby}
class Foo
	def foo
	end
end

...

undef foo
\end{minted}

El uso de \textit{undef} tiene que ser también dentro de la declaración de la clase, aunque sea en un momento posterior.	

\subsection{Un vistazo al acceso a métodos}

Si bien en Ruby existen también los miembros públicos y privados, estos son usados para proveer acceso a los métodos, puesto que \textbf{los atributos son privados}. En Ruby, \textbf{los métodos son públicos por omisión }\cite{fulton2015ruby}.

\subsubsection{Métodos públicos}

Accesibles donde la clase es visible.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{ruby}|public <lista de métodos>|\\
\hline
\end{tabular}
\end{center}

\subsubsection{Métodos privados}

Accesibles solo por instancias de la clase.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{ruby}|private <lista de métodos>|\\
\hline
\end{tabular}
\end{center}

La lista de métodos públicos o privados debe hacer referencia a métodos previamente definidos. Otra posibilidad es, similar a otros lenguajes, definirse el método en  ese momento. 

\textcolor{blue}{Ejemplo:}

\begin{minted}{ruby}
class A
  private
  def metodo_privado
    # codigo
  end
end
\end{minted}

\subsection{Atributos miembro}

Todos los atributos que forman parte de una clase deben ser declarados dentro de la misma. En Ruby los atributos son llamados variables de instancia, y no requieren ser declarados fuera de los métodos. Podemos usar variables de instancia conforme se necesiten. Una variable de instancia debe llevar como prefijo el símbolo @, por ejemplo:

\mint[linenos=false]{ruby}|@variableInstanciaOAtributo|

Ejemplo:
\begin{minted}{ruby}
class InstTest
     def set_foo(n)
       @foo = n
     end
     def set_bar(n)
       @bar = n
     end
end
\end{minted}

El detalle es que en Ruby las variables de instancia no son accesibles externamente. Para poder accederlas debemos crear métodos de acceso como en el ejemplo pasado, o definir explícitamente el acceso a los atributos, lo que genera métodos con el nombre del atributo ( pero sin el @ ). Existen 3 tipos de acceso a los atributos:


\begin{enumerate}
\item \textit{attr\_accesor}. Genera acceso de lectura y escritura a la variable de instancia.
\item \textit{attr\_reader}. Genera acceso de lectura sobre la variable de instancia.
\item \textit{attr\_writer}. Proporciona acceso de escritura sobre la variable de instancia.
\end{enumerate}

Ejemplo:

\begin{minted}{ruby}
class Usuario
	attr_accessor :nombre
	attr_accessor :apellidos
	attr_reader :login
	attr_writer :password
...
def muestra
	@nombre+”  ”+@apellidos
end
end

\end{minted}

\section{Objetos de clase en Ruby}

En Ruby todos los números, arreglos, cadenas y demás entidades son objetos, lo que permite aplicar métodos definidos para esos objetos directamente a las literales:

\begin{minted}{ruby}
10.succ                 # 11
"hola".upcase           # "HOLA"
[2,1,5,3,4].sort       # [1,2,3,4,5]
objeto.metodo
\end{minted}

Esto implicaría que cada objeto en Ruby es un objeto de alguna clase. De hecho es posible preguntarle a un objeto a que clase pertenece:

\mint[linenos=false]{ruby}|"hola".class |

O mejor aún, los métodos que la clase tiene:

\mint[linenos=false]{ruby}|"hola".methods |

Aunque esto puede hacerse directamente con el nombre de la clase\footnote{Para saber la razón por la que es posible usar el nombre de una clase, ver el tema de miembros de clase.}. Sin embargo el resultado puede variar, por ejemplo si le preguntamos a una clase a que clase pertenece! :

\begin{minted}{ruby}
String.class

String.methods
\end{minted}

\subsection{Asignación de memoria al objeto}

En Ruby, un objeto es instanciado mediante la ejecución del \textbf{método} \textit{new}, el  crea automáticamente un área de memoria del tamaño adecuado, y regresa la referencia del área de memoria. El objeto instanciado típicamente es asignado a una variable. 

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{ruby}|identificador = Clase.new   |\\
\hline
\end{tabular}
\end{center}

Un \textcolor{blue}{ejemplo} completo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
class Ejemplo3
	@i  # no es necesario
	@j	# especificar los atributos
	def unMetodo x,y
		@i=x
		@j=y
		puts "El valor de i es " + @i.to_s 
		puts "El valor de j es " + @j.to_s
	end
end

require "Ejemplo3"
# ó load "Ejemplo3.rb"

obj1 = Ejemplo3.new
obj2 = Ejemplo3.new

obj1.unMetodo 10,20
obj2.unMetodo 100, 20
\end{minted}
\caption{Ejemplo inicial de clases y objetos en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo}, una estructura de cola:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
class Cola
	@q=[]
	@sloc= @rloc=-1
	
	def ini 
		@sloc= @rloc=-1
		@q=[]
	end
	
	def set val
		if @sloc>1000
			puts "La cola esta llena"
			return false
		end
		@sloc+=1
		@q[@sloc]=val
		return true
	end
	
	def get
		if @rloc == @sloc then
			puts "La cola esta vacia"
			return false
		else
			@rloc+=1
			return @q[@rloc]
		end
	end 
end
require "Cola"

a = Cola.new
b = Cola.new

a.ini
b.ini

a.set 1
b.set 2
a.set 11
b.set(22)

puts a.get
puts a.get
puts b.get
puts b.get()

a.get
\end{minted}
\caption{Ejemplo 2 de clase en Ruby, una estructura simple de Cola.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%



%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage

\section{Clases en Python}

Una clase en \textbf{Python} consiste de la palabra reservada \textit{class}, seguida del nombre de la clase y finalmente el cuerpo de la clase. Recordar que la identación es usada en Python para definir bloques de código. 

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
class <nombre_clase> :
		<cuerpo de la clase>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo\footnote{ Algunos ejemplos como este no son programas completos, sino simples ejemplos de clases. Python es un lenguaje interpretado. No existe un método principal que inicie la ejecución. El intérprete recibe una lista de instrucciones y éste comienza ejecutando de la línea inicial hasta la última línea.  }:	

\begin{minted}{python}
class Ejemplo01:
	def fun(a,b):
		x=a
		y=b 
\end{minted}

\section{Miembros de una clase en Python}

\subsection{Métodos miembro}

	Un método es una operación que pertenece a una clase. La sintaxis básica para declarar a un método:
	
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
def nombreMétodo( <parámetros> ) :
	<instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Un aspecto importante a considerar es que la lista de parámetros, al igual que el uso de variables, \textbf{no} requiere definir el tipo de dato, pues éste se determina en el momento de la llamada al método.	

\subsection{Atributos miembro}
Los atributos o variables de instancia en Python deben ser declarados dentro de un método de la clase mediante:

\mint[linenos=false]{python}|self.nombre= valor|

Los atributos podrán ser accedidos usando la misma notación (\textit{self.nombre})

Ejemplo:
\begin{minted}{python}
class InstTest:
    def set_foo(self, n):
       self.foo = n
    def set_bar(self, n):
       self.bar = n
\end{minted}

Es importante señalar que los métodos deben recibir al objeto en el primer parámetro. Esto se hace nombrando al primer parámetro como \textit{self}. 

\subsection{Acceso a miembros en Python}

Estrictamente hablando, no existen miembros realmente privados en Python, todos los miembros son considerados públicos. Sin embargo, en la práctica tenemos dos formas de declarar miembros privados.

Una opción entonces es declarar a los \textbf{elementos privados por convención}, declarando el nombre del miembro precedido por un guión bajo\_. Entonces una variable \textit{privada} deberá ser nombrada, por ejemplo, como $\_foo$. Esto es una señal a los programadores de que se considera al miembro privado y no debería accederse fuera de la clase. 

La otra opción es definir un \textit{miembro privado} con un nombre precedido por doble guión bajo \_ . Entonces un miembro deberá de ser nombrado, por ejemplo $\_\_foo$. Si el nombre de un atributo o método - de instancia o de clase- inicia con dos guiones bajos - y no termina con dos guiones bajos-, el miembro se considera privado. El resto de los miembros son considerados públicos \cite{pilgrim2009dive}.

Tener  en cuenta que este es un mecanismo débil ya que aún se puede acceder a estos miembros \textit{privados} a través de un truco conocido como \textit{name mangling} a través del nombre de la clase ($obj.\_\_nombreClase\_\_atributo$). No se recomienda ya que va en contra del diseño orientado a objetos y puede llevar a un código más difícil de mantener y errores inesperados.

Ejemplo:
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Test:
    def __init__(self):
        self.__test=10
        self.test=5
    def getTest(self):
        return self.__test

#main script  
t= Test()
print(t.test)
print(t.getTest())
print(t._Test__test) # accediendo al atributo con el nombre de la clase

print(t.__test)  #genera error

\end{minted}
\caption{Ejemplo de miembros privados en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Ahora bien, Python, de manera similar a Ruby,  se adhiere al Principio de Acceso Uniforme establecido por Bertrand Meyer \cite{meyer1997object}: \textit{''Todos los servicios ofrecidos por un módulo deben estar disponibles a través de una notación uniforme, que no traicione si se implementan mediante almacenamiento o mediante computación''}.  En una forma más simple, establece que no debería haber ninguna diferencia sintáctica entre trabajar con un atributo, una propiedad calculada previamente o un método/consulta de un objeto.

Entonces de acuerdo a este principio, deberíamos acceder a los atributos directamente: $foo.x=0$, en lugar de por medio de un método $foo.set_x(0)$. Acceder directamente al atributo nos permitiría hacer expresiones más cortas:
\begin{minted}{python}
foo.x += 1
\end{minted}

En lugar de:
\begin{minted}{python}
foo.set_x(foo.get_x() + 1)
\end{minted}

Sin embargo esto va en contra del principio del mínimo privilegio. 



%%%%%%%%%%
% ADVANCED
%%%%%%%%%%
\ifadvanced


\subsection{Acceso administrado a atributos en Python}

Python tiene un protocolo de propiedades que nos permite dirigir acciones sobre atributos para operaciones tipo \textit{get}, \textit{set}, borrado y documentación básica.

Una propiedad es creada al asignarle el resultado de una función incorporada para un atributo de clase:

\begin{minted}{python}
attribute = property(fget, fset, fdel, doc)
\end{minted}

La siguiente clase usa una propiedad para trazar el acceso al atributo nombre. El dato es almacenado en $\_nombre$.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Persona:
  def __init__(self, nombre):
    self._nombre = nombre 

  def getNombre(self):
    print('obteniendo...')
    return self._nombre
  
  def setNombre(self, val): 
    print('cambiando...')
    self._nombre = val
  
  def delNombre(self):
    print('removiendo...')
    del self._nombre
  nombre = property(getNombre, setNombre, delNombre, "propiedad nombre ")

per1 = Persona('Bob Esponja') 
print(per1.nombre)
per1.nombre = 'Roberto Esponja' 
print(per1.nombre)
del per1.nombre    # Ejecuta delnombre

print('-'*20)   
per2 = Persona('Susana F') 
print(per2.nombre) 
print(Persona.nombre.__doc__)  # O help(Persona.nombre)

\end{minted}
\caption{Definiendo las propiedades de acceso de un tributo en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Cuando el código es ejecutado, dos instancias reciben la propiedad del atributo, como sería con cualquier otro atributo definido en la clase.

\subsubsection{Atributos calculados/validados}

La ventaja de atributos administrados es que combinan la simplicidad de dar la impresión de acceder directamente al atributo al mismo tiempo que pueden hacer un cálculo o una validación.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class PropCuadrado:
  def __init__(self, v): 
    self.val = v 
  def getX(self):           # Obtiene el atributo
    return self.val ** 2 
  def setX(self, val):    # asigna en el atributo
    self.val = val 
  X = property(getX, setX)   # Sin propiedades del o docs

P= PropCuadrado(3)      # Dos instancias de la clase con property 
Q= PropCuadrado(32)     # Cada una tiene un estado distinto

print(P.X)          # 3 ** 2
P.X = 4 
print(P.X)          # 4 ** 2
print(Q.X)          # 32 ** 2 (1024)

\end{minted}
\caption{Uso clásico de métodos get y set en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Definiendo propiedades de atributos con \textit{Decorators}}

Podemos también definir los métodos de acceso (\textit{getter} y \textit{setter}) y de borrado usando decoraciones (\textit{decorators})

Ejemplo:
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Foo:
    def __init__(self):
        self.__foo = 0

    @property
    def foo(self):  
        return self.__foo

    @foo.setter
    def foo(self, value):
        self.__foo = value

f= Foo()
f.foo= "asignando a través del método setter"
print("Desplegando mediante el getter", f.foo)
\end{minted}
\caption{Ejemplo de decorators en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Veamos ahora el ejemplo inicial ahora con métodos decorados.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Persona:
  def __init__(self, nombre):
    self._nombre = nombre 

  @property
  def nombre(self):
    "propiedad nombre"
    print('obteniendo...')
    return self._nombre

  @nombre.setter
  def nombre(self, val): 
    print('cambiando...')
    self._nombre = val
  
  @nombre.deleter
  def nombre(self):
    print('removiendo...')
    del self._nombre

per1 = Persona('Bob Esponja') 
print(per1.nombre)
per1.nombre = 'Roberto Esponja' 
print(per1.nombre)
del per1.nombre    # Runs delnombre

print('-'*20)   # sue inherits property too
per2 = Persona('Susana F') 
print(per2.nombre) 
print(Persona.nombre.__doc__)  # Or help(Persona.nombre)

\end{minted}
\caption{Ejemplo de clase Persona con decorators en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\subsubsection{Definiendo propiedades de atributos con Descriptores}

Otra opción para el manejo de atributos es el uso de descriptores (\textit{descriptors}). En realidad es otra forma de describir las propiedades de los atributos pero ahora en una clase separada. Los descriptores son creados entonces como clases independientes, y asignados a atributos de clase. Como una propiedad, una clase descriptora maneja un único atributo, pero al tener su propio alcance (siendo clases) pueden manejar las propiedades para atributos más complejos de una mejor manera.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
class Descriptor:
  "inserta aqui cadena de descripción"
  def __get__(self, instance, owner): ... # regresa valor del atributo
  def __set__(self, instance, value): ... # regresa nada None) 
  def __delete__(self, instance): ...  # regresa nada (None)
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Nombre:
    "propiedad nombre"
    def __get__(self, instancia, dueño):
      print('obteniendo...')
      return instancia._nombre
    def __set__(self, instancia, val):
      print('cambiando...')
      instancia._nombre = val
    def __delete__(self, instancia):
      print('borrando...') 
      del instancia._nombre

class Persona:
    def __init__(self, nombre):
      self._nombre = nombre 
    nombre = Nombre()

per1 = Persona('Bob Esponja') 
print(per1.nombre)
per1.nombre = 'Roberto Esponja' 
print(per1.nombre)
del per1.nombre    

print('-'*20)   
per2 = Persona('Susana F') 
print(per2.nombre) 
print(Nombre.__doc__)  


\end{minted}
\caption{Ejemplo de clase Persona con descriptores en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Inclusive se puede poner como clase anidada:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Persona:
    def __init__(self, nombre):
        self._nombre = nombre
    class Nombre:
        "propiedad nombre"
        def __get__(self, instancia, dueño):
            print('obteniendo...')
            return instancia._nombre
        def __set__(self, instancia, val):
            print('cambiando...')
            instancia._nombre = val
        def __delete__(self, instancia):
            print('borrando...')
            del instancia._nombre
  
    nombre = Nombre()

#script de prueba
per1 = Persona('Bob Esponja')
print(per1.nombre)
per1.nombre = 'Roberto Esponja'
print(per1.nombre)
del per1.nombre
print('-'*20)
per2 = Persona('Susana F')
print(per2.nombre)
print(Persona.Nombre.__doc__) 

\end{minted}
\caption{Ejemplo de clase Persona con descriptores en clase anidada en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Manejo genérico de atributos}

También es posible manejar el acceso a los atributos redefiniendo los métodos especiales de acceso getattr, setattr y delattr.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Persona:
  def __init__(self, nombre):
    self._nombre = nombre       #lanza __setattr__

  def __getattr__(self, attr): 
    print('get: ' + attr)
    if attr == 'nombre':        #intercepta nombre
      return self._nombre       # no se cicla al ser el atributo real
    else:                       #otros son errores
      raise AttributeError(attr)
  
  def __setattr__(self, attr, val): 
    print('set: ' + attr)
    if attr == 'nombre':
      attr = '_nombre'          #asigna nombre interno
    self.__dict__[attr] = val   #evita ciclado recursivo de __setattr__

  def __delattr__(self, attr): 
    print('del: ' + attr)
    if attr == 'nombre':
      attr = '_nombre'          #evita ciclado recursivo 
    del self.__dict__[attr]     #aunque mucho menos común

per1 = Persona('Bob Esponja')   
print(per1.nombre)              #Corre __getattr__
per1.nombre = 'Roberto Esponja' #Corre __setattr__
print(per1.nombre)
del per1.nombre                 #Corre __delattr__

print('-'*20)   
per2 = Persona('Susana F') 
print(per2.nombre) 

\end{minted}
\caption{Ejemplo de clase Persona con manejo genérico de atributos en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% ADVANCED_END
%%%%%%%%%%

\section{Objetos de clase en Python}

En Python todos los números, arreglos, cadenas y demás entidades son objetos. Cada objeto tiene un valor, un identificador y un tipo. El identificador del objeto y el tipo pueden ser accedidos mediante las operaciones $id()$ y $type()$ respectivamente:

\begin{minted}{python}
>>> n=10
>>> id(n)
3492368
>>> type(n)
<class 'int'>
>>> arr=[2,3,4]
>>> id(arr)
19201080
>>> type(arr)
<class 'list'>
\end{minted}

\subsection{Asignación de memoria al objeto}

En Python, un objeto es instanciado mediante la ejecución objeto de la clase que se quiere instanciar, éste crea automáticamente un área de memoria del tamaño adecuado, y regresa la referencia del área de memoria. El objeto instanciado típicamente es asignado a una variable. 

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{python}|identificador = Clase()|\\
\hline
\end{tabular}
\end{center}

Un \textcolor{blue}{ejemplo} completo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Ejemplo3:
    def unMetodo(self, x, y):
        self.i=x
        self.j=y
        print("El valor de i es " + str(self.i)) 
        print("El valor de j es " + str(self.j))
# script de ejecucion
obj1= Ejemplo3()
obj2= Ejemplo3()
obj1.unMetodo(10, 20)
obj2.unMetodo(100, 200)
\end{minted}
\caption{Ejemplo de clases en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo}, una estructura de cola:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Cola:
    def ini(self):
        self.sloc= self.rloc=-1
        self.q=[]

    def setC(self, val):
        if self.sloc>1000:
            print("La cola esta llena")
            return False
        self.sloc+=1
        self.q.append(val)
        return True

    def getC(self):
        if self.rloc == self.sloc:
            print("La cola esta vacia")
            return False
        else:
            self.rloc+=1
            return self.q[self.rloc]

# script de ejecucion
a = Cola()
b = Cola()

a.ini()
b.ini()

a.setC(1)
b.setC(2)
a.setC(11)
b.setC(22)

print(a.getC())
print(a.getC())
print(b.getC())
print(b.getC())

a.getC()
\end{minted}
\caption{Ejemplo.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%




%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala
\newpage

\section{Clases en Scala}

Una clase en \textbf{Scala} consiste de la palabra reservada \textit{class}, seguida del nombre de la clase y finalmente el cuerpo de la clase.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{scala}
class <nombre_clase> {
	<cuerpo de la clase>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{scala}
class Ejemplo01 {
  def fun(a:int,b:int) {
    var x: int =a
    val y: int =b
    ...
  }
}
\end{minted}

\section{Miembros de una clase en Scala}

\subsection{Métodos miembro}

	Un método es una operación que pertenece a una clase. La sintaxis básica para declarar a un método:
	
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{scala}
def nombreMétodo [( <parámetros> ) ][: tipo retorno] =
	<instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

La lista de parámetros es opcional. Un método sin parámetros no requiere los paréntesis en su uso (definición y/o llamada):

\mint[linenos=false]{scala}|def foo = ''foo''|

\subsubsection{Atributos miembro}

Los atributos Scala deben ser declarados dentro la clase mediante:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{scala}|var nombre: tipo [= valor]|\\
\hline
\end{tabular}
\end{center}

Los atributos podrán ser accedidos usando la misma notación. 

Es posible también definir atributos que no van a cambiar (su referencia, aunque el objeto referenciado pueda cambiar -similar a elementos final en Java-):

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{scala}|val nombre: tipo [= valor]|\\
\hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{scala}
class InstTest {
  var foo: Int
  var bar: Int
}
\end{minted}

Scala puede inferir el tipo de dato cuando estos son inicializados:

\mint[linenos=false]{scala}|var s= "cadena"  |

\subsection{Un vistazo al acceso a miembros}

La declaración de visibilidad o acceso a miembros es similar a la de Java y C\#. Sin embargo, los miembros son considerados \textbf{públicos por omisión }y no existe un modificador para este tipo de acceso.

\subsubsection{Miembros públicos}
Visibles donde la clase sea visible. No se tiene una palabra reservada para especificar al miembro como público.

\subsubsection{Miembros privados}
Solamente son accesible dentro de la clase (o tipo) que lo define, y sus tipos anidados. Accesibles únicamente dentro del mismo paquete.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{scala}|private <definición de miembro> |\\
\hline
\end{tabular}
\end{center}

Existen otras opciones de accesibilidad que serán comentadas más adelante. Ejemplo:

\begin{minted}{scala}
class Fecha {
	private var dia: int
	private var mes, an: int
	
	def setDia(d: Int): Boolean = {} 
 	def getDia(): Int =	{} 
	def setMes(m: Int): Boolean = {}
	def getMes(): Int = {}
	def setAn(a: Int): Boolean = {}
	def getAn(): Int = {}
}
\end{minted}

\section{Objetos de clase en Scala}

Scala es un lenguaje puro orientado a objetos. Todos los números, arreglos, cadenas y demás entidades son objetos. A diferencia de Java, inclusive los números y las funciones son considerados objetos. 

\subsection{Números como objetos}

\begin{minted}{scala}
scala> 1
res1: Int = 1

scala> 1  
res2: Int = 1

scala> 1+2
res3: Int = 3

scala> (1).+(2)
res4: Int = 3
\end{minted}

\subsection{Funciones como objetos}

Puesto que Scala considera a las funciones como objetos, es posible pasar las funciones como argumentos en los parámetros, almacenarlos en variables y regresarlos como resultado de otras funciones. El hecho de que las funciones sean consideradas \textit{first-class citizens } es lo que hace que Scala puede ser considerado también un lenguaje con capacidades de \textbf{programación funcional}!

\subsection{Asignación de memoria al objeto}

En Scala, un objeto es instanciado igual que en Java, usando la instrucción \textit{new} seguida del nombre de la clase. El objeto instanciado típicamente es asignado a una variable. La variable puede o no haber sido definida con anterioridad. La excepción sería n los objetos que corresponden a valores primitivos en Java, para los cuales no es necesario usar específicamente el constructor. De hecho, tratar de usar un constructor para estos tipos generará un error de compilación.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{scala}|identificador = new Clase()|\\
\hline
\end{tabular}
\end{center}

Un \textcolor{blue}{ejemplo} completo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Ejemplo3 {
  private var i: Int =0
  private var j: Int =0
  def unMetodo(x: Int, y: Int) = {
        i=x
        j=y
        println("El valor de i es " + i) 
        println("El valor de j es " + j)
  }
}

object HolaMundo {
  def main(args: Array[String])  ={
    var obj1 : Ejemplo3 = new Ejemplo3
    var obj2 = new Ejemplo3
    
    obj1.unMetodo(10, 20)
    obj2.unMetodo(100, 200)
  }
}
\end{minted}
\caption{Ejemplo de clase en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo}, una estructura de cola:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Cola {
  private var sloc, rloc = 0
  private var q = new Array[Int] (0)//0 elementos
  
  def ini() = {
    sloc  = -1
    rloc = -1
    q= new Array[Int] (10) //10 elementos
  }

def setC(valor: Int):Boolean = {
    if (sloc>1000){
    	println("La cola esta llena")
        return false
    }
    sloc+=1
    q(sloc)=valor
    return true
  }
 
  def get :Int ={
    if (rloc == sloc){
      println("La cola esta vacia")
      return -1
    } else {
      rloc += 1
      return q(rloc)
    }
  }
}

object ColaTest {
  def main(args : Array[String])  = {
    val a,b: Cola = new Cola
      
    a.ini()
    b.ini()

    a.setC(1)
    b.setC(2)
    a.setC(11)
    b.setC(22)

    println(a.get)
    println(a.get)	
    println(b.get)
    println(b.get)

    a.get
  }
} 
\end{minted}
\caption{Ejemplo de clases en Scala, una estructura de Cola simple.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%



%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp
\newpage

\section{Clases en C\#}

La definición en \textbf{C\#}, de manera similar a C++ y Java, consiste de la palabra reservada \textit{class}, seguida del nombre de la clase y finalmente el cuerpo de la clase encerrado entre llaves. 

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{csharp}
class <nombre_clase> {
	<cuerpo de la clase>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{csharp}
	public class Ejemplo01	{
		int x;
		float y;
		void fun(int a, float b){
			x=a;
			y=b;
		}
	}
\end{minted}

\section{Miembros de una clase en C\#}

Los miembros en C\# son esencialmente los atributos y los métodos de la clase.

\subsection{Atributos miembro}

Todos los atributos que forman parte de una clase deben ser declarados dentro de la misma.

La sintaxis mínima es la siguiente:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{csharp}|tipo nombreAtributo;   |\\
 
 Los atributos pueden ser inicializados desde su lugar de declaración:
 
\mint[linenos=false]{csharp}|tipo nombreAtributo = valor;  |\\

o, en el caso de variables de objetos:

\mint[linenos=false]{csharp}|tipo nombreAtributo = new Clase(); |\\

\hline
\end{tabular}
\end{center}

\subsection{Métodos miembro}

	Un método es una operación que pertenece a una clase. \textbf{No} es posible declarar métodos fuera de la clase. Además, no existe el concepto de método prototipo como en C++.

	Sin embargo, igual que en C++, la declaración de una función ó método miembro es considerada dentro del ámbito de su clase. 

	La sintaxis básica para declarar a un método:
	
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{csharp}
tipoRetorno nombreMétodo ( [<parámetros>] ) {
	<instrucciones>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}	

\subsection{Tipos de parámetros}

Existen 4 tipos de paso de parámetros en C\#. Pasó de parámetros por valor, por referencia, parámetros de salida y arreglos de parámetros.

\begin{itemize}
\item \textbf{Pasó de parámetros por valor}. Este es el tipo de parámetros por omisión. Se manda una copia del valor, sea un tipo de dato simple (o una enumeración o estructura), o una copia de la referencia al objeto.
\item \textbf{Por referencia}. Parámetros por referencia usan la palabra clave \textit{ref}, y no usan los valores de las variables, sino las variables mismas. Ejemplo:

\begin{minted}{csharp}
void foo(ref MiClase c) {
	c=null;
}
\end{minted}

La modificación de c permanece después de la llamada al método \textit{foo}.

\item \textbf{Parámetros de salid}a. Parámetros de salida usan la palabra clave \textit{out}, y no usan los valores de las variables, sino las variables mismas. Es similar al parámetro por referencia pero se considera como un parámetro sin asignación en la llamada al método, y el método debe asignarle un valor antes de terminar su ejecución.
\item \textbf{Arreglos de parámetros}. Permiten pasar un número variable de parámetros en una llamada a un método. Utiliza el modificador \textit{params} en la definición del método. El número de parámetros puede ser de cero a n, respetando el tipo de dato del parámetro. Ejemplo:
\begin{minted}{csharp}
void muestra (params int[] num){
    foreach (int x in num)
    {
        Console.Write (x+" ");
    }
    Console.WriteLine();
}
\end{minted}

Llamando al método:

\begin{minted}{csharp}
muestra(1, 2, 3, 4, 5);
int[] arr = {99, 88, 77};
muestra(arr);
\end{minted}

\end{itemize}

\subsection{Un vistazo al acceso a miembros}

En C\#, como en Java, se define el acceso a cada miembro de manera unitaria, al contrario de la definición de acceso por grupos de miembros de C++. Miembros en clases son considerados privados por omisión\footnote{Accessibility Levels (C\# Reference) \href{ https://msdn.microsoft.com/en-us/library/ba0a1yw2.aspx}{(C\# Reference)}}.

\subsubsection{Miembros públicos}

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{csharp}|public <definición de miembro>  |\\
\hline
\end{tabular}
\end{center}

\subsubsection{Miembros privados}

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{csharp}|private <definición de miembro>  |\\
\hline
\end{tabular}
\end{center}

\subsubsection{Miembros internos}
Miembros definidos de esta manera son accesibles por métodos de cualquier clase que se encuentre en el mismo \textit{assembly}\footnote{Un \textit{assembly} es una colección de archivos compilados reunidos como un archivo ejecutable o un $DLL$.}. 

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{csharp}|internal <definición de miembro>  |\\
\hline
\end{tabular}
\end{center}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Recordatorio} 
\end{center} 
\\ \hline
Es una buena costumbre de programación acceder a los atributos solamente a través de las funciones de modificación, sobre todo si es necesario algún tipo de verificación sobre el valor del atributo. Estos métodos de acceso y modificación comúnmente tienen el prefijo \textit{get} y \textit{set}, respectivamente.   
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{csharp}
public class Fecha{
		private int dia;
		private int mes, an;
	
		public bool setDia(int d){}   //poner día
		public int getDia()	{} //devuelve día
		public bool setMes(int m){}
		public int getMes(){}
		public bool setAn(int a) {}
		public int getAn() {}
	}
\end{minted}

\section{Objetos de clase en C\#}

Como en Java, en C\# todos los objetos son creados dinámicamente, por lo que se necesita reservar la memoria de estos en el momento en que se van a ocupar. El operador es también \textit{new}.

\subsection{Asignación de memoria al objeto}

	El operador \textit{new} crea automáticamente un área de memoria del tamaño adecuado, y regresa la referencia del área de memoria. Esta referencia debe de recibirla un identificador de la misma clase de la que se haya reservado la memoria. 
	
%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{csharp}| <identificador> = new Clase();  |\\
 o en el momento de declarar a la variable de objeto:
  \mint[linenos=false]{csharp}| Clase <identificador> = new Clase();  |\\
\hline
\end{tabular}
\end{center}	
	
El concepto de \textit{new} va asociado de la noción de constructor, pero esta se verá más adelante, por el momento basta con adoptar esta sintaxis para poder completar ejemplos de instanciación.	

Un \textcolor{blue}{ejemplo} completo:	

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System;

namespace Application
{
	public class Ejemplo3 {
		public int i, j;
	
		static void Main() {
			Ejemplo3 e3= new Ejemplo3();
        		Ejemplo3 e1= new Ejemplo3();

        		e1.i=10;
        		e1.j=20;
        		e3.i=100;
        		e3.j=20;
        	
			Console.WriteLine(e1.i);
        		Console.WriteLine(e3.i);
		}
 	} 
}
\end{minted}
\caption{Ejemplo de clase en C\#.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo}, una estructura de cola:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System;

namespace Application
{

	class Cola{
		private int [] q;
		private int sloc, rloc;

		public void ini() { 
			sloc=rloc=-1;
        		q=new int[10];
		}

		public bool set(int val){
			if(sloc>=10){
				Console.WriteLine("la cola esta llena");
				return false;
			}
			sloc++;
			q[sloc]=val;
			return true;
		}

		public int get(){
        	  if(rloc==sloc) {
            	Console.WriteLine("la cola esta vacia");
            	return -1;
        	  }
		  else {
				rloc++;
				return q[rloc];
		  }
		}
	}

	public class PruebaCola {
		static void Main(){

			Cola a= new Cola(); // new crea realmente el objeto
			Cola b= new Cola(); // reservando la memoria
			Cola pCola= new Cola();  

    	    		//Inicializacion de los objetos
			a.ini();
			b.ini();
			pCola.ini();

			a.set(1);
			b.set(2);
			pCola.set(3);
			a.set(11);
			b.set(22);
			pCola.set(33);

			Console.WriteLine(a.get());
			Console.WriteLine(a.get());
			Console.WriteLine(b.get());
			Console.WriteLine(b.get());
			Console.WriteLine(pCola.get());
			Console.WriteLine(pCola.get());
		}
	}
}
\end{minted}
\caption{Ejemplo 2 de clase en C\#, una estructura simple de Cola.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%



%%%%%%%%%%
% D
%%%%%%%%%%
\ifd
\newpage
\section{Clases en D}

La definición de una en \textbf{D} consiste de la palabra reservada \textit{class}, seguida del nombre de la clase y finalmente el cuerpo de la clase encerrado entre. Recordar que D es un lenguaje sintácticamente similar a C++.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
class <nombre_clase> {
	<cuerpo de la clase>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{d}
class Ejemplo1 {
	int x;
 	float y;
 	void fun(int a, float b) {
		x=a;
		y=b;
 	}
}
\end{minted}

\section{Miembros de una clase en D}

	Al igual que en C++, en D una clase está formada por un conjunto de miembros que pueden ser datos, funciones, clases anidadas, enumeraciones, tipos de dato, etc. 
	
Ejemplo:

\begin{minted}{d}
class Ejemplo2{
	int i;
	int i;   //error
	int j;
	void func() {}
}
\end{minted}

\subsection{Atributos miembro}

Todos los atributos que forman parte de una clase deben ser declarados dentro de la misma.

\subsection{Métodos miembro}

	Los métodos al igual que los atributos, deber ser definidos en la clase. A diferencia de C++, la definición completa del método debe ir dentro de la clase.

Ejemplo:

\begin{minted}{d}
//código en ejemplo3.h
class Ejemplo3 {
	public:
	int x;
 	float y;
 	int funX(int a) {
		x=a;
		return x;
	}
}
\end{minted}
	
\subsection{Un vistazo al acceso a miembros}

\subsubsection{Miembros públicos}

Se utiliza cuando queremos dar a usuarios de una clase(no implementadores el acceso a miembros de esa clase, los miembros deben ser declarados públicos.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
public:
		<definición de miembros>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\subsubsection{Miembros privados}

Si queremos ocultar ciertos miembros de una clase de los usuarios de la misma, debemos declarar a los miembros como privados Por omisión los miembros se consideran privados %requiere referencia

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
private:
		<definición de miembros>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:
\begin{minted}{d}
class Fecha {
   	private:
	  int dia;
	  int mes;
	  int an;

	public:
	  char setDia(int d) {…}   //poner día
	  int getDia(){…}	//devuelve día
	  char setMes(int m) {…}
	  int getMes(){…}
	  char setAn(int a) {…}
	  int getAn(){…}
}
\end{minted}

\section{Objetos de clase en D}

Vamos a ver como es posible crear objetos o instancias de clase en D.  En D, un objeto es una variable de un tipo definido por el usuario\cite{alexandrescu2010d}. Para indicar al recolector de basura que un objeto se puede liberar, es posible ejecutar \textit{objeto.destroy()}\footnote{Anteriormente se usaba la instrucción \textit{delete}, pero ha sido descontinuada en las versiones actuales del compilador: \textit{Deprecation: The delete keyword has been deprecated.  Use object.destroy() (and core.memory.GC.free() if applicable) instead}.
1}.

%La instrucción \textit{delete} existe en D para decirle al $gc$ que la memoria esta lista para liberarse, aunque hay la intención de desaprobarla en futuras versiones del lenguaje.

Un \textcolor{blue}{ejemplo} completo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Ejemplo3;
import std.stdio;

class Ejemplo3 {
	public:
		int i;
		int j;
}

void main(string[] args) {
	Ejemplo3 e1= new Ejemplo3;
	Ejemplo3 e2= new Ejemplo3();
	e1.i=10;
	e1.j=20;
	e2.i=100;
	e2.j=20;
	writeln(e1.i);
	writeln(e2.i);
}
\end{minted}
\caption{Ejemplo de clase en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo}, una cola:
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Cola;

import std.stdio;

class Cola{
	private:
	  int [10] q;
	  int sloc, rloc;
	public:
	  void ini() {
		sloc=rloc=-1;
	  }
	  
	  char set(int val){
		  if(sloc>=10){
			  writeln("la cola esta llena");
			  return 0;
		  }
		  sloc++;
		  q[sloc]=val;
		  return 1;
	  }
	  
	  int get(){
		  if(rloc==sloc)
			  writeln("la cola esta vacia");
		  else {
			  rloc++;
			  return q[rloc];
		  }
		  return 0;
	  }
}

//cola definida en un arreglo
int main(){
	Cola a,b, pCola= new Cola; 
	a= new Cola;
	b= new Cola;
	
	a.ini();
	b.ini();
	pCola.ini();
	a.set(1);
	b.set(2);
	pCola.set(3);
	a.set(11);
	b.set(22);
	pCola.set(33);
	writeln(a.get());
	writeln(a.get());
	writeln(b.get());
	writeln(b.get());
	writeln(pCola.get());
	writeln(pCola.get());	
   	pCola.destroy();
   	return 0;
}
\end{minted}
\caption{Ejemplo 2 de clase en D, una estructura de Cola simple.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%

\section{Usando la palabra reservada this en C++, C\#, D, Scala y Java}

Cuando en algún punto dentro del código de algunos de los métodos se quiere hacer referencia al objeto ligado en ese momento con la ejecución del método, podemos hacerlo usando la palabra reservada \textit{this}. 

	Una razón para usarlo es querer tener acceso a algún atributo posiblemente oculto por un parámetro del mismo nombre.

También puede ser usado para regresar el objeto a través del método, sin necesidad de realizar una copia en un objeto temporal.

La sintaxis es la misma en C++ y en Java, con la única diferencia del manejo del operador de indirección “*” si, por ejemplo, se quiere regresar una copia y no la referencia del objeto. \textbf{D}, \textbf{C\#} y \textbf{Scala} también utilizan \textit{this}.

Ejemplo en C++:
\begin{minted}{cpp}
Fecha Fecha::getFecha(){
	return *this;
}
\end{minted}

Ejemplo en Java:
\begin{minted}{java}
class Fecha {
	private int dia;
	private int mes, an;
	…
	public Fecha getFecha(){
		 return this;
    }   
	…
}
\end{minted}


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage

\section{Usando la palabra reservada \textit{self} en Ruby}

En Ruby, para hacer referencia en un método al objeto donde es ejecutado el método (el mismo que recibe el mensaje) se usa la palabra reservada \textit{self}, en lugar de \textit{this}. 

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
class SelfEjemplo
	@x=0
	@y=0
	def getSelfEjemplo
		return self
	end
	attr_accessor :x, :y
end

#código de prueba
obj1= SelfEjemplo.new

obj1.x=10
puts obj1.x	
obj1.y="YY"
puts obj1.y

obj2=obj1.getSelfEjemplo

puts obj2.x

obj1.y=123
puts obj1.y  # despliega 123
puts obj2.y  # despliega 123 
\end{minted}
\caption{Ejemplo de uso de \textit{self} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%

%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage

\section{Usando \textit{self} en Python}

En Python, el primer argumento de un método es llamado \textit{self}. Esto no es más que una convención puesto que no se trata de una palabra reservada. Es utilizado para identificar al objeto que ejecuta al método y es necesario inclusive para el uso de sus atributos y métodos, como se ha visto en ejemplos anteriores.
	
\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

class SelfEjemplo:
    def ini(self):
        self.x=0
        self.y=0
        
    def getSelfEjemplo(self):
        return self


# script de ejecucion
obj1 = SelfEjemplo()
obj1.ini()

obj1.x=10
print(obj1.x)
obj1.y="YY"
print(obj1.y)

obj2=obj1.getSelfEjemplo()

print(obj2.x)

obj1.y=123
print(obj1.y) #despliega 123
print(obj2.y) #despliega 123

\end{minted}
\caption{Ejemplo de uso de \textit{self} en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%

\newpage
\chapter{Polimorfismo AdHoc: Sobrecarga de operaciones}
\section{Introducción}
Es posible tener el \textbf{mismo nombre} para una operación con la condición de que tenga parámetros diferentes. La diferencia debe de ser al menos en el tipo de datos. Al menos un parámetro debe ser diferente. 

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
 Si se tienen dos o más operaciones con el mismo nombre y diferentes parámetros se dice que dichas operaciones están \textbf{sobrecargadas}.  
\\ \hline
\end{tabular}
\end{center}

El compilador sabe que operación ejecutar a través de la \textbf{firma} de la operación, que es una combinación del nombre de la operación y el número y tipo de los parámetros.

El tipo de regreso de la operación puede ser igual o diferente.

La sobrecarga\footnote{También conocida como homonimia.} de operaciones sirve para hacer un código más legible y modular. La idea es utilizar el mismo nombre para operaciones relacionadas. Si no tienen nada que ver entonces es mejor utilizar un nombre distinto. A continuación ejemplos de sobrecarga en C++ y Java.

%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\section{Ejemplos de sobrecarga en C++}

\begin{minted}{cpp}
class MiClase{
	int x;

	public:
	 void modifica() {
		x++;
	}
	 void modifica(int y){
		x=y*y;
	}
}
\end{minted}

\textcolor{blue}{Ejemplo} completo e C++:
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//fuera de POO
#include <iostream>
using namespace std;

int cuadrado(int i){
	return i*i;
}
double cuadrado(double d){
	return d*d;
}

int main() {
	cout<<"10 elevado al cuadrado:  "<<cuadrado(10)<<endl;
	cout<<"10.5 elevado al cuadrado: "<<cuadrado(10.5)<<endl;
	return 0;
}
\end{minted}
\caption{Ejemplo de sobrecarga en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%

%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\section{Ejemplo de sobrecarga en Java}

\begin{minted}{java}
class MiClase{
	int x;
	public 	 void modifica() {
		x++;
	}
	public void modifica(int y){
		x=y*y;
	}
}
\end{minted}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%

%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby

\section{En Ruby no hay sobrecarga}


Ruby \textbf{no} soporta sobrecarga de operaciones. En Ruby la firma de un método es su nombre. Si dos métodos son definidos con el mismo nombre, la última implementación definida es la que se espera.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
class MiClase
	attr_reader :x
	
	def modifica
		@x+=1
	end
	def modifica y
		@x=y*y
	end
	
end

#prueba
mc=MiClase.new

puts mc.x
# mc.modifica    -- Error pues se ha redefinido el método

mc.modifica 10
puts mc.x
\end{minted}
\caption{Ejemplo en ruby, redefiniendo un método.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%


%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython

\section{Sobrecarga de operaciones en Python}
% https://www.blog.pythonlibrary.org/2016/02/23/python-3-function-overloading-with-singledispatch/

%https://docs.python.org/3.10/library/functools.html

Originalmente Python no contaba con sobrecarga de operaciones. De hecho tratar de sobrecargar de forma tradicional nos llevaría a una situación como la del siguiente ejemplo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class MiClase:
    def modifica(self):
        self.x+=1
    
    def modifica(self, y):
        self.x=y*y
        
#prueba
mc=MiClase()
mc.modifica(5)
print(mc.x)
#  mc.modifica()    -- Error pues se ha redefinido el metodo
mc.modifica(10)
print(mc.x)
\end{minted}
\caption{Ejemplo redefiniendo un método en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


Sin embargo, una aproximación al concepto de sobrecarga ha sido implementado en versiones más recientes a través decoraciones declaradas dentro del módulo \textit{functools}

\subsection{Sobrecarga de funciones con \textit{singledispatch}}
A partir de la versión 3.4 de Python, el decorador \textit{singledispatch} permitirá convertir una función tradicional en una función sobrecargada. Es importante señalar que únicamente es posible hacerlo con al tipo del primer argumento de la función.  Ejemplo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

from functools import singledispatch

@singledispatch
def suma(a, b):
    raise NotImplementedError('Tipo no soportado')

@suma.register(int)
def _(a, b):
    print("El primer argumento es de tipo: ", type(a))
    print(a + b)

@suma.register(str)
def s(a, b):        # nombre de la función no es relevante
    print("El primer argumento es de tipo: ", type(a))
    print(a + b)

@suma.register
def _(a: list, b):  #el tipo de dato puede ir especificado como "anotación"
    print("El primer argumento es de tipo: ", type(a))
    print(a + b)

suma(1, 2)
suma('Programación', 'Python')
suma([1, 2, 3], [5, 6, 7])

print('Tipos de datos manejados: ', suma.registry.keys())

\end{minted}
\caption{Ejemplo sobrecargando una función con \textit{singledispatch}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

De manera similar a otros lenguajes, la implementación del método a enviarse a ejecución es el del tipo que corresponda, en este caso al tipo del primer argumento. Es importante señalar que el nombre de la función que se registra con no es relevante.

En el siguiente código se ve que el decorador permite apilamiento para que una función soporte más de un tipo.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

from functools import singledispatch
from decimal import Decimal

@singledispatch
def suma(a, b):
    raise NotImplementedError('Tipo no soportado')

@suma.register(float)
@suma.register(Decimal)
def _(a, b):
    print("El primer argumento es de tipo:  ", type(a))
    print(a + b)

suma(1.23, 5.5)
suma(Decimal(100.5), Decimal(10.789))

print('Tipos de datos manejados: ', suma.registry.keys())

\end{minted}
\caption{Ejemplo sobrecargando una función con \textit{singledispatch} y apilamiento de decoradores.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Sobrecarga de métodos con \textit{singledispatchmethod}}

La solución pasada es útil para funciones pero no para métodos de instancia o de clase, debido a que el primer argumento aquí es para el objeto o la clase - \textit{self} o \textit{cls} -.
A partir de Python 3.8, se puede utilizar \textit{singledispatchmethod}
para sobrecargar métodos, métodos de clase, métodos abstractos o estáticos para el primer argumento del método (después de \textit{self} o \textit{cls}.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

from functools import singledispatchmethod

class Negacion:
    @singledispatchmethod
    def neg(self, arg):
        raise NotImplementedError("No puedo negar este tipo de dato")

    @neg.register
    def _(self, arg: int):
        return -arg

    @neg.register
    def _(self, arg: bool):
        return not arg


obj = Negacion()

print(obj.neg(10))
print(obj.neg(True))

\end{minted}
\caption{Ejemplo sobrecargando un método con \textit{singledispatchmethod}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

from functools import singledispatchmethod

class Negacion:
    @singledispatchmethod
    @classmethod
    def neg(cls, arg):
        raise NotImplementedError("No puedo negar este tipo de dato")

    @neg.register
    @classmethod
    def _(cls, arg: int):
        return -arg

    @neg.register
    @classmethod
    def _(cls, arg: bool):
        return not arg


obj = Negacion()

print(obj.neg(10))
print(Negacion.neg(True))

\end{minted}
\caption{Ejemplo sobrecargando un método de clase con \textit{singledispatchmethod}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%

%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala

\section{Ejemplo de sobrecarga en Scala}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class MiClase {
	var x: Int=0
    def modifica() {
        x+=1
     }
    
    def modifica(y:Int) {
        x=y*y
    }       
}
    
object Sobrecarga {
  def main(args: Array[String]) ={
	  System.out.println("Sobrecarga")
	  var mc /* : MiClase */ = new MiClase()
	  mc.modifica(5)
	  println(mc.x)
	  mc.modifica()  
	  println(mc.x)
	  mc.modifica(10)
	  println(mc.x)
  }  
}
\end{minted}
\caption{Ejemplo de sobrecarga en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%


%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp

\section{Ejemplo de sobrecarga en C\#}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System;
 
namespace Application
{
 
class MiClase {
        public int x=0;
    public void modifica() {
        x+=1;
     }
    
    public void modifica(int y) {
        x=y*y;
    }    
}
    
//public class Sobrecarga       {
class Sobrecarga {
        static void Main() {
                Console.WriteLine("Sobrecarga");
                MiClase mc = new MiClase();
                mc.modifica(5);
                Console.WriteLine(mc.x);
                mc.modifica();  
                Console.WriteLine(mc.x);
                mc.modifica(10);
                Console.WriteLine(mc.x);
        }
}
        
}
\end{minted}
\caption{Ejemplo de sobrecarga en C\#.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%


%%%%%%%%%%
% D
%%%%%%%%%%
\ifd

\section{Ejemplo de sobrecarga en D}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Sobrecarga;

import std.stdio;


class MiClase {
	public:
		int x=0;
		void modifica() {
			x+=1;
		}
    
		void modifica(int y) {
			x=y*y;
		}    
}
    
//public class Sobrecarga	{
int main() {
		writeln("Sobrecarga");
		MiClase mc = new MiClase();
		mc.modifica(5);
	  	writeln(mc.x);
	  	mc.modifica();  
	  	writeln(mc.x);
	  	mc.modifica(10);
	  	writeln(mc.x);
	  	return 0;
}
\end{minted}
\caption{Ejemplo de sobrecarga en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%

\newpage
\chapter{Constructores y destructores}

%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Constructores y destructores en C++}

Con el manejo de los tipos de datos primitivos, el compilador se encarga de reservar la memoria y de liberarla cuando estos datos salen de su ámbito. 

En la programación orientada a objetos, se trata de proporcionar mecanismos similares, aunque con mayor funcionalidad. Cuando un objeto es creado es llamado un método conocido como \textbf{constructor}, y al salir se llama a otro conocido como \textbf{destructor}. Si no se proporcionan estos métodos  se asume la acción más simple.

\subsection{Constructor}

Un \textbf{constructor} es un método con el mismo nombre de la clase. Este método no puede tener un tipo de dato y si puede permitir la homonimia o sobrecarga.

Ejemplo:
\begin{minted}{cpp}
class Cola{
	private:
	int q[100];
	int sloc, rloc;
 	
 	public:
	Cola( );	//constructor
	void put(int);
	int get( );
};

//implementación del constructor
Cola::Cola ( ) {
	sloc=rloc=0;
	cout<<"Cola inicializada \n";
}
\end{minted}

Un constructor si puede ser llamado desde un método de la clase.

\subsubsection{Lista de inicialización de atributos Constructor }
En C++, se pueden  inicializar los atributos de una clase después de los parámetros del constructor utilizando una lista de inicialización. La lista de inicialización se coloca después de la lista de parámetros del constructor y antes del cuerpo del constructor.

Aquí se presenta un ejemplo:


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}

#include <iostream>

class MiClase {
public:
    // Constructor con parámetros
    MiClase(int parametro1, int parametro2) 
        : atributo1(parametro1), atributo2(parametro2) {
        // Cuerpo del constructor (si es necesario)
        // Puedes realizar más inicializaciones o lógica aquí
    }

    // Otros métodos y miembros de la clase

private:
    int atributo1;
    int atributo2;
};

int main() {
    // Crear un objeto de la clase MiClase e inicializar sus atributos
    MiClase objeto(10, 20);

    return 0;
}

\end{minted}
\caption{Ejemplo de lista de inicialización de atributos en un constructor en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El constructor de \textit{MiClase} toma dos parámetros enteros y utiliza una lista de inicialización para asignar esos valores a los atributos \textit{atributo1} y \textit{atributo2}. Esto es una práctica recomendada en C++ porque puede ayudar a mejorar el rendimiento y evitar ambigüedades en la inicialización de los miembros de la clase, pero tiene como desventaja que no incluye la validación de los mismos.

\subsubsection{Constructor de Copia}

Es útil agregar a todas las clases un constructor de copia que reciba como parámetro un objeto de la clase y copie sus datos al nuevo objeto. 

C++ proporciona un constructor de copia por omisión, sin embargo es una \textbf{copia a nivel de miembro} y puede no realizar una copia exacta de lo que queremos. Por ejemplo en casos de apuntadores a memoria dinámica, se tendría una copia de la dirección y no de la información referenciada.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}| <nombre clase>(const <nombre clase> &<objeto>);  |\\
\hline
\end{tabular}
\end{center}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//ejemplo de constructor de copia
#include <iostream>
#include <time.h>
#include <stdlib.h>

using namespace std;

class Arr{
	private:
	int a[10];
	public:
	
	Arr(int x=0) {
		for( int i=0; i<10; i++){
			if (x==0)
				x=rand();
			a[i]=x;
	}
}

	Arr(const Arr &copia){   //constructor de copia
		for( int i=0; i<10; i++)
			a[i]=copia.a[i];
	}

	char set(int, int);
	int get(int) const ;
	int get(int);
};

char Arr::set(int pos, int val ){
	if(pos>=0 && pos<10){
		a[pos]=val;
		return 1;
	}
	return 0;
} 

int Arr::get(int pos) const {
	if(pos>=0 && pos<10)
		return a[pos];
	//   a[9]=0;  error en un metodo constante
	return 0;
}

int Arr::get(int pos) {  //no es necesario sobrecargar
	if(pos>=0 && pos<10)   // si el metodo no modifica
		return a[pos];
	return 0;
}

int main(){
	Arr a(5), b;
	srand( time(NULL) );
	
	a.set(0,1);
	a.set(1,11);
	cout<<a.get(0)<<endl;
	cout<<a.get(1)<<endl;

	b.set(0,2);
	b.set(1,22);
	cout<<b.get(0)<<endl;
	cout<<b.get(1)<<endl;

	Arr d(a);
	cout<<d.get(0)<<endl;
	cout<<d.get(1)<<endl;
	
	return 0;
}
\end{minted}
\caption{Ejemplo de constructor de copia en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Destructor}

 	La contraparte del constructor es el \textbf{destructor}. Este se ejecuta momentos antes de que el objeto sea destruido, ya sea porque salen de su ámbito o por medio de una instrucción \textit{delete}. El uso más común para un destructor es liberar la memoria asignada dinámicamente, aunque puede ser utilizado para otras operaciones de finalización, como cerrar archivos, una conexión a red, etc.

	El destructor tiene al igual que el constructor el nombre de la clase pero con una tilde como prefijo (\~).

	El destructor tampoco regresa valores ni tiene parámetros. 

\textcolor{blue}{Ejemplo:}

\begin{minted}{cpp}
class Cola{
 	private:
	int q[100];
	int sloc, rloc;
 	
 	public:
	Cola( );	//constructor
	~Cola();  //destructor
	void put(int);
	int get( );
};

Cola::~Cola( ){
	cout<<"cola destruida\n";
}
\end{minted}

\textcolor{blue}{Ejemplo} completo de Cola con constructor y destructor:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//cola definida en un arreglo
//incluye constructores y destructores de ejemplo
#include <iostream>
#include <string.h>
#include <stdio.h>

using namespace std;

class Cola{
	private:
	int q[10], sloc, rloc;
	char *nom;

	public:
	Cola(const char *cad=NULL) {  //funcion en linea
		if(cad){   //cadena!=NULL
			nom=new char[strlen(cad)+1];
			strcpy(nom, cad);
		}else
			nom=NULL;
		sloc=rloc=-1;
	}
	~Cola( ) {
		if(nom){  //nom!=NULL
			cout<<"Cola : "<<nom<<" destruida\n";
			delete [] nom;
		}
	}

	char set(int);
	int get();
};

char Cola::set(int val){
	if(sloc>=10){
		cout<<"la cola esta llena";
		return 0;
	}
	sloc++;
	q[sloc]=val;
	return 1;
}
int Cola::get(){
	if(rloc==sloc)
		cout<<"la cola esta vacia";
	else {
		rloc++;
		return q[rloc];
	}
	return 0;
}

int main(){
	Cola a("Cola a"),b("Cola b"),
		*pCola= new Cola("Cola dinamica pCola");
	a.set(1);
	b.set(2);
	pCola->set(3);
	a.set(11);
	b.set(22);
	pCola->set(33);
	cout<<a.get()<<endl;
	cout<<a.get()<<endl;
	cout<<b.get()<<endl;
	cout<<b.get()<<endl;
	cout<<pCola->get()<<endl;
	cout<<pCola->get()<<endl;
	
	delete pCola;
}
\end{minted}
\caption{Ejemplo completo de Cola con constructor y destructor en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%


%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage

\section{Constructores y finalizadores en Java}

En Java, cuando un objeto es creado es llamada un método conocido como \textbf{constructor}, y al salir se llama a otro conocido como \textbf{finalizador}\footnote{En C++ no existe el concepto de finalizador, sino el de destructor, porque su tarea primordial es liberar la memoria ocupada por el objeto, cosa que no es necesario realizar en Java.}. Si no se proporcionan estos métodos se asume la acción más simple.

\subsection{Constructor}

Un constructor es un método con el mismo nombre de la clase. Este método no puede tener un tipo de dato de retorno y si puede permitir la homonimia o sobrecarga, y la modificación de acceso al mismo.

Ejemplo:

\begin{minted}{java}
public class Cola{
	private int q[];
	private int sloc, rloc;
	public void put(int){ ... }
	public int get( ){ ... }
	//	implementación del constructor
	public Cola ( ) {
		sloc=rloc=0;
		q= new int[100];
		System.out.println("Cola inicializada ");
	}
}
\end{minted}

El constructor se ejecuta en el momento de asignarle la memoria a un objeto, y es la razón de usar los paréntesis junto al nombre de la clase al usar la instrucción \textit{new}:

\mint[linenos=false]{java}| Fecha f = new Fecha(10,4,2007); |

Si no se especifica un constructor, Java incluye uno predeterminado, que asigna memoria para el objeto e inicializa  las variables de instancia a valores predeterminados. Este constructor se omite si se especifica uno o más por parte del programador.

\subsection{Finalizador}

La contraparte del constructor en Java es el método \textit{finalize} o finalizador. Este se ejecuta momentos antes de que el objeto sea destruido por el recolector de basura. El uso más común para un finalizador es liberar los recursos utilizados por el objeto, como una conexión de red o cerrar algún archivo abierto.

No es muy común utilizar un método finalizador, más que para asegurar situaciones como las mencionadas antes. El método iría en términos generales como se muestra a continuación\footnote{ No se ha mencionado el modificador \textit{protected}. Este concepto se explicará una vez que se haya visto el manejo de herencia.}:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
protected void finalize() {
	<instrucciones>
} 
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

El finalizador puede ser llamado como un método normal, inclusive puede ser sobrecargado, pero un finalizador con parámetros no puede ser ejecutado automáticamente por la máquina virtual de Java. Se recomienda evitar el definir un finalizador con parámetros.

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%



%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage

\section{Inicializadores en Ruby}

En Ruby, el método que podemos usar para inicializar un objeto es llamado \textit{initialize}. No es llamado constructor porque, en Ruby, son internamente dos procesos separados. El método \textit{initialize} no es un constructor y es definido automáticamente como privado.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\hline
La explicación para esto es que las clases en Ruby son instancias de la clase \textit{Class}. Por cada clase definida, un objeto de tipo \textit{Class} es creado y asignado a una constante del nombre especificado en la declaración de la clase. Cuando el método \textit{new} es llamado ($NombreClase.new$) para crear un objeto, se ejecuta por default el método \textit{new} de \textit{Class}, el cual ejecuta al método \textit{allocate} para asignar la memoria del objeto, y por último, el método \textit{initialize} del nuevo objeto es ejecutado.  
\\ \hline
\end{tabular}
\end{center}

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
class NombreClase
	def initialize [(lista de parámetros)] 
		<código>
	end
	...
end
...
obj = NombreClase.new [(parámetros)]
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{ruby}
class Cola
	def initialize
		@sloc= @rloc=-1
		@q=[]
	end
	...	
end
\end{minted}

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%



%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage

\section{Inicializando y eliminando en Python}

Clases en Python no tienen  constructores ni destructores explícitos. Lo más parecido a un constructor es el método \_\_init()\_\_ . El concepto es similar al de inicialización de objetos en Ruby.
El método \_\_init()\_\_ está implementado por omisión y no estamos obligados a definirlo. Podemos añadir atributos en otros métodos sin necesidad de inicializarlos en el método \textit{init}:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Rectángulo:
       def area(self) -> float:
           return self.largo * self.ancho

r = Rectángulo()
r.largo, r.ancho = 11, 9
print(r.area())
\end{minted}
\caption{Ejemplo mostrando el uso de atributos sin añadirlos en \textit{init}.}
\label{listing:1}
\end{longlisting}

Sin embargo, no se considera una buena práctica pues puede generar confusión y errores. Lo mejor es inicializar los atributos en el método \textit{init}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
class NombreClase:
    def __init__(self, [<parametros>]):
	<código>
	...

obj = NombreClase([<parámetros>])
    \end{minted}
\\ \hline
\end{tabular}
\end{center}


%\end{minted}

Ejemplo:

\begin{minted}{python}
class Cola:
	
	def __init__(self)
		self.sloc= self.rloc=-1
		self.q=[]
	end
	...	
end
\end{minted}

Por otro lado, el método $\_\_del\_\_()$ es lo más parecido que se tiene a un destructor, más parecido realmente al finalizador de java, ya que es llamado cuando todas las referencias a un objeto se han eliminado y éste es recogido por el recolector de basura.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#Ejemplo de inicializador y eliminador en Python
class Empleado: 
    # Inicializador 
    def __init__(self): 
        print('Objeto empleado creado.') 
  
    # Eliminando (Llamando al 'destructor') 
    def __del__(self): 
        print('Destructor llamado, Empleado borrado.') 
  
obj = Empleado() 
del obj 
\end{minted}
\caption{Ejemplo mostrando el uso de los métodos \_\_init\_\_() y \_\_del\_\_() en Python.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala
\newpage

\section{Constructores en Scala}

Scala distingue entre un constructor primario y constructores secundarios. El constructor primario en realidad se forma con la definición de la clase seguida de una lista de parámetros. Una clase en Scala con su sección de parámetros es llamada clase \textbf{polimórfica}, de otro modo, una clase sin parámetros es una clase \textbf{monomórfica}. Estos parámetros de clase pueden ser usados directamente dentro de la definición de la misma y ya no es necesario definirlos como atributos.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{scala}
class NombreClase (<parametros>) {
 
}
…
obj = new NombreClase([<parámetros>])
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Esto permite ahorrar espacio y tener una clase potencialmente más concisa. Pero ¿Qué pasa si yo necesito validar los valores de los parámetros? Dentro del código de la clase es posible insertar dicho código y formará parte del constructor primario.

Ejemplo\footnote{Si no se especifica un identificador de tipo var, se toma como de tipo val por omisión}:
\begin{minted}{scala}
class Cola(var sloc: Int, var rloc: Int, var q: Array[Int]) {
	if (q==null) {
		sloc=-1
		rloc=-1
	}
	
}
\end{minted}

Es posible tener constructores auxiliares de la forma:

 TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{scala}
def this([<parámetros>])
    <instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}


\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%


%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp
\newpage

\section{Constructores y destructores en C\#}

Constructores y destructores pueden ser definidos en C\# de forma similar a C++.

\subsection{Constructor}
	Un constructor en C\# es definido especificando un método del mismo nombre de la clase.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{csharp}
class NombreClase {
    NombreClase([<parametros>]) {
		<código>
	}
}
...
obj = new NombreClase([<parámetros>]);
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{csharp}
class Cola{
	private int q[];
	private int sloc, rloc;
	public void put(int){ 
//...
	 }
	public int get( ){ 
//... 
	}
	//	implementación del constructor
	public Cola ( ) {
		sloc=rloc=0;
		q= new int[100];
		Console.WriteLine("Cola inicializada ");
	}
}
\end{minted}

\subsection{Destructor}

C\# cuenta con un recolector de basura, por lo que el uso del destructor no es tan frecuente como en C++. Aún así es posible definir un destructor usando la misma sintaxis de C++:

\begin{minted}{csharp}
~Cola( ){
	Console.WriteLine("cola destruida");
}
\end{minted}

Su comportamiento en realidad es más parecido al finalizador de Java.


\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%


%%%%%%%%%%
% D
%%%%%%%%%%
\ifd
\newpage
\section{Constructores y destructores en D}

D incluye también el concepto de y destructor de objetos.

\subsection{Constructor}

Aunque los miembros de una clase son incializados en D por su valor por omisión o inicializándolos estáticamente en el momento de la definición del miembro,  es posible definir un constructor en D es definido especificando un método con el nombre de \textit{this}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
class NombreClase {
    this([<parametros>]) {
		<código>
	}
}
...
obj = new NombreClase([<parámetros>]);
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\begin{minted}{d}
class Cola{
	private:
int q[];
		int sloc, rloc;
	public:
void put(int){ 
//...
	 	}
		int get( ){ 
//... 
		}
	//	implementación del constructor
	this ( ) {
		sloc=rloc=0;
		q= new int[100];
		writeln("Cola inicializada ");
	}
}
\end{minted}

\subsection{Destructor}

 D cuenta con un recolector de basura, sin embargo al igual que C\# cuenta con la opción de definir un destructor.
 
\begin{minted}{d}
~this( ){
	writeln("cola destruida");
}
\end{minted}

\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%

\chapter{Miembros de clase  o estáticos}

Cada objeto tiene su propio estado, pero a veces es necesario tener valores por clase y no por objeto. En esos casos se requiere tener atributos \textbf{estáticos} que sean compartidos por todos los objetos de la clase.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
Existe solo una copia de un miembro estático y no forma parte de los objetos de la clase. Este tipo de miembro son también conocidos como miembros de clase.   
\\ \hline
\end{tabular}
\end{center}

\includegraphics[scale=.9]{imagenes/miembros_estaticos.png}


%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Miembros estáticos en C++}

Un miembro estático es accesible desde cualquier objeto de la clase o mediante el operador de resolución de alcance binario (::) y el nombre de la clase, dado que el miembro estático \textbf{existe} aunque no haya instancias de la clase. 

Sin embargo, el acceso sigue restringido bajo las reglas de acceso a miembros:
 
\begin{itemize}
\item  Si se quiere acceder a un miembro estático que es privado deberá hacerse mediante un método público. 
\item  Si no existe ninguna instancia de la clase entonces deberá ser por medio de un método público y estático.
\end{itemize}

Además, un método estático solo puede tener acceso a miembros estáticos.

Ejemplo:

\begin{minted}{cpp}
class Objeto{
	private:
	char nombre[10];
	static int numObjetos;
 	public:
	Objeto(char *cadena=NULL);
	~Objeto();
};

Objeto::Objeto(const char *cadena){
	if(cadena!=NULL)
		strcpy(nombre, cadena);
	else
		nombre=NULL;
	numObjetos++;
}

Objeto::~Objeto(){
	numObjetos--;
}	
\end{minted}

Los atributos estáticos deben de ser inicializados al igual que los atributos constantes, fuera de la declaración de la clase. Por ejemplo:

\mint[linenos=false]{cpp}| int Clase::atributo=0;		int const Clase::ATRCONST=50; |

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//prueba de miembros estáticos
#include <iostream>
#include <stdio.h>
#include <string.h>

using namespace std;

class Persona{
	private:
	static int nPersonas;
	static const int MAX;
	char *nombre;
	
	public:
	Persona(const char *c=NULL){
		if(c!=NULL){
			nombre= new char[strlen(c)+1];
			strcpy(nombre, c);
			cout<<"Persona: "<<nombre<<endl;
		}else{
			nombre=NULL;
			cout<<"Persona: "<<endl;
		} 
		nPersonas++;
	}
	
	~Persona(){
		cout<<"eliminando persona : "<<nombre<<endl;
		if(nombre)
			delete []nombre;
		nPersonas--;
	}

	static int getMax(){
		return MAX;
	}
	
	static int getnPersonas(){
		return nPersonas;
	}
};
int Persona::nPersonas=0;
const int Persona::MAX=10;

int main() {
	 
	cout<<"Máximo de personas: "<<Persona::getMax()<<endl;
	cout<<"Número de personas: "<<Persona::getnPersonas()<<endl;

	Persona per1;
	cout<<"Máximo de personas: "<<Persona::getMax()<<endl;
	cout<<"Número de personas: " <<Persona::getnPersonas()<<endl;

	Persona per2("persona 2");
	cout<<"Máximo de personas: "<<per2.getMax()<<endl;
	cout<<"Número de personas: "<<per2.getnPersonas()<<endl;
	return 0;
}	
\end{minted}
\caption{Ejemplo miembros estáticos en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%



%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Miembros estáticos en Java}
Un miembro estático en Java se maneja de la misma forma que en C++. Cada uno de los objetos tiene su propio estado independiente del resto de los objetos, compartiendo al  mismo tiempo un estado común al tener todos los objetos acceso al estado de la clase, el cual es único y existe de forma independiente.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class Objeto{
    private String nombre;
	private static int numObjetos;
	public Objeto(String cadena){
                if(cadena.length()!=0)
			nombre=cadena;
		else
			nombre="cadena por omision";
		numObjetos++;
	}

	public static int getNumObjetos(){
		return numObjetos;
	}

	public static void main(String argv[]) {
                System.out.println("Objetos: " + getNumObjetos());
                System.out.println("Objetos: " + Objeto.getNumObjetos());
                Objeto uno,dos;
                uno= new Objeto("");
                dos= new Objeto("Objeto dos");
                System.out.println("Objetos: " + uno.getNumObjetos());
                System.out.println("Objetos: " + dos.getNumObjetos());         
	}
}
\end{minted}
\caption{Ejemplo de miembros estáticos en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Una diferencia que se puede apreciar en este ejemplo con respecto a C++, es que no estamos obligados a inicializar el elemento estático, pues éste es inicializado automáticamente.

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Miembros de clase en Ruby}

Los elementos estáticos en Ruby son conocidos como miembros de clase, el cual es un término también usado en otros lenguajes debido a que el ámbito de los miembros va  más allá del objeto pues existen en la clase sin depender de un objeto en particular y representan, como ya mencionamos, un estado de la clase.

\subsection{Atributos de clase}

Las variables de clase en Ruby son nombradas usando @@ como prefijo y deben ser inicializadas antes de ser usadas en definiciones de métodos. Referenciar un atributo de clase no inicializado genera un error. Las variables de clase son compartidas entre descendientes de las clases donde estas fueron definidas.

\subsection{Métodos de clase}

Los métodos de clase son definidos en Ruby usando como prefijo el nombre de la clase o la palabra reservada \textit{self} seguido de punto y el nombre del método de clase. \textit{self} se resuelve como el nombre de la clase en este caso, siendo un comportamiento distinto a cuando es usado dentro de un método (\textit{self} se resuelve como el objeto en ejecución).

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
class Persona
	@@nPersonas=0
	@@MAX=100 	# no es una constante 
	@nombre
	def initialize nom
		@nombre=nom
		puts "Persona: " + @nombre if nom.size>0
		@@nPersonas+=1
	end
	
	def self.getMax
		return @@MAX
	end
	
	def Persona.getnPersonas
		return @@nPersonas
	end
	
end

#código principal

puts "Numero maximo de personas: #{Persona.getMax}"
puts "Numero de personas: #{Persona.getnPersonas}"

per1 = Persona.new "Persona 1"
puts "Numero maximo de personas: #{Persona.getMax}"
puts "Numero de personas: #{Persona.getnPersonas}"

per2 = Persona.new "Persona 2"
puts Persona.getMax
puts Persona.getnPersonas
# puts per2.getMax    -- error

\end{minted}
\caption{Ejemplo de miembros de clase en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

A diferencia de C++ y Java, en Ruby un método de clase no puede ser accedido mediante un objeto. Un método de clase solo puede ser usado externamente mediante el nombre de la clase.

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%


%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Miembros estáticos / de clase en Python}

En Python existe el concepto de atributos de clase y métodos de clase, pero estos últimos se diferencian de los métodos estáticos como se explica a continuación.

\subsection{Atributos de clase}

	En Python los \textbf{atributos de clase} en realidad son los atributos que se definen \textbf{dentro de la clase}. Los atributos de instancia (\textit{data attributes} en Python) son definidos dentro del método $\_\_init\_\_$.

\subsection{Método de clase y Método estático}

En Python existe una ligera diferencia entre un método de clase y un método estático. Son definidos usando \textit{decorators}: \textit{@staticmethod }y \textit{@classmethod}.  Un método de clase recibe a la clase como primer argumento, de la misma forma que un método de instancia recibe a la instancia como primer argumento, por lo que tiene el ámbito de la clase. Como en Java, el método puede ser llamado mediante el nombre de la clase o el de un objeto de la clase. El método estático por su parte, no recibe un argumento implícito\footnote{ \href{ http://www.bogotobogo.com/python/python_differences_between_static_method_and_class_method_instance_method.php}{Class method vs static method 2015}}, por lo que \textbf{no puede modificar ni el estado de un objeto ni el de la clase}.   Un \textcolor{blue}{ejemplo} marcando la diferencia:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class A:
    def metodo(self,x):
        print ("ejecutando metodo(%s,%s)"%(self,x))
 
    @classmethod
    def metodo_de_clase(cls,x):
        print ("ejecutando metodo de clase(%s,%s)"%(cls,x))
 
    @staticmethod
    def metodo_estatico(x):
        print ("ejecutando metodo estatico(%s)"%x)

#Script de ejecución
a=A()
 
#La llamada normal a un método de instancia. 
#El objeto es pasado de manea implícita como primer argumento
a.metodo(1)
# salida: ejecutando metodo(<__main__.A object at 0xb7dbef0c>,1)
 
# En un metodo de clase, la clase del objeto es pasada 
# implicitamente como primer argumento
a.metodo_de_clase(1)
# salida: ejecutando metodo de clase(<class '__main__.A'>,1)
 
# Tambien puede ejecutarse un metodo de clase usando 
# el nombre de la clase 
A.metodo_de_clase(1)
# salida: ejecutando metodo de clase(<class '__main__.A'>,1)
 
# Un metodo estatico no pasa implicitamente ni al objeto 
# ni la clase como primer argumento
a.metodo_estatico(1)
# salida: ejecutando metodo estatico(1)
 
#metodo esta confinado al objeto a 
print(a.metodo)
 
#metodo_de_clase esta confinado a la clase A, no a al objeto a
print(a.metodo_de_clase)
 
# metodo_estatico no esta confinado ni al objeto 
# ni a la clase, no va dicha informacion como argumento
print(a.metodo_estatico)
print(A.metodo_estatico)
\end{minted}
\caption{Ejemplo de métodos estáticos y de clase en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Persona:
    nPersonas=0
    MAX=100     # no es una constante 
    def __init__(self, nom):
        self.nombre=nom
        print("Persona: " + self.nombre)
        Persona.nPersonas+=1
        
    @classmethod    
    def getMax(cls):
        return cls.MAX

    @classmethod
    def getnPersonas(cls):
        return cls.nPersonas
    
    def getnPersonas2(self):
        return self.nPersonas

#código principal

print("Numero maximo de personas:", Persona.getMax() )
print("Numero de personas:", Persona.getnPersonas() )

per1 = Persona("Persona 1")
print("Numero maximo de personas: ", Persona.getMax() )
print("Numero de personas: ", Persona.getnPersonas() )

per2 = Persona("Persona 2")
print(Persona.getMax() )
print(per2.getnPersonas() )
print(per2.getnPersonas2() )
\end{minted}
\caption{Ejemplo de métodos de clase en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textcolor{blue}{Ejemplo:}


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
from datetime import date

class Persona:
	def __init__(self, nombre, edad):
		self.nombre = nombre
		self.edad = edad

	# método de clase crea una clase persona por año de nacimiento.
	@classmethod
	def porAñoNacimiento(cls, nombre, año):
		return cls(nombre, date.today().year - año)

	# método estático para verificar si una persona es un adulto
	@staticmethod
	def esAdulto(edad):
		return edad > 18

persona1 = Persona('un nombre', 30)
persona2 = Persona.porAñoNacimiento('otro nombre', 1999)

print("Edad: ", persona1.edad)
print("Edad: ", persona2.edad)

print("¿Es adulto?", Persona.esAdulto(22))

\end{minted}
\caption{Ejemplo de métodos de clase y estático en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala
\newpage
\section{Miembros estáticos en Scala}

Scala no cuenta con miembros estáticos. Una opción es utilizar la definición de miembros “estáticos” en objetos únicos (\textit{singleton}). Un ejemplo de este tipo de estructura se vio en el ejemplo de inicial del lenguaje:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
object HolaMundo {
  def main(args: Array[String])  ={
    println("Hola, Mundo!")
  }
}
\end{minted}
\caption{Ejemplo de objeto único \textit{singleton} en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Donde \textit{HolaMundo} es un objeto único que por lo tanto no tiene que ser instanciado.


\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%



%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp
\newpage
\section{Miembros estáticos / de clase en C\#}
Un miembro estático en C\# se maneja de forma similar a C++ y Java. Cada uno de los objetos tiene su propio estado independiente del resto de los objetos. También, el los miembros estáticos sirven para definir un estado de clase. Sin embargo,  los objetos no tienen acceso dicho estado, por lo que los miembros estáticos únicamente pueden ser accedidos usando el nombre de la clase. 

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System;
class Objeto{
    	private String nombre;
	private static int numObjetos;
	public Objeto(String cadena){
                if(cadena.Length!=0)
			nombre=cadena;
		else
			nombre="cadena por omision";
		numObjetos++;
	}

	public static int getNumObjetos(){
		return numObjetos;
	}

	public static void Main() {
                Console.WriteLine("Objetos: " + getNumObjetos());
                Console.WriteLine("Objetos: " + Objeto.getNumObjetos());

                Objeto uno,dos;

			   uno= new Objeto("");
                dos= new Objeto("Objeto dos");
                // valido en Java y C++ pero no en  C#
                //Console.WriteLine("Objetos: " + uno.getNumObjetos());
                //Console.WriteLine("Objetos: " + dos.getNumObjetos());      
                // error CS0176: Static member `Objeto.getNumObjetos()' cannot be accessed with an instance reference, qualify it with a type name instead  
                Console.WriteLine("Objetos: " + getNumObjetos()); 
	}
}
\end{minted}
\caption{Ejemplo de miembros estáticos en C\#.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
//prueba de miembros estáticos
using System;

class Persona{
        private static int nPersonas;
        // private static const int MAX=10;
        // constantes son estaticas por default
        private const int MAX=10;
        
        string nombre;

        public Persona(string c){
             if(c.Length!=0)
			// no se proporciona un constructor que reciba un string
                  //nombre= new string(c); 
                  nombre= (string) c.Clone();  // o c.Copy() Ver diferencia entre copia superficial y profunda (shallow & deep copy)

             else
                  nombre="";
             Console.WriteLine("Persona: "+nombre);
			nPersonas++;
		}

        	public static int getMax(){
			return MAX;
		}
       	public static int getnPersonas(){
			return nPersonas;
		}

        public static void Main() {
        		Console.WriteLine("Maximo de personas: "+Persona.getMax());
        		Console.WriteLine("Numero de personas: "+Persona.getnPersonas());

          	Persona per1= new Persona("");
            	Console.WriteLine("Maximo de personas: "+Persona.getMax());
         	Console.WriteLine("Numero de personas: "+Persona.getnPersonas());

         	Persona per2= new Persona("persona 2");
          	//Console.WriteLine("Maximo de personas: "+per2.getMax());
             //Console.WriteLine("Numero de personas: "+per2.getnPersonas());
			Console.WriteLine("Maximo de personas: "+Persona.getMax());
	        Console.WriteLine("Numero de personas: "+Persona.getnPersonas());


                Persona per3= new Persona("persona 3");
                Console.WriteLine("Maximo de personas: "+Persona.getMax());
                Console.WriteLine("Numero de personas: "+Persona.getnPersonas());			
       }
}
\end{minted}
\caption{Ejemplo 2 de miembros estáticos en C\#.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Al igual que en Java, no estamos obligados a inicializar el atributo estático. 

El manejo de cadenas aquí cambió ligeramente debido a que C\# no proporciona un constructor del tipo \textit{string(string)}. Se usó el método \textit{Clone()} el cual genera una copia superficial del objeto. En este caso una copia profunda \textit{Copy()} hubiera dado el mismo resultado. Otro aspecto importante en cuanto a cadenas es que en C\# las cadenas son inmutables, por lo que si se requiere un cambio a una cadena debe generarse en una nueva. La restricción es para hacer un manejo más eficiente de las cadenas.


\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%



%%%%%%%%%%
% D
%%%%%%%%%%
\ifd
\newpage
\section{Miembros estáticos / de clase en D}

El manejo de miembros estáticos es similar al de C++

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Objeto;
import std.stdio;
 
class Objeto{
    private:
        string nombre;
        static int numObjetos;
   public:
        this(string cadena){
                if(cadena.length!=0)
                        nombre=cadena;
                else
                        nombre="cadena por omision";
                numObjetos++;
        }
 
        static int getNumObjetos(){
                return numObjetos;
        }
}
int main() {
        writeln("Objetos: ", Objeto.getNumObjetos());
 
        Objeto uno,dos;
        uno= new Objeto("");
        dos= new Objeto("Objeto dos");
        writeln("Objetos: ", uno.getNumObjetos());
        writeln("Objetos: ", dos.getNumObjetos());        
        return 0; 
}
\end{minted}
\caption{Ejemplo de miembros estáticos en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro \textcolor{blue}{ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Persona;
 
import std.stdio;
 
class Persona{
        private:
                static int nPersonas;
                static const int MAX=10;
                string nombre;
        
        public:
                this(string s=null){
                if(s!=null){
                        nombre= s;
                        writeln("Persona: ", nombre);
                }else{
                        nombre=null ;
                        writeln("Persona: ");
                } 
                nPersonas++;
        }
        
        ~this(){
                writeln("eliminando persona : ", nombre);       
                nPersonas--;
        }
 
        static int getMax(){
                return MAX;
        }
        
        static int getnPersonas(){
                return nPersonas;
        }
}

int main() {       
        writeln("Máximo de personas: ", Persona.getMax());
        writeln("Número de personas: ", Persona.getnPersonas());
 
        Persona per1= new Persona();
        writeln("Máximo de personas: ", Persona.getMax());
        writeln("Número de personas: ", Persona.getnPersonas());
 
        Persona per2= new Persona("persona 2");
        writeln("Máximo de personas: ", per2.getMax());
        writeln("Número de personas: ", per2.getnPersonas());
        return 0;
}
\end{minted}
\caption{Ejemplo 2 de miembros estáticos en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Como en Java, no estamos obligados a inicializar los atributos estáticos.

\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%

\chapter{Objetos constantes}
	Algunas ocasiones puede ser útil tener objetos constantes, los cuales no puedan ser modificados. Sin embargo, cada lenguaje interpreta de manera ligeramente distinta, como se verá a continuación.
	



%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
%\newpage

\section{Objetos constantes en C++}

En C++, es posible tener objetos de tipo constante, los cuales no podrán ser modificados en ningún momento\footnote{Ayuda a cumplir el principio del mínimo privilegio, donde se debe restringir al máximo el acceso a los datos cuando este acceso estaría de sobra\cite{mcaffer2010eclipse}.} Tratar de modificar un objeto constante se detecta como un error en tiempo de compilación.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}| const <clase> <lista de objetos>;  |\\
\hline
\end{tabular}
\end{center}	

Ejemplo:

\mint[linenos=false]{cpp}| const Hora h1(9,30,20); |

Para estos objetos, algunos compiladores llegan a ser tan rígidos en el cumplimiento de la instrucción, que no permiten que se hagan llamadas a métodos sobre esos objetos.  La compilación estándar permite la ejecución de métodos, siempre y cuando no modifiquen el estado del objeto. 

Si se quiere  consultar al objeto mediante llamadas a métodos get, lo correcto es declarar métodos con la palabra reservada \textit{const}, para permitirles actuar libremente sobre los objetos sin modificarlo. La sintaxis requiere añadir después de la lista de parámetros la palabra reservada \textit{const} en la declaración y en su definición. 


% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
Declaración.
\\ 
    \begin{minted} [linenos=false]{cpp}
<tipo> <nombre> (<parámetros>) const;
    \end{minted}
\\ 
Definición del método fuera de la declaración de la clase.
\\
    \begin{minted} [linenos=false]{cpp}
	<tipo> <clase> :: <nombre> (<parámetros>) const {
		<código>
	}
	\end{minted}
\\
Definición del método dentro de la declaración de la clase.
\\
    \begin{minted} [linenos=false]{cpp}
	<tipo> <nombre> (<parámetros>) const {
		<código>
	}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Los compiladores generalmente restringen el uso de métodos constantes a objetos constantes. Para solucionarlo es posible sobrecargar  el método con la única diferencia de la palabra \textit{const}, aunque el resto de la firma del método sea la misma. 

Un método puede ser declarado dos veces tan sólo con que la firma del método difiera por el uso de \textit{const}. Objetos constantes ejecutarán al método definido con \textit{const}, y objetos variables ejecutarán al método sin esta restricción. De hecho, un objeto variable puede ejecutar el método no definido con \textit{const} por lo que si el objetivo del método es el mismo, y este no modifica al objeto (e.g., métodos tipo \textit{get}) bastaría con definir al método una vez\footnote{Además, declarar a los métodos \textit{get} y otros métodos que no modifican al objeto con el calificador \textit{const} es una buena práctica de programación.}.

Los constructores no necesitan la declaración \textit{const}, puesto que deben poder modificar al objeto.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
#include <iostream>
#include <time.h>
#include <stdlib.h>

using namespace std;

class Arr{
	private:
	int a[10];
	public:
	Arr(int x=0) {
		srand( time(NULL) );
		for( int i=0; i<10; i++){
			if (x==0)
				x=rand()%100;
			a[i]=x;
		}
	}
	char set(int, int);
	int get(int) const ;
	int get(int);
};

char Arr::set(int pos, int val ){
	if(pos>=0 && pos<10){
		a[pos]=val;
		return 1; 
	}
	return 0;
}

int Arr::get(int pos) const {
	if(pos>=0 && pos<10)
		return a[pos];
//   a[9]=0;  error en un método constante
	return 0;
}

int Arr::get(int pos) {  //no es necesario sobrecargar
	if(pos>=0 && pos<10)   // si el método no modifica
		return a[pos];
	return 0;
}

int main(){
	const Arr a(5),b;
	Arr c; 
	
//	a.set(0,1);  //error llamar a un método no const
//	b.set(0,2);	 // para un objeto constante (comentar estas lineas)
	c.set(0,3);
//	a.set(1,11); //error llamar a un método no const
//	b.set(1,22); // para un objeto constante (comentar estas lineas)
	c.set(1,33);
	cout<<a.get(0)<<endl; // ejecuta int get(int) const ;
	cout<<a.get(1)<<endl; 
	cout<<b.get(0)<<endl;
	cout<<b.get(1)<<endl;
	cout<<c.get(0)<<endl; // ejecuta int get(int);
	cout<<c.get(1)<<endl;
	return 0;
}
\end{minted}
\caption{Ejemplo de objetos constantes en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%


%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
%\newpage
\section{Objetos finales en Java}

Ya se mencionó en la sección de fundamentos de Java el uso de la palabra reservada \textit{final}, la cual permite a una variable ser inicializada sólo una vez. En el caso de los objetos o referencias a los objetos el comportamiento es el mismo. Si se agrega la palabra \textit{final} a la declaración de una referencia a un objeto, significa que la  variable podrá ser inicializada una sola vez, en el momento que sea necesario.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}| final <clase> <lista de identificadores de objetos>;  |\\
\hline
\end{tabular}
\end{center}

Por ejemplo:

 \mint[linenos=false]{java}| final Hora h1= new Hora(9,30,20);  |

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
  Es importante remarcar que no es el mismo sentido de \textit{const} en C++. Aquí lo único que se limita es la posibilidad de una variable de referencia a ser inicializada de nuevo, pero no inhibe la modificación de miembros.
\\ \hline
\end{tabular}
\end{center}

Por ejemplo:

\begin{minted}{java}
final Light aLight = new Light();  // variable local final
aLight.noOfWhatts = 100;	//Ok. Cambio en el edo. del objeto

aLight = new Light();	// Inválido. No se puede modificar la referencia
\end{minted}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class Fecha {
	private int dia;
	private int mes, año;
	
	public Fecha(){
		dia=mes=1;
		año=1900;
	}
	public boolean setDia(int d){
		if (d >=1 && d<=31){
			dia= d;
			return true;
		}
		return false;
			
	}   //poner día
	public int getDia()	{
		return dia;
	} //devuelve día
	public boolean setMes(int m){
		if (m>=1 && m<=12){
			mes=m;
			return true;
		}
		return false;
	}
	public int getMes(){
		return mes;
	}

	public boolean setAño(int a) {
		if (a>=1900){
			año=a;
			return true;
		}
		return false;
	}
	public int getAño() {
		return año;
	}
}

public class MainF {

	public static void main(String[] args) {
		final Fecha f;
		
		f= new Fecha();
		
		f.setDia(10);
		f.setMes(3);
		f.setAño(2001);
		System.out.println(f.getDia()+"/"+f.getMes()+"/"+f.getAño());
		f= new Fecha(); //Error: la variable f es final y no puede ser reasignada
	}
}
\end{minted}
\caption{Ejemplo de objetos finales en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Objetos constantes en Ruby}
Los objetos constantes ya fueron indirectamente explicados al mencionar el manejo de constantes en Ruby, debido a que todos los datos son manejados como objetos. Recordemos que deben empezar con una \textbf{letra mayúscula} y pueden ser definidas dentro de una clase o módulo y serán visibles dentro de ese ámbito. Una constante definida fuera de un clase o módulo será vista globalmente. Es posible reasignar un valor a una constante, pero esto producirá una advertencia (pero no un error).

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
class Fecha
	def initialize
		@dia= @mes =1
		@anio=1900
	end
	
	def setDia dia
		if dia>=1 && dia<=31
			@dia=dia
			return true
		end
		return false
	end
	
	def setMes mes
		if mes>=1 && mes<=12
			@mes=mes
			return true
		end
		return false
	end

	def setAnio a
		if a>=1900
			@anio=a
			return true
		end
		return false
	end
	
	attr_reader :dia, :mes, :anio
end

#Código de prueba

Fe = Fecha.new  # es constante por ser nombrada con una mayúscula como prefijo

Fe.setDia 10
Fe.setMes 3
Fe.setAnio 2008

puts Fe.dia.to_s+"/"+Fe.mes.to_s+"/"+Fe.anio.to_s
# ó:
puts "#{Fe.dia}/#{Fe.mes}/#{Fe.anio}"

Fe=Fecha.new   # genera un warning pero no es un error al ser reasignado el identificador constante
\end{minted}
\caption{Ejemplo de objetos constantes en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Tenemos entonces que los objetos constantes tienen una mayor similitud con Java, siendo la diferencia principal que la modificación de un objeto constante en Ruby únicamente genera un \textit{warning}, mientras que en Java genera un error. Siendo Ruby un lenguaje interpretado es una buena solución que, al no poder ser detectado este problema en tiempo de compilación, solo genera una advertencia y continúe la ejecución.


\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%


%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Objetos constantes en Python}

Python no cuenta con objetos ni variables constantes. Se acostumbra definir variables de referencia a objetos que no se deben cambiar con mayúsculas, pero no existe ningún mecanismo que el lenguaje proporciona para evitar la modificación de los objetos.
\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala
\newpage
\section{Objetos constantes en Scala}
Scala cuenta con identificadores constantes definidos mediante \textit{val} que tienen un comportamiento similar a los definidos con \textit{final}  en Java. Del mismo modo, puede agregarse el modificador \textit{final} aunque el comportamiento es idéntico. Las diferencias básicas con el \textit{final} de Java es que un identificador \textit{val} debe ser inicializado al declararse y el identificador puede ser redefinido.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Fecha {
  var dia, mes: Int=0
  var anio: Int=1900
 	
  def setDia(mdia: Int): Boolean ={
		if (mdia>=1 && mdia<=31){
      dia=mdia
      return true
    }
		return false
  }

  def setMes(mmes: Int): Boolean ={
		if (mmes>=1 && mmes<=12){
			mes=mmes
			return true
		}
		return false
	}

  def setAnio (manio: Int): Boolean ={
		if (manio>=1900) {
			anio=manio
			return true
		}
		return false
	}
}

//Código de prueba  
object Constantes {
  val fe = new Fecha()  // similar a final en java, salvo que puede ser redefinido
  final val fe2= new Fecha()  // similar a final en java, salvo que no puede ser redefinido
   
  def main(args: Array[String]) ={
	  System.out.println("Constantes")
      var f= new Fecha()
           
      f.setDia(10)
      f.setMes(3)
      f.setAnio(2010)
	 
    //  fe2=fe  //no se puede reasignar
    //  fe=fe2  //no se puede reasignar
        
      val fe = new Fecha() // se puede redefinir fe
      val fe2 = new Fecha() // se puede redefinir fe2
      System.out.println("fin de Constantes")
  }  
}
\end{minted}
\caption{Ejemplo de objetos constantes en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%


%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp
\newpage
\section{Objetos constantes en C\#}

C\# no permite el uso de objetos constantes. Aunque existe la palabra clave \textit{const}, ésta es usada para definir un identificador para una expresión constante. Esto no permite la asignación de objetos puesto que son creados dinámicamente. De hecho:

\mint[linenos=false]{csharp}| public const int i = x; |

es un error si $x$ no es constante.

\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%


%%%%%%%%%%
% D
%%%%%%%%%%
\ifd
\newpage
\section{Objetos constantes en D}

El manejo de objetos constantes en D es básicamente como el de C++. Aparte de los ajustes en la sintaxis, la única diferencia es el uso de objetos dinámicos ya que D no maneja objetos estáticos.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Arr;

import std.stdio;

class Arr{
        private:
        int a[10];
        public:
        this(int x=0) {
                for( int i=0; i<10; i++){
                        if (x==0)
                                x=i;
                        a[i]=x;
                }
        }

char set(int pos, int val ){
        if(pos>=0 && pos<10){
                a[pos]=val;
                return 1; 
        }
        return 0;
}
 
int get(int pos) const {
       writeln("Ejecuta int get(int) const");
        if(pos>=0 && pos<10)
                return a[pos];
  //  a[9]=0;  // error en un método constante
       return 0;
}
 
int get(int pos) {  //no es necesario sobrecargar
        writeln("Ejecuta int get(int)");        
        if(pos>=0 && pos<10)   // si el método no modifica
                return a[pos];
        return 0;
}
}
int main(){
        const Arr a= new Arr(5), b=new Arr();
        Arr c; 
        
        c = new Arr();
        
//      a.set(0,1);  //error llamar a un método no const
//      b.set(0,2);      // para un objeto constante (comentar estas lineas)
        c.set(0,3);
//      a.set(1,11); //error llamar a un método no const
//      b.set(1,22); // para un objeto constante (comentar estas lineas)
        c.set(1,33);
        writeln(a.get(0)); // ejecuta int get(int) const ;
        writeln(a.get(1)); 
        writeln(b.get(0));
        writeln(b.get(1));
        writeln(c.get(0)); // ejecuta int get(int);
        writeln(c.get(1));
        return 0;
}
\end{minted}
\caption{Ejemplo de objetos constantes en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%


%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\chapter{Amistad en C++}

En C++ existe el concepto de \textbf{amistad}.  Aunque puede ser considerado por algunos como una intrusión a la encapsulación o a la privacidad de los datos: 

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
\textit{"... la amistad corrompe el ocultamiento de información y debilita el valor del enfoque de diseño orientado a objetos"}\cite{deitel2006c++}    
\\ \hline
\end{tabular}
\end{center}

Un amigo de una clase es una función u otra clase que no es miembro de la clase, pero que tiene permiso de usar los miembros públicos y privados de la clase\footnote{También tiene acceso a los miembros protegidos que se verán más adelante.}. 

Es importante señalar que el ámbito de una función amiga no es el de la clase, y por lo tanto los amigos no son llamados con los operadores de acceso de miembros.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
Sintaxis para una función amiga:
    \begin{minted} [linenos=false]{cpp}
class <nombreClase> {
	friend <tipo> <metodo>();
...
public:
	...
};
    \end{minted}
\\
Sintaxis para una clase amiga:
  \begin{minted} [linenos=false]{cpp}
class <nombreClase> {
	friend <nombreClaseAmiga>;
...
public:
	...
};
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

	Las funciones o clases amigas no son privadas ni públicas (o protegidas), pueden ser colocadas en cualquier parte de la definición de la clase, pero se acostumbra que sea al principio.[Deitel, 1995]

	Como la amistad entre personas, esta es \textbf{concedida} y no tomada. Si la clase B quiere ser amigo de la clase A, la clase A debe declarar que la clase B es su amiga.

	La amistad \textbf{no es simétrica ni transitiva}: si la clase A es un amigo de la clase B, y la clase B es un amigo de la clase C, no implica:

\begin{itemize}
\item     Que la clase B sea un amigo de la clase A.
\item     Que la clase C sea un amigo de la clase B.
\item     Que la clase A sea un amigo de la clase C.
\end{itemize}

El concepto de amistad no esta implementado en otros lenguajes aunque el nivel protegido  permite un cierto nivel de acceso miembros de clases del mismo módulo an algunos lenguajes.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//Ejemplo de funcion amiga con acceso a miembros privados
#include <iostream>

using namespace std;

class ClaseX{
	friend void setX(ClaseX &, int);  //declaración friend
	public:
	ClaseX(){
		x=0;
	}
	void print() const {
		cout<<x<<endl;
	}
	private:
	int x;
};

void setX(ClaseX &c, int val){
	c.x=val;	//es legal el acceso a miebros privados por amistad.
}

int main(){
	ClaseX pr;

	cout<<"pr.x después de instanciación : ";
	pr.print();
	cout<<"pr.x después de la llamada a la función amiga setX : ";
	setX(pr, 10);
	pr.print();
}
\end{minted}
\caption{Ejemplo de funciones amigas en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//ejemplo 2 de funciones amigas
#include <iostream>
using namespace std;

class Linea;

class Recuadro {
	friend int mismoColor(Linea, Recuadro);
	
	private:
	int color; //color del recuadro
	int xsup, ysup; //esquina superior izquierda
	int xinf, yinf; //esquina inferior derecha
	
	public:
	void ponColor(int);
	void definirRecuadro(int, int, int, int);
};

class Linea{
	friend int mismoColor(Linea, Recuadro);
	
	private:
	int color;
	int xInicial, yInicial;
	int lon;
	
	public:
	void ponColor(int);
	void definirLinea(int, int, int);
};

int mismoColor(Linea l, Recuadro r){
	if(l.color==r.color)
		return 1;
	return 0;
}

//métodos de la clase Recuadro
void Recuadro::ponColor(int c) {
	color=c;
}

void Recuadro::definirRecuadro(int x1, int y1, int x2, int y2) {
	xsup=x1;
	ysup=y1;
	xinf=x2;
	yinf=y2;
}

//métodos de la clase Linea
void Linea::ponColor(int c) {
	color=c;
}

void Linea::definirLinea(int x, int y, int l) {
	xInicial=x;
	yInicial=y;
	lon=l;
}

int main(){
	Recuadro r;
	Linea l;

	r.definirRecuadro(10, 10, 15, 15);
	r.ponColor(3);
	l.definirLinea(2, 2, 10);
	l.ponColor(4);
	if(!mismoColor(l, r))
		cout<<"No tienen el mismo color"<<endl;
	//se ponen en el mismo color
	l.ponColor(3);
	if(mismoColor(l, r))
		cout<<"Tienen el mismo color";
	return 0;
}
\end{minted}
\caption{Ejemplo 2 de funciones amigas en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%

\newpage
\chapter{Polimorfismo AdHoc: Sobrecarga de operadores}

La sobrecarga de operadores es la capacidad de definir nuevo comportamiento para operadores existentes en un lenguaje con tipos de datos definidos por el usuario. De esta forma, en programación orientada a objetos, se les da a los operadores un nuevo significado de acuerdo al objeto sobre el cual se aplique.

C++,  Ruby, Scala\footnote{\href{https://j2eethoughts.wordpress.com/2010/10/13/scala-overloading-operators/} {Scala: Overloading Operators}},  C\#\footnote{ \href{https://msdn.microsoft.com/en-us/library/aa288467(v=vs.71).aspx}{Operator Overloading Tutorial}} y  D\footnote{ \href{http://dlang.org/operatoroverloading.html}{Operator Overloading}} permiten la sobrecarga de de operadores. Java no permite la sobrecarga de operadores. Python cuenta con una aproximación a la sobrecarga de operadores.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
Para sobrecargar un operador, se define un método que es invocado cuando el operador es aplicado sobre ciertos tipos de datos.
\\ \hline
\end{tabular}
\end{center}


%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Sobrecarga de operadores en C++}

La sintaxis para definir un método con un operador difiere de la definición normal de un método, pues el nombre del método esta definido por la palabra reservada \textit{operator} y el operador que se va a sobrecargar:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
<tipo> operator <operador> (<argumentos>) ;
    \end{minted}
\\
o
\\
   \begin{minted} [linenos=false]{cpp}
<tipo> operator <operador> (<argumentos>) {
<cuerpo del método>
}
    \end{minted}
\\
Para la definición fuera de la clase:
\\
   \begin{minted} [linenos=false]{cpp}
<tipo> <clase>::operator <operador> (<argumentos>) {
<cuerpo del método>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Para utilizar un operador con objetos, es necesario que el operador este sobrecargado, aunque existen dos excepciones:

\begin{itemize}
\item  El\textbf{ operador de asignación =}, puede ser utilizado sin sobrecargarse explícitamente, pues el comportamiento por omisión es una\textbf{ copia a nivel de miembro} de los miembros de la clase. Sin embargo no debe de usarse si la clase cuenta con miembros a los que se les asigne memoria de manera dinámica.
\item  El \textbf{operador de dirección \&}, esta sobrecargado por omisión para devolver la dirección de un objeto de cualquier clase.
\end{itemize}

\textbf{Algunas restricciones: }

   \begin{enumerate}
\item  Operadores que no pueden ser sobrecargados:  $.		.*		::		?:		sizeof$
\item  La precedencia de un operador no puede ser modificada. Deben usarse los paréntesis para obligar un nuevo orden de evaluación.
\item  La asociatividad de un operador no puede ser modificada.
\item  No se puede modificar el número de operandos de un operador. Los operadores siguen siendo unarios o binarios.
\item  No es posible crear nuevos operadores.
\item  No puede modificarse el comportamiento de un operador sobre tipos de datos definidos por el lenguaje.
\end{enumerate}

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//programa de ejemplo de sobrecarga de operadores.
class Punto {
	float x, y;
public:
	Punto(float xx=0, float yy=0){
		x=xx;
		y=yy;
	}
	Punto operator =(Punto);
	Punto operator +(Punto);
	Punto operator -();
	Punto operator *(float);
	Punto operator *=(float);
	Punto operator ++();  //prefijo
	Punto operator ++(int);  //posfijo	
	bool operator >(Punto);
	bool operator <=(Punto);
};

Punto Punto::operator =(Punto a){ //copia o asignación
	x=a.x;
	y=a.y;
	return *this;
}

Punto Punto::operator +(Punto p){
	return Punto(x+p.x, y+p.y);
}

Punto Punto::operator -(){
	return Punto(-x, -y);
}

Punto Punto::operator *(float f){
	Punto temp;
	temp=Punto(x*f, y*f);
	return temp;
}

// incremento prefijo
Punto Punto::operator ++(){
	x++;
	y++;
	return *this;
}

// incremento posfijo
Punto Punto::operator++(int)
{
    Punto temp= *this;
    x++;
    y++;
    return temp;
}

bool Punto::operator >(Punto p){
	return (x>p.x && y>p.y) ? 1 : 0;
}

bool Punto::operator <=(Punto p){
	return (x<=p.x && y<=p.y) ? 1 : 0;
}

int main(){
	Punto a(1,1);
	Punto b;
	Punto c;

	b++;
	++b;
	c=b;
	c=a+b;
	c=-a;
	c=a*.5;

	return 0;
}
\end{minted}
\caption{Ejemplo de sobrecarga de operadores con C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Ejercicio} 
\end{center} 
\\ \hline
Crear una clase \textit{String} para el manejo de cadenas. Tendrá dos atributos: apuntador a carácter y un entero $tam$, para almacenar el tamaño de la cadena. Sobrecargar operadores $=$ (asignación), ($==$) igualdad, $!=, <, >, <=, >=, +, +=, [ ]$. 
Generar un programa de prueba para objetos de la clase. La estructura inicial será la siguiente:
\\
    \begin{minted} [linenos=false]{cpp}
class String{
   char *s;
   int tam;
public:
   String(char * =NULL);
   String(const String &copia);  //constructor de copia
   ~String();
//sobrecarga de operador de asignación
   const String &operator =(const String &);
   //igualdad
   bool operator ==(const String &) const ;
};
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\newpage
\textcolor{blue}{Ejemplo:} código de \textit{String}

Véase que es posible asignar una cadena "   " sin sobrecargar el operador de asignación, o comparar un objeto \textit{String} con una cadena. Esto se logra gracias a que se provee de un constructor que convierte una cadena a un objeto \textit{String}. De esta manera, este \textbf{constructor de conversión} es llamado automáticamente, creando un objeto temporal para ser comparado con el otro objeto. 

No es posible que la cadena (o apuntador a char) vaya del lado izquierdo, pues se estaría llamando a la funcionalidad del operador para un apuntador a char.  Si se requiere que el operando izquierdo sea de un tipo distinto al de la clase, la sobrecarga del operador debe hacerse usando una función externa a la clase. Si fuera necesario, esta función podría declararse como amiga de la clase.


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//Sobrecarga de operadores. Implementación de una clase String
#include <iostream>
#include <stdio.h>
#include <string.h>

using namespace std;

class String{
	//operadores de salida de flujo
	friend ostream &operator << (ostream &, const String &);
private:
	char *s;
	int tam;
public:
	String(const char * =NULL);

	String(const String &copia){
		s=NULL;
		tam=0;
		*this=copia;//¿se vale o no?
	}
	~String(){
		if(s!=NULL){
			delete []s;
			s=NULL;
			tam=0;
		}
	}

	//sobrecarga de constructor de asignación
	const String &operator =(const String &);

	//igualdad
	bool operator ==(const String &) const ;

	//concatenación
	String operator +(const String &) const;

	//concatenación y asignación
	const String &operator +=(const String &);

	String &copia (const String &);

	//sobrecarga de los corchetes
	char &operator[] (int) const;
};

//operadores de inserción y extracción de flujo
ostream& operator<< (ostream &salida, const String &cad){
	salida<<cad.s;
	return salida;  //permite concatenación
}

istream &operator >> (istream &entrada, String &cad){
	char tmp[100];
	entrada >> tmp;
	cad=tmp; //usa operador de asignación de String y const. de conversión
	return entrada;	//permite concatenación
}

String::String(const char *c){
	if(c==NULL){
		s=NULL;
		tam=0;
	} else {
		tam=strlen(c);
		s= new char[tam+1];
		strcpy(s, c);
	}
}

const String &String::operator =(const String &c){
	if(this!= &c) {      //verifica no asignarse a si mismo
		if(s!=NULL)
			delete []s;
		tam=c.tam;
		s= new char[tam+1];
		strcpy(s, c.s);
	}
	return *this; //permite concatenación de asignaciones
}

bool String::operator ==(const String &c)const {
		return strcmp(s, c.s)==0;
}

//operador de suma regresa una copia de la suma obtenida
//en un objeto local.
String String::operator +(const String &c) const {
	String tmp(*this);
	tmp+=c;
	return tmp;
}

const String &String::operator +=(const String &c){
	char *str=s, *ctmp= new char [c.tam+1];
	strcpy(ctmp, c.s);
	tam+=c.tam;
	s= new char[tam+1];
	strcpy(s, str);
	strcat(s, ctmp);
	delete []str;
	delete []ctmp;
	return *this;
}

String &String::copia (const String &c) {
	if(this!= &c) {      //verifica no asignarse a si mismo
		if(s!=NULL)
			delete []s;
		tam=c.tam;
		s= new char[tam+1];
		strcpy(s, c.s);
	}
	return *this; //permite concatenación de asignaciones
}

char &String::operator[] (int i) const {
	if(i>=0 && i<tam)
		return s[i];
	return s[0];
}

int main(){
	String a("AAA");
	String b("Prueba de cadena");
	String c(b);
    // Es un error hacer una asignación sin liberar memoria.
    // ese es el principal peligro de usar el operador sobrecargado 
    // por default de asignación
	a=b;
	b.copia("H o l a");
	b=c+c;
	b="nueva";
	c+=c;
	String d("nueva cadena");
	d+="Hola";
	String e;
	e=d+"Adios";
	d="coche";
	int x=0;
	x=d=="coche"; //Lo contrario no es válido "coche"==d
	char ch;
	ch=d[7];
	d[2]='X';
	cout<<d<<endl;
	cout<<"Introduce dos cadenas:";
	cin>>e>>d;
	cout<<"Cadenas:\n";
	cout<<e<<endl<<d;
	return 0;
}
\end{minted}
\caption{Ejemplo de String con sobrecarga de operadores en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Sobrecarga de operadores en Ruby}
Aunque Ruby no maneja sobrecarga de operaciones si soporta la sobrecarga de operadores. Para hacerlo simplemente se define un método en la clase, donde el nombre del método es el nombre del operador que se necesita sobrecargar.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
def  <operador>
	...
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Operadores que no pueden ser sobrecargados:

\mint[linenos=false]{cpp}| =, !, not, &&, and, ||, or, ., !=, .., ..., :: and some others ¿- ?. |

La instrucción \textit{return} puede omitirse en Ruby porque regresa el resultado de la ultima expresión de una función.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
#programa de ejemplo de sobrecarga de operadores.
class Punto  
  attr_reader :x, :y
  @x
  @y
  def initialize x=10, y=10
    @x, @y=x,y
  end
  
  def + op
    return Punto.new(@x+op.x, @y+op.y)
  end

  def - (op)
    Punto.new(@x-op.x, @y-op.y)
  end
  
  def * (f)
    temp=Punto.new @x*f, @y*f
    return temp
  end 

  def > (op)
    return (@x>op.x && @y>op.y) ? true : false
  end
  
  def <= (op)
    return (@x<=op.x && @y<=op.y) ? true : false
  end  
end

def prueba
  a= Punto.new 1,1
  b= Punto.new
  c= Punto.new
  puts a.x
  puts b.x
  puts c.x
  
  c=a+b
  puts c.x
  puts c.y
  c+=a
  puts c.x
  puts c.y  
  c=a*0.5
  puts c.x
  puts c.y
  p=a-b
  puts p.x
  puts p.y

  puts a>b
  puts a<=b
end

prueba
\end{minted}
\caption{Ejemplo de sobrecarga en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Al ser un lenguaje dinámico, el segundo operando queda determinado en tiempo de ejecución. Además al sobrecargar, por ejemplo, el operador $+$ automáticamente queda sobrecargado el operador $+=$ (lo mismo para el resto de las asignaciones abreviadas).

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%



%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Sobrecarga de operadores en Python}

Python permite la sobrecarga de operadores mediante la definición de métodos especiales\footnote{Ver más sobre métodos especiales en: {\href{https://docs.python.org/3/reference/datamodel.html#special-method-names}{Python reference}}. Dichos métodos inician y terminan con doble '\_'. Por ejemplo, si se quiere sobrecargar la igualdad ($==$) se tiene que crear una definición del método $\_\_eq\_\_$.

\textcolor{blue}{Ejemplo:}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#programa de ejemplo de sobrecarga de operadores.
class Punto:  
  
  def __init__(self,x=10, y=10 ):
    self.x=x
    self.y=y
  
  def __add__(self, op):
    return Punto(self.x+op.x, self.y+op.y)
  
  def __sub__(self, op):
    return Punto(self.x-op.x, self.y-op.y)
  
  def __mul__(self, f):
    temp=Punto(self.x*f, self.y*f)
    return temp
 
  def __gt__(self, op):  # >
    return (self.x>op.x and self.y>op.y)

  def __le__ (self, op): # <=
    return (self.x<=op.x and self.y<=op.y)

# principal
a= Punto(1,1)
b= Punto()
c= Punto()
print( a.x)
print(b.x)
print(c.x)
  
c=a+b
print(c.x)
print(c.y)
c+=a
print(c.x)
print(c.y)  
 
p=a-b
print(p.x)
print(p.y)
 
c=a*0.5
print(c.x)
print(c.y)
  
print( a>b)
print( a<=b)
\end{minted}
\caption{Ejemplo de sobrecarga de operadores en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Una lista de las funciones para la sobrecarga de operadores se muestra a continuación\footnote{Fuente: Pointal, Lauren; Python 2.4 Quick Reference Card, 2006.}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
__add__(self,other) → value: self + other 
__sub__(self,other) → value: self- ­ other 
__mul__(self,other) → value: self * other 
__div__(self,other)→value: self/other 
__mod__(self,other) → value: self % other  
__pow__(self,other) → value: self ** other  
__neg__(self) → value:- ­self 
__pos__(self) → value: +self
__abs__(self) → value: abs(self) 
__iadd__(self,other) ➤ self += other 
__isub__(self,other) ➤ self- ­= other 
__imul__(self,other) ➤ self *= other 
__idiv__(self,other)➤ self/=other  
__imod__(self,other) ➤ self %= other 
__ipow__(self,other) ➤ self **= other 
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Es importante mencionar que, aunque no hay un método especial para la asignación, hay métodos especiales para los operadores de asignación compuesta como $+=, -=, *=, /=$, etc. Estos son \_\_iadd\_\_, \_\_isub\_\_, \_\_imul\_\_, \_\_idiv\_\_, entre otros.



\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala
\newpage
\section{Sobrecarga de operadores en Scala}

La sobrecarga de operadores en Scala es permitida debido a que en realidad los operadores son métodos. La diferencia es la forma en que se usan los operadores con respecto a los métodos. De hecho, una expresión del tipo:

$10+2$

en realidad es la ejecución del método $+$ definido para $Int$:

$(10).+(2)$

De hecho en Scala podemos usar cada método en el estilo de un operador. Se podría decir que no es que Scala tenga sobrecarga de operadores sino sobrecarga de métodos y los operadores son métodos. El operador de asignación $=$ recibe un tratamiento especial por parte del compilador de Scala y no puede ser sobrecargado.

Existen algunas restricciones para la sobrecarga de operadores prefijos. Los operadores prefijos en Scala son unarios. Los únicos operadores que pueden ser usados de forma unaria son $+, -, !$  y  \textasciitilde . Para sobrecargar uno de estos operadores el método debe llevar como prefijo del operador el nombre de $unary\_$.  Por ejemplo, una sobrecarga del operador unario $+$ se llamaría $unary\_+$.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Punto(var x:Int, var y:Int) {
    def Punto (x:Int, y:Int){
       this.x= x
       this.y= y
    }

    def + (p: Punto): Punto = {
        new Punto(x+p.x, y+p.y)
    }       

    def > (p: Punto): Boolean = {
     if (x>p.x && y>p.y)  true else false
    }

    //sobrecarga de operador prefijo unario
    def unary_-(): Punto ={
        new Punto(-x, -y)
    }
}

object Main{
  def main(args: Array[String]) ={
    System.out.println("Sobrecarga de operadores")
    var a: Punto = new Punto(1,1)
    var b,c= new Punto(0, 0)

    println(a.x)
    println(b.x)
    b=a
    println(b.x)
    println(a>c)
    c= -b  // espacio o paréntesis necesarios para evitar ambigüedad con operador de asignación  
    println(c.x)
  }  
}
\end{minted}
\caption{Ejemplo de sobrecarga de operadores en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%


%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp
\newpage
\section{Sobrecarga de operadores en C\#}

Como ya se sabe, la sobrecarga de operadores esta relacionada con la sobrecarga de métodos. Al igual que en C++, la sobrecarga de operadores en C\# depende de la palabra reservada \textit{operator} y el método debe ser público y estático.

Existen dos formas de métodos de sobrecarga de operadores: para operadores unarios y para operadores binarios\footnote{ \href{https://msdn.microsoft.com/en-us/library/aa691324(v=vs.71).aspx}{Operator overloading} }. 

En el caso de los operadores unarios, el tipo del operando deberá ser del mismo tipo de la clase para la cual el operador esta siendo definido. Para operadores binarios, al menos uno de los dos operandos debe ser del mismo tipo de la clase. Esto limita la sobrecarga de operadores para objetos que no hemos creado. (no se puede sobrecargar $+$ para \textit{int}, por ejemplo). Los parámetros tampoco deben usar los modificadores \textit{ref}  o \textit{out}. La sintaxis general se muestra a continuación.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\
Forma general para operadores unarios:
\\ \hline
    \begin{minted} [linenos=false]{csharp}
public static <tipo-retorno> operator <operador> 
 ( <tipo> <nombre operando>) {
    <instrucciones>
}
    \end{minted}
\\
Forma general para operadores binarios:
\\
\begin{minted}[linenos=false]{csharp}
public static <tipo-retorno> operator <operador> 
 ( <tipo> <nombre operando1>, <tipo> <nombre operando2>)  {
    <instrucciones>
}
\end{minted}
\\ \hline
\end{tabular}
\end{center}

Las sobrecarga unaria de $–$ y $++$ es posible pero no se distingue entre la forma prefija y postfija\cite{schildt2010c}.

Si se sobrecargan operadores como $<$, su operador complementario $>$ también debe ser sobrecargado.

Los siguientes operadores no pueden ser sobrecargados: $=, ., ?:, ->, new, is, sizeof, typeof$ \footnote{Overloadable Operators, \url{https://msdn.microsoft.com/en-us/library/8edha89s(v=vs.71).aspx} }.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
//programa de ejemplo de sobrecarga de operadores.

using System;

class Punto {
	float x, y;
	public Punto(float xx=0, float yy=0){
		x=xx;
		y=yy;
	}

	public static Punto operator +(Punto a, Punto b){
		return new Punto(a.x+b.x, a.y+b.y);
	}

	public static Punto operator -(Punto a){
		return new Punto(-a.x, -a.y);
	}

	public static Punto operator *(Punto a, float f){
		Punto temp;
		temp=new Punto(a.x*f, a.y*f);
		return temp;
	}

	// incremento prefijo
	public static Punto operator ++(Punto a){
		a.x++;
		a.y++;
		return a;
	}

	public static bool operator >(Punto a, Punto b){
		return (a.x>b.x && a.y>b.y) ? true : false;
	}
	
	public static bool operator <(Punto a, Punto b){
		return (a.x<b.x && a.y<b.y) ? true : false;
	}

/*  Requerirá sobrecargar su operador complementario >=
	public static bool operator <=(Punto a, Punto b){
		return (a.x<=b.x && a.y<=b.y) ? true : false;
	}
*/

	public static void Main(){
		Punto a= new Punto(1,1);
		Punto b= new Punto();
		Punto c= new Punto();

		b++;
		++b;
		c=b;
		c=a+b;
		c=-a;
		c=a*.5f;
	}
}

\end{minted}
\caption{Ejemplo de sobrecarga de operadortes en C\#.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%



%%%%%%%%%%
% D
%%%%%%%%%%
\ifd
\newpage
\section{Sobrecarga de operadores en D\protect\footnote{ \href{ http://dlang.org/operatoroverloading.html} {Operator overloading}}  }

El uso de sobrecarga en D involucra conceptos diversos tales como plantillas y auto referencia, entre otros. El uso de funciones de plantilla para sobrecargar operadores hace que requiera de una sintaxis particular\footnote{\c{C}ehreli, Ali; \textit{Programming in D}, First edition; pp. 291-313; 2015}.


La definición de plantillas contiene dos partes:
  
\begin{enumerate}
\item El encabezado o nombre de una función de plantilla para cada operador que se quiera sobrecargar y que se mostrará más adelante.
\item Una restricción de plantilla ($if op==”+”$, por ejemplo) para identificar el carácter del operador en la cadena. 
\end{enumerate}

Los operadores postfijos de incremento y decremento ($x++$ y $x--$) no pueden ser sobrecargados directamente aunque son reescritos bajos los términos de la sobrecarga prefija.

Ejemplo de sobrecarga unaria:

\begin{minted}{d}
struct S {
    int m;

    int opUnary(string s)() if (s == "-"){
        return -m;
    }
}

int foo(S s){
    return -s;
}
\end{minted}

La sobrecarga de operadores binarios requiere el uso de la función \textit{opBinary} y en algunos casos \textit{opBinaryRight}. \textit{OpBinaryRight} se ocupa cuando el objeto que ejecuta al método puede aparecer en el lado derecho del operador, aunque su uso es poco común. Para sobrecargar el operador de igualdad y desigualdad se usa la función \textit{opEquals} (una expresión con el operador $!=$ es reescrita como $!(a==b)$ por lo que solo se sobrecarga el operador de igualdad. Mientras que para sobrecargar un operador relacional se usa \textit{opCmp}. Existen funciones para otros operadores.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
//programa de ejemplo de sobrecarga de operadores.

// test.d
module Punto;

import std.stdio;

class Punto {
	float x, y;
	
	public:
	this(float xx=0, float yy=0){
		x=xx;
		y=yy;
	}

	Punto opBinary(string op) (Punto a) if (op=="+") {
	    // if (op=="+")
    	return new Punto(x+a.x, y+a.y);
	}

	Punto opUnary(string op) () if (op=="-"){
		return new Punto(-x, -y);
	}

	Punto opBinary(string op)(float f) if (op=="*") {
		Punto temp;
		temp=new Punto(x*f, y*f);
		return temp;
	}

	// incremento prefijo
	Punto opUnary(string op) () if (op=="++"){
		x++;
		y++;
		return this;
	}

	bool opEquals(Punto b) (Punto a, Punto b) if (op=="=="){  
		return (x>b.x && y>b.y) ? true : false;
	}


	bool opCmp(string op) (Punto a, Punto b) if (op==">"){
		return (a.x>b.x && a.y>b.y) ? true : false;
	}
	
	bool opCmp(string op) (Punto b) if (op=="<"){
		return (x<b.x && y<b.y) ? true : false;
	}
}

void	 main(){
	Punto a= new Punto(1,1);
	Punto b= new Punto();
	Punto c= new Punto();

	b++;
	writeln("b.x:", b.x, " b.y:",b.y);
	++b;
	writeln("b.x:", b.x, " b.y:",b.y);
	c=b;
	writeln("c.x:", c.x, " c.y:",c.y);
	c=a+b;
	writeln("c.x:", c.x, " c.y:",c.y);
	c=-a;
	writeln("c.x:", c.x, " c.y:",c.y);
	c=a*.5f;
	writeln("c.x:", c.x, " c.y:",c.y);
}
\end{minted}
\caption{Ejemplo de sobrecarga de operadores en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Ejercicio} 
\end{center} 
\\ \hline
Crear un programa con una clase \textit{Pila} y los métodos correspondientes (\textit{push, pop, getTope, getElemTope, estaVacia, estaLlena, ...}) ocupando los temas OO antes vistos de acuerdo a lo que cada lenguaje permita (constructores, miembros estáticos, sobrecarga de operaciones, sobrecarga de operadores, funciones amigas)
\\ \hline
\end{tabular}
\end{center}

\chapter{Herencia}
\section{Introducción}

La \textbf{herencia} es un mecanismo potente de abstracción que permite compartir similitudes entre clases manteniendo al mismo tiempo sus diferencias.

	Es una forma de reutilización de código, tomando clases previamente creadas y formando a partir de ellas nuevas clases, heredándoles sus atributos y métodos. Las nuevas clases pueden ser modificadas agregándoles nuevas características.

	Los términos para distinguir los tipos de clases pueden variar. Por ejemplo, en C++ la clase de la cual se toman sus características se conoce como \textbf{clase base}; mientras que la clase que ha sido creada a partir de la clase base se conoce como \textbf{clase derivada}. Existen otros términos para estas clases:

\begin{table}[]
\centering
\begin{tabular}{lllll}
\cline{1-2}
\multicolumn{1}{|l|}{Clase base}  & \multicolumn{1}{l|}{Clase derivada} &  &  &  \\ \cline{1-2}
\multicolumn{1}{|l|}{Superclase}  & \multicolumn{1}{l|}{Subclase}       &  &  &  \\ \cline{1-2}
\multicolumn{1}{|l|}{Clase padre} & \multicolumn{1}{l|}{Clase hija}     &  &  &  \\ \cline{1-2}
                                  &                                     &  &  & 
\end{tabular}
\end{table}

En Java es más común usar el término de superclase y subclase.
 
Una clase derivada es potencialmente una clase base, en caso de ser necesario.

	Cada objeto de una clase derivada también es un objeto de la clase base. En cambio, un objeto de la clase base no es un objeto de la clase derivada.

	La implementación de herencia a varios niveles forma un árbol jerárquico similar al de un árbol genealógico.  Esta es conocida como \textbf{jerarquía de herencia}.

	\textbf{Generalización}. Una clase base o superclase se dice que es más general que la clase derivada o subclase.

	\textbf{Especialización}. Una clase derivada es por naturaleza una clase más especializada que su clase base.


%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Herencia: Implementación en C++}
	La herencia en C++ es implementada permitiendo a una clase incorporar a otra clase dentro de su declaración. 

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
class <claseDerivada>: <acceso>  <claseBase> {
	//cuerpo clase derivada
};
    \end{minted}
\\ \hline
\end{tabular}
\end{center}	

\textcolor{blue}{Ejemplo:}
   \textit{ Una clase vehículo que describe a todos aquellos objetos vehículos que viajan en carreteras. Puede describirse a partir del número de ruedas y de pasajeros.
	De la definición de vehículos podemos definir objetos más específicos (especializados). Por ejemplo la clase camión. }

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
#include <iostream>
using namespace std;

class Vehiculo{
	int ruedas;
	int pasajeros;
public:
	void setRuedas(int);
	int  getRuedas();
	void setPasajeros(int);
	int  getPasajeros();
};

void Vehiculo::setRuedas(int num){
	ruedas=num;
}
int Vehiculo::getRuedas(){
	return ruedas;
}
void Vehiculo::setPasajeros(int num){
	pasajeros=num;
}

int Vehiculo::getPasajeros(){
	return pasajeros;
}

//clase Camion con herencia  de Vehículo
class Camion: public Vehiculo {
	int carga;
	public:
	void setCarga(int);
	int getCarga();
	void muestra();
};

void Camion::setCarga(int num){
	carga=num;
}
int Camion::getCarga(){
	return carga;
}
void Camion::muestra(){
	cout<<"Ruedas: "<< getRuedas()<<endl;
	cout<<"Pasajeros: "<< getPasajeros()<<endl;
	cout<<"Capacidad de carga: "<<getCarga()<<endl;
}

int main(){
	Camion ford;
	ford.setRuedas(6);
	ford.setPasajeros(3);
	ford.setCarga(3200);
	ford.muestra();
	return 0;
}
\end{minted}
\caption{Ejemplo de herencia en C++, jerarquía de Vehículo.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Control de Acceso a miembros en C++}

	Existen tres palabras reservadas para el control de acceso: \textit{public}, \textit{private} y \textit{protected}. Estas sirven para proteger los miembros de la clase en diferentes formas. 

El control de acceso, como ya se vio anteriormente, se aplica a los métodos, atributos, constantes y tipos anidados que son miembros de la clase.

Resumen de tipos de acceso:

\begin{itemize}
\item \textbf{private}. Un miembro privado únicamente puede ser utilizado por los métodos miembro y funciones amigas de la clase donde fue declarado.                                                                               
\item \textbf{protected}. Un miembro protegido puede ser utilizado únicamente por los métodos miembro y funciones amigas de la clase donde fue declarado o por los métodos miembro y funciones amigas de las clases derivadas. El acceso protegido es como un nivel intermedio entre el acceso privado y público.
\item \textbf{public}. Un miembro público puede ser utilizado por cualquier método. Una estructura es considerada por C++ como una clase que tiene todos sus miembros públicos.        
\end{itemize}
                                                                                                               


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//ejemplo de control de acceso

class S{
	char *f1();
	int a;
 	protected:
	int b;
	int f2();
 	private:
	int c;
	int f3();
	public:
	int d, f;
	char *f4(int);
};

int main(){
	S obj;
	obj.f1(); //error
	obj.a=1;	//error
	obj.f2();//error
	obj.b=2; //error
	obj.c=3; //error
	obj.f3(); //error
	obj.d=5;
	obj.f4(obj.f);
	return 0;
}
\end{minted}
\caption{Ejemplo de herencia y control de acceso a miembros en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Control de acceso en herencia en C++}

Hasta ahora se ha usado la herencia con un solo tipo de acceso, utilizando el especificador \textit{public}. Los miembros públicos de la clase base son miembros públicos de la clase derivada, los miembros protegidos permanecen protegidos para la clase derivada.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//ejemplo de control de acceso en herencia

class Base{
	int a;
	protected:
	int b;
 	public:
	int c;
};

class Derivada: public Base {
	void g();
};

void Derivada::g(){
	a=0; //error, es privado
	b=1; //correcto, es protegido
	c=2; //correcto, es público
}
\end{minted}
\caption{Ejemplo control de acceso en herencia en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Para accesar a los miembros de una clase base desde una clase derivada, se pueden ajustar los permisos por medio de un calificador \textit{public}, \textit{private} o \textit{protected}.

	Si una clase base es declarada como \textbf{pública} de una clase derivada, los miembros públicos y protegidos son accesibles desde la clase derivada, no así los miembros privados.

	Si una clase base es declarada como \textbf{privada} de otra clase derivada, los miembros públicos y protegidos de la clase base serán miembros privados de la clase derivada. Los miembros privados de la clase base permanecen inaccesibles.

	Si se omite el calificador de acceso de una clase base, se asume \textbf{por omisión} que el calificador es \textit{public} en el caso de una estructura y \textit{private} en el caso de una clase.

	Ejemplo de sintaxis:

\begin{minted}{cpp}
class base {
 ...
};

class d1: private base {
...
};

class d2: base {
...
};

class d3: public base {
...
};
\end{minted}

Es recomendable declarar explícitamente la palabra reservada \textit{private} al tomar una clase base como privada para evitar confusiones:

\begin{minted}{cpp}
class x{
 	public:
    f();
};

class y: x {   //privado por omisión
	...
};	

void g( y *p){
	p->f();  //error
}
\end{minted}

	Finalmente, si una clase base es declarada como \textbf{protegida} de una clase derivada, los miembros públicos de la clase base se convierten en miembros protegidos de la clase derivada.

\textcolor{blue}{Ejemplo:}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//acceso por herencia
#include <iostream>
using namespace std;

class X{
	protected:
	int i;
	int j;
	
	public:
	void preg_ij();
	void pon_ij();
};

void X::preg_ij() {
	cout<< "Escriba dos números: ";
	cin>>i>>j;
}

void X::pon_ij() {
	cout<<i<<' '<<j<<endl;
}

//en Y, i y j de X siguen siendo miembros protegidos
//Si se llegara a cambiar este acceso a private i y j se heredarian como
// miembros privados de Y, además de los métodos públicos
class Y: public X{
	int k;
public:
	int preg_k();
	void hacer_k();
};

int Y:: preg_k(){
	return k;
}

void Y::hacer_k() {
	k=i*j;
}

// Z tiene acceso a i y j de X, pero no a k de Y
// porque es private por omisión
// Si Y heredara de x como private, i y j serían privados en Y,
// por lo que no podrían ser accesados desde Z
class Z: public Y {
public:
	void f();
};

// Si Y heredara a X con private, este método ya no funcionaría
// no se podría acceder a i ni a j.
void Z::f() {
	i=2;
	j=3;
}

// si Y hereda de x como private, no es posible accesar a los métodos
//públicos desde objetos de Y ni de Z.
int main() {
	Y var;
	Z var2;

	var.preg_ij();
	var.pon_ij();
	var.hacer_k();
	cout<<var.preg_k()<<endl;
	var2.f();
	var2.pon_ij();
	return 0;
}
\end{minted}
\caption{Ejemplo control de acceso en herencia con C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Constructores de clase base en C++}

El constructor de la clase base puede ser llamado desde la clase derivada, para inicializar los atributos heredados. La sintaxis es igual que el inicializador de objetos componentes.

	Los constructores y operadores de asignación de la clase base no son heredados por las clases derivadas. Pero pueden ser llamados por los de la clase derivada.

	Un constructor de la clase derivada llama primero al constructor de la clase base. Si se omite el constructor de la clase derivada, el constructor por omisión de la clase derivada llamará al constructor de la clase base.

	Los destructores son llamados en orden inverso a las llamadas del constructor: un destructor de una clase derivada será llamado antes que el de su clase base.
	
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
<clase>::<constructor>(<lista de argumentos>) : 
  <contructor de clase base>(<lista de argumentos sin el tipo>)
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// POINT.H
#ifndef POINT_H
#define POINT_H

class Point {
public:
   Point(float = 0.0, float = 0.0);
   ~Point();    
protected:      
   float x, y;  
};

#endif /*POINT_H_*/

// POINT.CPP
#include <iostream>
#include "point.h"
using namespace std;
Point::Point(float a, float b){
   x = a;
   y = b;

   cout << "Constructor Point: "
	<< '[' << x << ", " << y << ']' << endl;
}

Point::~Point(){
   cout << "Destructor Point:  "
        << '[' << x << ", " << y << ']' << endl;
}

// CIRCLE.H
#ifndef CIRCLE_H
#define CIRCLE_H

#include "point.h"

class Circle : public Point {
public:
   Circle(float r = 0.0, float x = 0, float y = 0);
   ~Circle();      
private:
   float radius;   
};

#endif /*CIRCLE_H_*/

// CIRCLE.CPP
#include "circle.h"

using namespace std;

Circle::Circle(float r, float a, float b)
   : Point(a, b)   // llamada al constructor de clase base
{
   radius = r;

   cout << "Constructor Circle: radio es "
        << radius << " [" << a << ", " << b << ']' << endl;
}

Circle::~Circle(){
   cout << "Destructor Circle:   radio es "
        << radius << " [" << x << ", " << y << ']' << endl;
}

// Main.CPP
#include <iostream.h>
#include "point.h"
#include "circle.h"

int main(){
   // Muestra llamada a constructor y destructor de Point
   {
      Point p(1.1, 2.2);
   }

   cout << endl;
   Circle circle1(4.5, 7.2, 2.9);
   cout << endl;
   Circle circle2(10, 5, 5);
   cout << endl;
   return 0;
}
\end{minted}
\caption{Ejemplo constructor de clase base en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\subsection{Manejo de objetos de la clase base como objetos de una clase derivada y viceversa en C++}

	Un objeto de una clase derivada pública, puede ser manejado como un objeto de su clase base. Sin embargo, un objeto de la clase base no es posible tratarlo de forma automática como un objeto de clase derivada.

	La opción que se puede utilizar, es enmascarar un objeto de una clase base a un apuntador de clase derivada. El problema es que no debe ser desreferenciado (accedido) así, primero se tiene que hacer que el objeto sea referenciado por un apuntador de su propia clase.

	Si se realiza la conversión explícita de un apuntador de clase base - que apunta a un objeto de clase base - a un apuntador de clase derivada y, posteriormente, se hace referencia a miembros de la clase derivada, es un error pues esos miembros no existen en el objeto de la clase base.
	


\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// POINT.H
// clase Point
#ifndef POINT_H_
#define POINT_H_
using namespace std;

class Point {
   friend ostream &operator<<(ostream &, const Point &);
	public:
   Point(float = 0, float = 0);      
   void setPoint(float, float);      
   float getX() const { return x; }  
   float getY() const { return y; }  
	protected:         
   float x, y;     
};

#endif /*POINT_H_*/


// POINT.CPP
#include <iostream>
#include "point.h"

Point::Point(float a, float b){
   x = a;
   y = b;
}

void Point::setPoint(float a, float b){
   x = a;
   y = b;
}

ostream &operator<<(ostream &output, const Point &p){
   output << '[' << p.x << ", " << p.y << ']';

   return output;   
}


// CIRCLE.H
// clase Circle
#ifndef CIRCLE_H
#define CIRCLE_H

#include <iostream>
#include <iomanip>
#include "point.h"

class Circle : public Point {  // Circle hereda de Point
   	friend ostream &operator<<(ostream &, const Circle &);
	public:
   	Circle(float r = 0.0, float x = 0, float y = 0);

   	void setRadius(float);      
   	float getRadius() const;    
   	float area() const;         
	protected:
   	float radius;
};
#endif /*CIRCLE_H_*/


// CIRCLE.CPP
#include "circle.h"

Circle::Circle(float r, float a, float b)
   : Point(a, b)   // llama al constructor de la clase base
{ radius = r; }

void Circle::setRadius(float r) { radius = r; }

float Circle::getRadius() const { return radius; }

float Circle::area() const
{ return 3.14159 * radius * radius; }

// salida en el formato:
// Center = [x, y]; Radius = #.##
ostream &operator<<(ostream &output, const Circle &c){
   output << "Center = [" << c.x << ", " << c.y
          << "]; Radius = " << setprecision(2) << c.radius;

   return output;
}

//Prueba.cpp 
// Probando apuntadores a clase base a apuntadores a clase derivada
#include <iostream>
#include <iomanip.h>
#include "point.h"
#include "circle.h"

int main(){
	Point *pointPtr, p(3.5, 5.3);
	Circle *circlePtr, c(2.7, 1.2, 8.9);
 
	cout << "Point p: " << p << "\nCircle c: " << c << endl;

	// Maneja a un Circle como un Circle
	pointPtr = &c;   // asigna la direccion de Circle a pointPtr
	circlePtr = (Circle *) pointPtr;  // mascara de base a derivada
	cout << "\nArea de c (via circlePtr): "
	<< circlePtr->area() << endl;

	// Es riesgoso manejar un Point como un Circle
	// getRadius() regresa basura
	pointPtr = &p;   // asigna direccion de Point a pointPtr
	circlePtr = (Circle *) pointPtr;  // mascara de base a derivada
	cout << "\nRadio de objeto apuntado por circlePtr: "
	<< circlePtr->getRadius() << endl;

	return 0;
}
\end{minted}
\caption{Ejemplo de objetos de clase derivada como clase base en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


%%%%%%%%%%
% ADVANCED
%%%%%%%%%%
\ifadvanced

\subsubsection{El operador $dynamic\_cast$}
  
El operador \textit{dynamic\_cast} es una forma de realizar una conversión de punteros o referencias de una clase base a una clase derivada en tiempo de ejecución. Este operador se utiliza para comprobar si un objeto de una clase base es realmente un objeto de una clase derivada específica
\footnote{La contraparte es el operador \textit{static\_cast} es otra forma de realizar una conversión de apuntadores o referencias en C++. A diferencia del \textit{dynamic\_cas}t, el \textit{static\_cast} realiza la conversión de forma estática en tiempo de compilación, es decir, no verifica si la conversión es válida.}.

La sintaxis para utilizar el operador \textit{dynamic\_cast} es:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}| dynamic_cast<tipo_derivado>(puntero_o_referencia_base)
  |\\
\hline
\end{tabular}
\end{center}

Supongamos que tenemos una clase base \textit{Empleado} y dos clases derivadas \textit{EmpleadoPorHora} y \textit{EmpleadoFijo}.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
#include <iostream>

using namespace std;

class Empleado {
public:
    virtual double salario() = 0;
};

class EmpleadoPorHora : public Empleado {
    private:
        double horasTrabajadas;
        double tarifaPorHora;
    public:
        // constructor con inicialización directa de miembros previa a
        // la ejecución del constructor
        EmpleadoPorHora(double horasTrabajadas, double tarifaPorHora) 
          : horasTrabajadas(horasTrabajadas), tarifaPorHora(tarifaPorHora) {}
        double salario() {
            return horasTrabajadas * tarifaPorHora;
        }
};

class EmpleadoFijo : public Empleado {
    private:
        double salarioMensual;
    public:
        EmpleadoFijo(double salarioMensual) : salarioMensual(salarioMensual) {}
        double salario() {
            return salarioMensual;
        }
};


int main() {
    Empleado* empleados[2];
    empleados[0] = new EmpleadoPorHora(40, 15);
    empleados[1] = new EmpleadoFijo(2000);
    for (int i = 0; i < 2; i++) {
        EmpleadoPorHora* empleadoPH = dynamic_cast<EmpleadoPorHora*>(empleados[i]);
        if (empleadoPH) {
            cout << "Empleado por Hora: "<< empleadoPH->salario()<< endl;
        }
        EmpleadoFijo* empleadoF = dynamic_cast<EmpleadoFijo*>(empleados[i]);
        if (empleadoF) {
            cout << "Empleado Fijo: "<< empleadoF->salario()<< endl;
        }
    }
    return 0;
}

\end{minted}
\caption{Ejemplo usando \textit{dynamic\_cast}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En el ejemplo anterior se crea un arreglo de apuntadores a \textit{Empleado} y se asignan las instancias de las clases derivadas \textit{EmpleadoPorHora} y \textit{EmpleadoFijo}. Luego, en el ciclo \textit{for} se recorre el arreglo y se utiliza el operador \textit{dynamic\_cast} para verificar si el puntero es una instancia de \textit{EmpleadoPorHora} o \textit{EmpleadoFijo}, y de esta manera acceder a sus métodos específicos. El \textit{dynamic\_cast} retorna un apuntador al tipo especificado si la conversión es válida, o nulo si no es así.

\fi
%%%%%%%%%%
% ADVANCED
%%%%%%%%%%

\subsection{Redefinición de métodos en C++}

	Algunas veces, los métodos heredados no cumplen completamente la función que quisiéramos que realicen en las clases derivadas. Es posible en C++  \textbf{redefinir} un método de la clase base en la clase derivada. Cuando se hace referencia al nombre del método, se ejecuta la versión de la clase en donde fue redefinida. 

Es posible sin embargo, utilizar el método original de la clase base por medio del operador de resolución de alcance.

	Se sugiere redefinir métodos que no vayan a ser empleados en la clase derivada, inclusive sin código para inhibir cualquier acción que no nos interese\footnote{n teoría esto no debería ser necesario anular operaciones si nos apegamos a la regla del 100\% (\textbf{de conformidad con la definición})}.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
La redefinición de métodos \textbf{no} es una sobrecarga porque se definen exactamente con la misma firma.  
\\ \hline
\end{tabular}
\end{center}
	
\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// EMPLOY.H
#ifndef EMPLOY_H
#define EMPLOY_H

using namespace std; 

class Employee {
	public:
   	Employee(const char*, const char*);  
   	void print() const;  
   	~Employee();         
	private:
   	char *firstName;     
   	char *lastName;      
};
#endif /*EMPLOY_H_*/

// EMPLOY.CPP
#include <string.h>
#include <iostream>
#include <assert.h>
#include "employ.h"

Employee::Employee(const char *first, const char *last){
   firstName = new char[ strlen(first) + 1 ];
   assert(firstName != 0);     strcpy(firstName, first);

   lastName = new char[ strlen(last) + 1 ];
   assert(lastName != 0); 
   strcpy(lastName, last);
}

void Employee::print() const
{ cout << firstName << ' ' << lastName; }

Employee::~Employee(){
   delete [] firstName;   
   delete [] lastName;    
}

// HOURLY.H
#ifndef HOURLY_H
#define HOURLY_H

#include "employ.h"

class HourlyWorker : public Employee {
	public:
   	HourlyWorker(const char*, const char*, float, float);
   	float getPay() const;  
 	void print() const;    
	private:
   	float wage;            
   	float hours;           
};

#endif /*HOURLY_H_*/

// HOURLY_B.CPP
#include <iostream>
#include <iomanip.h>
#include "hourly.h"

HourlyWorker::HourlyWorker(const char *first, const char *last, float initHours, 
 float initWage) : Employee(first, last) {
   hours = initHours;
   wage = initWage;
}

float HourlyWorker::getPay() const { return wage * hours; }

void HourlyWorker::print() const {
   cout << "HourlyWorker::print()\n\n";

   Employee::print();   // llama a función de clase base

   cout << " es un trabajador por hora con sueldo de"
        << " $" << setprecision(2) << getPay() << endl;
}

// main.CPP
#include <iostream>
#include "hourly.h"

int main(){
   HourlyWorker h("Bob", "Smith", 40.0, 7.50);
   h.print();
   return 0;
}
\end{minted}
\caption{Ejemplo de refefinición de métodos en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}
	

\subsection{Herencia múltiple en C++}

	Es posible que una clase requiere recibir miembros de más de una clase. Esto es posible haciendo uso de \textbf{herencia múltiple}. 

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
  Herencia múltiple es la capacidad de una clase derivada de heredar miembros de varias clases base.
\\ \hline
\end{tabular}
\end{center}


% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
class <nombre clase derivada> : <clase base 1> , <clase base 2>, 
   ...<clase base n> {
	...
};
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
class A{
	public:
	int i;
	void a(){}
};

class B{
	public:
	int j;
	void b(){}
};

class C{
	public:
	int k;
	void c(){}
};

class D: public A, public B, public C {
	public:
	int l;
	void d(){}
};
 
int main() {
	D var1;
	
	var1.a();
	var1.b();
	var1.c();
	var1.d();
	return 0;
}

\end{minted}
\caption{Ejemplo de herencia múltiple con C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

%<INSERTAR FIGURA 13>

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// BASE1.H
#ifndef BASE1_H
#define BASE1_H

class Base1 {
	public:
   	Base1(int x) { value = x; }
   	int getData() const { return value; }
	protected:         
	int value;   
};

#endif /*BASE1_H_*/

// BASE2.H
#ifndef BASE2_H
#define BASE2_H

class Base2 {
	public:
   	Base2(char c) { letter = c; }
   	char getData() const { return letter; }
	protected:        
   	char letter;   
};

#endif /*BASE2_H_*/

// DERIVED.H
#ifndef DERIVED_H
#define DERIVED_H

// herencia múltiple
class Derived : public Base1, public Base2 {
   	friend ostream &operator<<(ostream &, const Derived &);
	public:
   	Derived(int, char, float);
   	float getReal() const;
	private:
   	float real;   
};

#endif /*DERIVED_H_*/

// DERIVED.CPP
#include <iostream>
#include "base1.h"
#include "base2.h"
#include "derived.h"

Derived::Derived(int i, char c, float f): Base1(i), Base2(c) { 
	real = f; 
}

float Derived::getReal() const { 
	return real; 
}

ostream &operator<<(ostream &output, const Derived &d) {
   output << "     Entero: " << d.value
          << "\n   Caracter: " << d.letter
          << "\nNúmero real: " << d.real;

   return output;   
}

// main.CPP
#include <iostream>
#include "base1.h"
#include "base2.h"
#include "derived.h"

int main(){
	Base1 b1(10), *base1Ptr;   	
	Base2 b2('Z'), *base2Ptr;  	
	Derived d(7, 'A', 3.5);
   	
   	cout << "Objeto b1 contiene entero "
		<< b1.getData()
		<< "\nObjeto b2 contiene caracter "
		<< b2.getData()
		<< "\nObjeto d contiene:\n" << d;
	cout << "\n\nmiembros de clase derivada pueden ser"
		<< " accesados individualmente:"
		<< "\n  Entero: " << d.Base1::getData()
		<< "\n  Caracter: " << d.Base2::getData()
		<< "\n  Número real: " << d.getReal() << "\n\n";
	// Probar:  cout<<d.getData();  Es un error?
   	cout << "Miembros derivados pueden ser tratados como "
		<< "objetos de su clase base:\n";

   	base1Ptr = &d;
   	cout << "base1Ptr->getData() "
		<< base1Ptr->getData();

   	base2Ptr = &d;
   	cout << "\nbase2Ptr->getData() "
	<< base2Ptr->getData() << endl;
   	return 0;
}
\end{minted}
\caption{Otro ejemplo de herencia múltiple en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Aquí  se tiene un problema de \textbf{ambigüedad} al heredar dos métodos con el mismo nombre de clases diferentes. Se resuelve poniendo antes del nombre del miembro el nombre de la clase:   $objeto.<clase::>miembro$. El nombre del objeto es necesario, pues no se esta haciendo referencia a un miembro estático.

\subsubsection{Ambigüedades}

En el ejemplo anterior se vio un caso de ambigüedad al heredar de clases distintas un miembro con el mismo nombre. Normalmente se deben tratar de evitar esos casos, pues vuelven confusa nuestra jerarquía de herencia. 

	Existen otro casos donde es posible que se de la ambigüedad. 
	
	
\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//ejemplo de ambigüedad en la herencia
class B{
public:
	int b;
};

class D: public B, public B { //error
};

void f( D *p) {
	p->b=0;  //ambiguo
}

int main(){
	D obj;
	f(&obj);
	return 0; 
}
\end{minted}
\caption{Ejemplo de ambigüedad en herencia múltiple con C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

	El código anterior tiene un error  en la definición de herencia múltiple, ya que no es posible heredar más de una vez una misma clase de manera directa.	 Sin embargo, si es posible heredar las características de una clase más de una vez indirectamente:

%***INSERTAR FIGURA 14***

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//ejemplo de ambigüedad en la herencia
#include <iostream>
using namespace std;

class A{
	public:
	int next;
};

class B: public A{
};

class C: public A{
};

class D: public B, public C {
	int g();
};

int D::g(){
	//next=0;  Error: asignación ambigua
	return B::next == C::next;
}

class E: public D{
 	public:
	int x;
	int getx(){
		return x;
	}
};

int main(){
    D obj;
	E obje;

	obj.B::next=10;
	obj.C::next=20;
//  obj.A::next=11; 	Error: acceso ambiguo
//	obj.next=22;		Error: acceso ambiguo
	cout<<"next de B: "<<obj.B::next<<endl;
	cout<<"next de C: "<<obj.C::next<<endl;

	obje.x=0;
	obje.B::next=11;
	obje.C::next=22;
	cout<<"obje next de B: "<<obje.B::next<<endl;
	cout<<"obje next de C: "<<obje.C::next<<endl;
	return 0;
}
\end{minted}
\caption{Ejemplo 2 de ambigüedad en herencia múltiple con C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Este programa hace que las instancias de la clase D tengan objetos de clase base duplicados y provoca los accesos ambiguos. Este problema se resuelve con\textbf{ herencia virtual}.
	
% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
 \textbf{Herencia de clase base virtual}: Si se especifica a una clase base como virtual, solamente un objeto de la clase base existirá en la clase derivada. 
\\ \hline
\end{tabular}
\end{center}	

Para el ejemplo anterior, las clases B y C deben declarar a la clase A como clase base virtual:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
class B: virtual public A {...}

class C: virtual public A {...}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

El acceso entonces a los miembros puede hacerse usando una de las clases de las cuales heredo el miembro:

\begin{minted}{cpp}
obj.B::next=10;
obj.C::next=20;
\end{minted}

O simplemente accediéndolo como un miembro no ambiguo:ejercicio: probar los ejemplo y modificar la definición a clases base virtuales.

\mint[linenos=false]{cpp}| obj.next=22; |

	En cualquier caso se tiene solo una copia del miembro, por lo que cualquier modificación del atributo \textit{next} es sobre una única copia del mismo.
	
	
\subsubsection{Constructores en herencia múltiple}

Si hay constructores con argumentos, es posible que sea necesario llamarlos desde el constructor de la clase derivada. Para ejecutar los constructores de las clases base, pasando los argumentos, es necesario especificarlos después de la declaración de la función de construcción de la clase derivada, separados por coma. 

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
<Constructor clase derivada>(<argumentos>) : <base1> (<argumentos>), 
   <base2> (<argumentos>), ... , <basen> (<argumentos>) {
	...
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Donde como en la herencia simple, el nombre base corresponde al nombre de la clase, o en este caso, clases base.

El orden de llamada a constructores de las clases base se puede alterar a conveniencia. Una \textbf{excepción} a considerar es cuando se resuelve ambigüedad de una clase base pues en ese caso el constructor de la clase base ambigua únicamente se ejecuta una vez. Si no es especificado por el programador, se ejecuta el constructor sin parámetros de la clase base ambigua. Si se requiere pasar parámetros, se debe especificar la llamada antes de las llamadas a constructores de clase base directas. Este es el único caso en que es posible llamar a un constructor de una clase que no es un ancestro directo\cite{timothy2008introduction}. 
	
	
	
\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%


%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Herencia: implementación en Java}

La clase de la cual se toman sus características se conoce como \textbf{superclase}; mientras que la clase que ha sido creada a partir de la clase base se conoce como \textbf{subclase}. 

La herencia en Java difiere ligeramente de la sintaxis de implementación de herencia en C++.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
class <subclase> extends  <superclase> {
	//cuerpo subclase
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo

\textit{Una clase vehículo que describe a todos aquellos objetos vehículos que viajan en carreteras. Puede describirse a partir del número de ruedas y de pasajeros.
	De la definición de vehículos podemos definir objetos más específicos (especializados). Por ejemplo la clase camión.}
	
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//ejemplo de herencia
class Vehiculo{
	private int ruedas;
	private int pasajeros;
	
	public void setRuedas(int num){
		ruedas=num;
	}

	public int getRuedas(){
		return ruedas;
	}

	public void setPasajeros(int num){
		pasajeros=num;
	}

	public int getPasajeros(){
		return pasajeros;
	}

}

//clase Camion con herencia  de Vehiculo
public class Camion extends Vehiculo {
	private int carga;

	public void setCarga(int num){
		carga=num;
	}
	
	public int getCarga(){
		return carga;
	}

	public void muestra(){
		// uso de métodos heredados
		System.out.println("Ruedas: " + getRuedas());
		System.out.println("Pasajeros: " + getPasajeros());
		// método de la clase Camion
		System.out.println("Capacidad de carga: " + getCarga());
	}

	public static void main(String argvs[]){
		Camion ford= new Camion();
		ford.setRuedas(6);
		ford.setPasajeros(3);
		ford.setCarga(3200);
		ford.muestra();
	}

}
\end{minted}
\caption{Ejemplo de herencia en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En el programa anterior se puede apreciar claramente como una clase Vehículo hereda sus características a la subclase \textit{Camion}, pudiendo este último aprovechar recursos que no declara en su definición.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Tema sugerido} 
\end{center} 
\\ \hline
   BlueJ en apéndice A. (\ref{bluej}) 
\\ \hline
\end{tabular}
\end{center}

\subsection{Clase \textit{Object}}

En Java toda clase que se define tiene herencia implícita de una clase llamada \textit{Object}. En caso de que la clase que crea el programador defina una herencia explícita a una clase, hereda las características de la clase \textit{Object} de manera indirecta\footnote{En este caso hay que considerar que las características de la clase \textit{Object} pudieron haber sido modificadas a través de la jerarquía de herencia.}.

Ver clase \textit{Object} en: \url{https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html}

\subsection{Control de acceso a miembros en Java}

	Existen tres palabras reservadas para el control de acceso a los miembros de una clase: \textit{public}, \textit{private} y \textit{protected}. Estas sirven para proteger los miembros de la clase en diferentes formas. 

El control de acceso, como ya se vio anteriormente, se aplica a los métodos, atributos, constantes y tipos anidados que son miembros de la clase.

Resumen de tipos de acceso:

\begin{itemize}
\item \textit{private}. Un miembro privado únicamente puede ser utilizado por los métodos miembro de la clase donde fue declarado. Un miembro privado no es posible que sea manejado ni siquiera en sus subclases.
\item \textit{protected}. Un miembro protegido puede ser utilizado únicamente por los métodos miembro de la clase donde fue declarado, por los métodos miembro de las clases derivadas o clases que pertenecen al mismo paquete. El acceso protegido es como un nivel intermedio entre el acceso privado y público.
\item \textit{public}. Un miembro público puede ser utilizado por cualquier método. Este es visible en cualquier lugar que la clase sea visible
\end{itemize}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//ejemplo de control de acceso

class Acceso{
	protected int b;
	protected int f2() {
		return b;
	}

	private int c;
	private int f3() {
		return c;
	}

	public int d, f;
	public int f4(){ 
		return  d;
	}

}

public class EjemploAcceso {
	
	public static void main(String argvs[]){
		Acceso obj= new Acceso();

		obj.f2(); //es válido, ya que por omisión 
		obj.b=2; //las dos clases están en el mismo paquete

		obj.c=3; //error es un atributo privado
		obj.f3(); //error es un método privado

		obj.d=5;
		obj.f4();
	}
}

\end{minted}
\caption{Ejemplo de control de acceso en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


El ejemplo anterior genera errores de compilación al tratar de acceder desde otra clase a miembros privados. Sin embargo, los miembros protegidos si pueden ser accedidos porque están considerados implícitamente dentro del mismo paquete.
	
\subsection{Control de acceso de clase public en Java}

Este controlador de acceso \textit{public}, opera a nivel de la clase para que esta se vuelva visible y accesible desde cualquier lugar, lo que permitiría a cualquier otra clase hacer uso de los miembros de la clase pública.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
public class TodosMeVen {
// definición de la clase
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

La omisión de este calificador limita el acceso a la clase para que solo sea utilizada por clases pertenecientes al mismo paquete. 

Además, se ha mencionado que en un archivo fuente únicamente puede existir una clase pública, la cual debe coincidir con el nombre del archivo. La intención es que cada clase que tenga un objetivo importante debería ir en un archivo independiente, pudiendo contener otras clases no públicas que le ayuden a llevar a cabo su tarea.

\subsection{Constructores de superclase}

Los constructores no se heredan a las subclases. El constructor de la superclase puede ser llamado desde la clase derivada, para inicializar los atributos heredados y no tener que volver a introducir código de inicialización ya escrito en la superclase. 

La llamada explícita al constructor de la superclase se realiza mediante la referencia \textbf{super} seguida de los argumentos –si los hubiera- del constructor de la clase base. La llamada a este constructor debe ser hecha en la primera línea del constructor de la subclase. Si no se introduce así, el constructor de la clase derivadada llamará automáticamente al constructor por omisión (sin parámetros) de la superclase.

En el ejemplo siguiente podrá apreciarse esta llamada al constructor de la superclase.
\subsection{Manejo de objetos de subclase como objetos de superclase en Java}

Un objeto de una clase derivada, puede ser manejado como un objeto de su superclase. Sin embargo, un objeto de la clase base no es posible tratarlo como un objeto de clase derivada.

Un objeto de una subclase puede ser asignado a una variable de referencia de su superclase sin necesidad de indicar una conversión explícita mediante enmascaramiento. Cuando si se necesita utilizar enmascaramiento es para asignar de vuelta un objeto que aunque sea de una clase derivada, este referenciado por una variable de clase base. Esta conversión explícita es verificada por la máquina virtual, y si no corresponde el tipo real del objeto, no se podrá hacer la asignación y se generará una excepción en tiempo de ejecución.

Ejemplo:

\begin{minted}{java}
Superclase s= new superclase(), aptSuper;
Subclase sub= new subclase(), aptSub;

//válido
aptSuper = sub;

aptSub = (Subclase) aptSuper;

//inválido
aptSub= (Subclase) s;
\end{minted}

Podemos ver en el ejemplo anterior, que un objeto puede “navegar” en la jerarquía de clases hacia sus superclases, pero no puede ir a una de sus subclases, ni utilizando el enmascaramiento. Esto se hace por seguridad, ya que la subclase seguramente contendrá un mayor número de elementos que una instancia de superclase y estos no podrían ser utilizados porque causarían una inconsistencia.

Por último, es importante señalar que mientras un objeto de clase derivada este referenciado como un objeto de superclase, deberá ser tratado como si el objeto fuera únicamente de la superclase; por lo que no podrá en ese momento tener referencias a atributos o métodos definidos en la clase derivada.

Un código completo se muestra a continuación. \ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// definición de clase point
public class Point {
   protected double x, y; // coordenadas del punto

   // constructor
   public Point( double a, double b ) { 
	   setPoint( a, b ); 
   }

   // asigna a x,y las coordenadas del punto
   public void setPoint( double a, double b ) {
      x = a;
      y = b;
   }

   // obtiene coordenada x
   public double getX() { 
	   return x; 
   }  

   // obtiene coordenada y
   public double getY() { 
		return y; 
	}

   // convierte información a cadena
	public String toString(){ 
		return "[" + x + ", " + y + "]"; 
	}
}
// Definición de clase círculo
public class Circle extends Point {  // Hereda de Point
   protected double radius;

   // constructor sin argumentos
   public Circle()   {
      super( 0, 0 );  // llamada a constructor de clase base
      setRadius( 0 );  
   }

   // Constructor
   public Circle( double r, double a, double b )   {
      super( a, b );  // llamada a constructor de clase base
      setRadius( r );  
   }

   // Asigna radio del círculo
   public void setRadius( double r ) 
      { radius = ( r >= 0.0 ? r : 0.0 ); }

   // Obtiene radio del círculo
   public double getRadius() { return radius; }

   // Cálculo área del círculo
   public double area() { return 3.14159 * radius * radius; }

   // Convierte información en cadena
   public String toString() {
      return "Centro = " + "[" + x + ", " + y + "]" +
             "; Radio = " + radius;
   }
}
// Clase de Prueba de las clases Point y Circle
public class Prueba {

   public static void main( String argvs[] )  {
      Point pointRef, p; 
      Circle circleRef, c;

      p = new Point( 3.5, 5.3 );
      c = new Circle( 2.7, 1.2, 8.9 );

      System.out.println( "Punto p: " + p.toString() );
      System.out.println( "Circulo c: " + c.toString());
   
      // Tratamiento del círculo como instancia de punto
      pointRef = c;   // asigna círculo c a pointRef
      // en realidad Java lo reconoce dinámicamente como objeto Circle
      System.out.println( "Circulo c (via pointRef): " + pointRef.toString());
   
      // Manejar a un círculo como círculo 
      // (obteniéndolo de una referencia de punto)
      // asigna círculo c a pointref. Se repite la operación por claridad
      pointRef = c;   
      circleRef = (Circle) pointRef;  // enmascaramiento de superclase a subclase
      System.out.println( "Circulo c (via circleRef): " + circleRef.toString());
      System.out.println( "Area de c (via circleRef): " + circleRef.area());

      // intento de referenciar a un objeto point
      // desde una referencia de Circle (genera una excepcion)
      circleRef = (Circle) p;
   }
}
\end{minted}
\caption{Ejemplo de objetos de sub clase como de superclase en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



\subsection{Sobreescritura de métodos (Overriding)}

Frecuentemente, los métodos heredados no implementan el comportamiento específico requerido por la subclase. Java permite \textbf{sobreescribir} (o redefinir) un método de la clase base en la clase derivada. Al invocar el método desde una instancia de la subclase, se ejecutará la nueva versión.

Es una buena práctica utilizar la anotación \texttt{@Override} para asegurar que el compilador verifique la firma del método. Sin embargo, aún es posible acceder a la lógica original de la clase base utilizando la referencia \texttt{super}.

\ejemplo
\begin{longlisting}
\begin{minted}
    [frame=lines,
    framesep=2mm,
    baselinestretch=1.1,
    bgcolor=lightgray,
    fontsize=\footnotesize,
    linenos] % linenos añade números de línea, muy útil para docencia
    {java}
// Clase base: Empleado
public class Empleado {
    // Se recomienda usar protected si se planea acceso directo en herencia,
    // o mantener private y usar getters.
    protected String nombre;
    protected String apellido;

    public Empleado(String nombre, String apellido){
        // Asignación directa, no es necesario new String()
        this.nombre = nombre;
        this.apellido = apellido;
    }

    public void imprimirDatos() { 
        System.out.println("Empleado: " + nombre + " " + apellido);
    }
}

// Clase derivada: TrabajadorPorHora
public class TrabajadorPorHora extends Empleado {
    private double sueldoHora; // double tiene mayor precisión que float
    private double horas;            
    
    public TrabajadorPorHora(String nombre, String apellido, 
                             double horas, double sueldoHora) {
        super(nombre, apellido); // Llama al constructor de la clase base
        this.horas = horas;
        this.sueldoHora = sueldoHora;
    }

    public double calcularPago() { 
        return sueldoHora * horas; 
    }

    @Override // Buena práctica: asegura que estamos sobreescribiendo
    public void imprimirDatos() {
        System.out.println("--- Detalle Trabajador por Hora ---");
        
        // Reutilizamos la lógica de la clase padre
        super.imprimirDatos();   

        System.out.println("Sueldo calculado: $" + calcularPago());
    }
}

// Clase de prueba
public class TestEmpleados {

    public static void main(String[] args) {
        Empleado e = new Empleado("Juan", "García");
        TrabajadorPorHora h = new TrabajadorPorHora("Ana", "Pérez", 40.0, 15.50);

        e.imprimirDatos(); // Ejecuta versión de Empleado
        h.imprimirDatos(); // Ejecuta versión sobreescrita de TrabajadorPorHora
    }
} 
\end{minted}
\caption{Ejemplo de sobreescritura de métodos y uso de \texttt{super}.}
\label{listing:1}
\end{longlisting}

\subsection{Calificador \textit{final}}

Es posible que tengamos la necesidad de que cierta parte de una clase  no pueda ser modificada en futuras extensiones de la jerarquía de herencia. Para esto es posible utilizar el calificador \textit{final}.

Si un método se especifica en una clase X como \textit{final}:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}| <acceso> final <tipo> nombreMétodo( <parámetros>)  |\\
\hline
\end{tabular}
\end{center}

Se esta diciendo que el método no podrá ser redefinido en las subclases de X.
	
Aunque se omita este calificador, si se trata de un método de clase (estático) o privado, se considera final y no podrá ser redefinido.

Por otro lado, es posible que no queramos dejar la posibilidad de extender una clase, para lo que se utiliza el calificador \textit{final} a nivel de clase:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
<acceso> final class nombreClase {

	//definición de la clase

}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

De esta forma, la clase no permite generar subclases a partir de ella.  De hecho, el API de Java incluye muchas clases \textit{final}, por ejemplo la clase java.lang.String no puede ser especializada.

\subsection{Interfaces en Java}

Java únicamente cuenta con manejo de herencia simple, y la razón que se ofrece es que la herencia múltiple presenta algunos problemas de ambigüedad que complica el entendimiento del programa, sin que este tipo de herencia justifique las ventajas obtenidas de su uso.

	Sin embargo, es posible que se necesiten recibir características de más de un origen. Java soluciona esto mediante el uso de interfaces, que son una forma para declarar tipos especiales de clase que, aunque con ciertas limitaciones, no ofrecen las complicaciones de la herencia múltiple.

	Una interfaz tiene un formato muy similar a una clase, sus principales características:

    
\begin{itemize}
\item Una interfaz proporciona los nombres de los métodos (método abstracto), pero no sus implementaciones\footnote{En esta caso si se considera la declaración de prototipos.}.
\item Los métodos son públicos por omisión.
\item     Una clase puede implementar varias interfaces, aunque solo pueda heredar una clase.
\item     No es posible crear instancias de una interfaz.
\item     La clase que implementa la interfaz debe escribir el código de todos los métodos, de otra forma no se podrá generar instancias de esa clase.

\end{itemize}

El formato general para la declaración de una interfaz es el siguiente:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
[public] interface <nombreInterfaz> {
	//descripción de miembros
	//los métodos no incluyen código:
	<acceso> <tipo> <nombreMetodo> ( <parámetros> ) ;
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

El cuerpo de la interfaz generalmente es una lista de prototipos de métodos, pero puede contener atributos si se requiere\footnote{El parámetro debe incluir el nombre, el cual no es obligatorio que coincida en la implementación.}.

Una clase implementa una interfaz a través de la palabra reservada \textit{implements} después de la especificación de la herencia (si la hubiera) :

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
class <SubClase> extends <Superclase> implements   <nombreInterfaz> {
	//definición de la clase
	//debe incluirse la definición de los métodos de la interfaz
	//con la implementación del código de dichos métodos.
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Además, una interfaz puede ser extendida de la misma forma que una clase, aprovechando las interfaces previamente definidas, mediante el uso de la cláusula \textit{extends}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
[public] interface <nombreInterfaz> extends <InterfazBase> {

	//descripción de miembros

}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

De forma distinta a la jerarquía de clases, donde se tiene una jerarquía lineal que parte siempre de una clase simple \textit{Object}, una clase soporta herencia múltiple de interfaces, resultando en una jerarquía con múltiples raíces de diferentes interfaces.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//interfaz
interface IStack {                                               
    void push(Object item);
    Object pop();
}

//clase implementa la interfaz
class StackImpl implements IStack {                               
    protected Object[] stackArray;
    protected int tos;

    public StackImpl(int capacity) {
        stackArray = new Object[capacity];
        tos = -1;
    }

	//implementa el método definido en la interfaz
    public void push(Object item)                                 
        { stackArray[++tos] = item; }

	//implementa el método definido en la interfaz
    public Object pop() {                                         
        Object objRef = stackArray[tos];
        stackArray[tos] = null;
        tos--;
        return objRef;
    }

    public Object peek() { return stackArray[tos];}
}

// extendiendo una interfaz
interface ISafeStack extends IStack {                             
    boolean isEmpty();
    boolean isFull();
}


//esta clase hereda la implementación de la pila StackImpl
// e implementa la nueva interfaz extendida ISafeStack
class SafeStackImpl extends StackImpl implements ISafeStack {     

    public SafeStackImpl(int capacity) { super(capacity); }
    
    //implementa los métodos de la interfaz
    public boolean isEmpty() { return tos < 0; }                  
    public boolean isFull() { return tos >= stackArray.length;
 	}  
}

public class StackUser {

    public static void main(String args[]) {                      
        SafeStackImpl safeStackRef = new SafeStackImpl(10);
        StackImpl stackRef = safeStackRef;
        ISafeStack isafeStackRef = safeStackRef;
        IStack istackRef = safeStackRef;
        Object objRef = safeStackRef;

        safeStackRef.push("Dolar");                             
        stackRef.push("Peso");

		// tipo de dato simple es convertido a Integer:
        stackRef.push(1);
        System.out.println(stackRef.peek().getClass());

        System.out.println(isafeStackRef.pop());
        System.out.println(istackRef.pop());
        
        System.out.println(objRef.getClass());
    }
}
\end{minted}
\caption{Ejemplo de interfaz en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

%<INSERTAR FIGURA ISTACK>

Por otro lado, una interfaz también puede ser utilizada para definir nuevos tipos. Una interfaz así o una clase que implementa a una interfaz de este estilo es conocida como \textbf{Supertipo}.

Es importante resaltar tres diferencias en las relaciones de herencia y como esta funciona entre clases e interfaces:
 
\begin{enumerate}
\item  \textbf{Implementación lineal de jerarquía de herencia entre clases}: una clase extiende a otra clase.
\item  \textbf{Jerarquía de herencia múltiple entre interfaces}: una interfaz extiende otras interfaces.
\item  \textbf{Jerarquía de herencia múltiple entre interfaces y clases}: una clase implementa interfaces.
\end{enumerate}
\subsubsection{Interfaces en Java con implementación predeterminada de métodos}

A partir de Java 8 permite el uso de métodos implementados en interfaces. Estos pueden ser métodos estáticos o un tipo especial de método llamado \textit{Default}\footnote{\url{https://www.techempower.com/blog/2013/03/26/everything-about-java-8/}, \url{https://stackoverflow.com/questions/18286235/what-is-the-default-implementation-of-method-defined-in-an-interface}}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
[public] interface <nombreInterfaz> {
	//implementación predeterminada de método
	<acceso> default <tipo> <nombreMetodo> ( <parámetros> ) {
            //código del método
    }
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Ahora, las clases que implementan la interfaz no tienen que proporcionar su propia implementación del método o métodos. Si no lo hacen, se utilizará la implementación predeterminada.

\subsubsection{Ambigüedad con implementación de métodos en interfaces}
Si una clase hereda de una interfaz que tiene un método por defecto y también hereda de una clase base que tiene un método con la misma firma, se utilizará la implementación de la clase base, y no se generará una ambigüedad.

Pero si de dos interfaces distintas se hereda un método implementado con la misma firma, si existe ambigüedad. Para evitarla, la clase que implementa a las interfaces tiene queproporcionar su propia implementación del método:

Ejemplo:
\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}

interface InterfazA {
    default void metodo() {
        System.out.println("InterfazA");
    }
}

interface InterfazB {
    default void metodo() {
        System.out.println("InterfazB");
    }
}

// Ambigüedad si descomentas esta línea:
// class MiClase implements InterfazA, InterfazB {}

class MiClase implements InterfazA, InterfazB {
    // Si proporcionas tu propia implementación, no hay ambigüedad
    @Override
    public void metodo() {
        System.out.println("Implementación en MiClase");
    }
}

public class Main {
    public static void main(String[] args) {
        MiClase instancia = new MiClase();
        instancia.metodo(); // Imprime "Implementación en MiClase"
    }
}

\end{minted}
\caption{Ejemplo de interfaz con potencial ambigüedad en métodos predefinidos en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\subsubsection{Y ¿atributos en las interfaces?}
Hasta Java 7, las interfaces solo podían contener constantes (variables estáticas finales) como atributos. Estos atributos se consideraban \textbf{automáticamente} como \textit{public}, \textit{static}, y \textit{final}. Un ejemplo sería:
%multiple lines
\begin{minted}{java}
public interface MiInterfaz {
    int MI_CONSTANTE = 42; // Atributo (public, static, final)
}
\end{minted}

%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
En resumen, en Java, una interfaz puede contener lo siguiente:

    \begin{enumerate}
        \item \textbf{Variables Constante}s: Por defecto son públicas, estáticas y finales.
        \item \textbf{Métodos Abstractos}: Estos métodos son por defecto abstractos y públicos.
        \item \textbf{Métodos Predeterminados}: A partir de Java 8. Estos son métodos no abstractos y proporcionan una implementación predeterminada.
        \item \textbf{Métodos Estáticos}: A partir de Java 8, Estos son métodos que pertenecen a la interfaz en lugar de a las instancias de la interfaz.
        \item \textbf{Métodos Privados}: Introducidos en Java 9, estos métodos sólo pueden ser utilizados dentro de la interfaz y otros métodos de interfaz.
        \item \textbf{Métodos Estáticos Privados}: Estos son métodos estáticos que son privados para la interfaz.
    \end{enumerate}

Tener en cuenta que las interfaces en Java no tienen estado, y cualquier variable que crees son realmente constantes. Además, una interfaz no puede contener un constructor ya que no puede ser utilizada para crear objetos. Si se requiere que una clase tenga un cierto atributo, se necesita usar una clase abstracta. La idea de usar atributos en una interfaz generalmente se considera una mala práctica en Java.
\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%


\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%



%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Herencia: Implementación en Ruby}

Ruby, al igual que Java, no cuenta con herencia múltiple, por lo que únicamente es posible indicar una clase como superclase. Para esto se utiliza el símbolo $<$ antes del nombre de la superclase. 

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
class <SubClase> < <SuperClase>
  # codigo de la subclase
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Retomando el  ejemplo del la jerarquía de Vehículo y Camión, visto anteriormente. 

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
# ejemplo de herencia 
class Vehiculo
	@ruedas
	@pasajeros
	attr_accessor :ruedas, :pasajeros  
end

# clase Camion con herencia de Vehiculo
class Camion < Vehiculo
	@carga
	attr_accessor :carga
	
	public
	def muestra
		# uso de métodos heredados y generados automáticamente 
		# por attr_accessor

		puts "Ruedas: #{ruedas}"
		puts "Pasajeros: #{pasajeros}"
		# método de la clase Camion
		puts "Capacidad de carga: #{carga}"
	end
end

# Código de prueba
ford= Camion.new
ford.ruedas =6
ford.pasajeros=3
ford.carga=3200
ford.muestra
\end{minted}
\caption{Ejemplo de herencia en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Clase \textit{Class}}

Las clases en Ruby son considerados objetos de primera clase\footnote{Pueden ser usados en el lenguaje de programación como cualquier otro objeto.}. Cada clase declarada en Ruby es una instancia de la clase \textit{Class} \cite{thomas2005programming}. 

El proceso que se sigue es el siguiente: cuando una clase es definida, un objeto de la clase \textit{Class} es creado y asignado a una constante global con el nombre usado en la definición. Cuando un nuevo objeto de la clase es instanciado ($nombreClase.new$), el método \textit{new}  de \textit{Class} es ejecutado por omisión.\footnote{De hecho, el método \textit{new}  de la clase \textit{Class} puede ser redefinido, aunque no es una práctica recomendada.} 

A continuación se presenta la información general de la clase Class \cite{thomas2005programming}:

\begin{alltt}
class methods
inherited 		aClass.inherited( aSubClass )
This is a singleton method (per class) invoked by Ruby when a subclass 
of aClass is created. The new subclass is passed as a parameter.

class Top
  def Top.inherited(sub)
	print "New subclass: ", sub, "\\n"
  end
end


class Middle < Top
end


class Bottom < Middle
end

produces:

New subclass: Middle
New subclass: Bottom

new 	Class.new( aSuperClass=Object ) -> aClass
Creates a new anonymous (unnamed) class with the given superclass (or 
Object if no parameter is given).

instance methods
new 	aClass.new( [ args ]* ) -> anObject
Creates a new object of aClass's class, then invokes that object's 
initialize method, passing it args.

superclass 	aClass.superclass -> aSuperClass or nil
Returns the superclass of aClass, or nil.

Class.superclass 	» 	Module
Object.superclass 	» 	nil
\end{alltt}

\subsection{Clase \textit{Object}}

La clase padre de todas las clases en Ruby es la clase \textit{Object}, por lo que sus métodos están disponibles para todos los objetos a menos que estos se encuentren redefinidos.

A continuación se presenta una lista de los métodos de \textit{Object}:


\begin{alltt}
==   ===   =~   __id__   __send__   class   clone   dclone   display
dup   enum_for   eql?   equal?   extend   freeze   frozen?   hash   
id   inspect   instance_eval   instance_of?   instance_variable_defined?   
instance_variable_get   instance_variable_get   instance_variable_set   
instance_variable_set   instance_variables   is_a?   kind_of?   method   
methods   new   nil?   object_id   private_methods   protected_methods   
public_methods   remove_instance_variable   respond_to?   send   
singleton_method_added   singleton_method_removed   singleton_method_undefined   
singleton_methods   taint   tainted?   to_a   to_enum   to_s   to_yaml   
to_yaml_properties   to_yaml_style   type   untaint 
\end{alltt}
    
\subsection{Control de acceso a miembros en Ruby}

Como ya se ha mencionado, también en Ruby existen tres palabras reservadas para el control de acceso a los \textbf{métodos} de una clase: \textit{public}, \textit{private} y \textit{protected}. Estas sirven para proteger los métodos de la clase en diferentes formas. 

Resumen de tipos de acceso:

\begin{itemize}
\item private. Un método \textbf{privado} no puede ser llamado mediante un objeto. Por esta razón, los métodos privados solo pueden ser utilizados en la definición de la clase.
\item protected. Un método \textbf{protegido} puede ser utilizado únicamente por objetos de la clase donde se define el método, así como por sus subclases.
\item public. Un método \textbf{público} puede ser utilizado por cualquier método. Éste es visible en cualquier lugar que la clase sea visible. Los métodos son públicos por omisión, con excepción del método initialize, el cual es privado. 
\end{itemize}

El comportamiento de acceso privado y protegido es diferente de los lenguajes C++ y Java. En Ruby, un método protegido puede ser llamado por cualquier instancia de la clase donde se define o de sus subclases. Por su parte, un método privado puede ser llamado solamente en el contexto un objeto de la clase. Los métodos privados no puede ser ejecutados directamente ni siquiera por otro objeto de la misma clase \cite{thomas2005programming}. El uso de \textit{self}  tampoco es válido para métodos privados.

Ejemplo:

\begin{minted}{ruby}
class MiClase
      def metodo1    # default es 'public'
        #...
      end

  protected          # subsecuentes métodos serán 'protected'

      def metodo2    #  'protected'
        #...
      end

  private            # subsecuentes métodos serán 'private'

      def metodo3    #  'private'
        #...
      end

  public             # subsecuentes métodos serán 'public'

      def metodo4    # 'public'
        #...
      end
end
\end{minted}

o

\begin{minted}{ruby}
class MiClase
  def metodo1
  end
	...
  public    :metodo1, :metodo4
  protected :metodo2
  private   :metodo3
end
\end{minted}

\subsection{Inicializadores de superclase}

En Ruby, de manera similar a Java, es posible llamar al método inicializador de la superclase usando \textit{super} seguido de la lista de argumentos.


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
class Persona

  attr_accessor :nombre, :edad, :sexo

  def initialize(nombre, edad, sexo)
    @nombre, @edad, @sexo = nombre, edad, sexo
  end

end


class Estudiante < Persona

  attr_accessor :matr, :horas

  def initialize(nombre, edad, sexo, matr, horas)
    super(nombre, edad, sexo)
    @matr = matr
    @horas = horas
  end

  # ...

end

# Creando dos objetos
a = Persona.new("Ironman", 37, "m")
b = Estudiante.new("Spiderman", 36, "m", "000-13-5031", 24)

\end{minted}
\caption{Ejemplo de herencia e inicializador en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Manejo de objetos de la subclase como objetos de una superclase en Ruby}

El manejo de objetos de subclase como objetos de superclase no es posible en Ruby, debido a que los identificadores no tienen un tipo de dato.


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
# definicion de clase point
class Point 
   attr_reader :x, :y
   
   protected
   @x
   @y # coordenadas del punto
   # constructor
   def initialize a, b  
	   setPoint a, b  
   end
   # asigna a x,y las coordenadas del punto
   public 
   def setPoint a, b
      @x = a
      @y = b
   end  
   # convierte informacion a cadena
	def to_s 
		return "[ #{@x}, #{@y} ]"
	end
end

# Definicion de clase circulo
class Circle < Point # Hereda de Point
   attr_reader :radius
   @radius

   # Constructor
   def initialize r, a, b
      super a, b  # llamada a constructor de clase base
      setRadius r   
   end

   # Asigna radio del circulo
   def setRadius r 
      @radius = ( r >= 0 ? r : 0 ) 
   end
 
   # Calculo area del circulo
   def area  
   	  return 3.14159 * radius * radius
   end

   # Convierte informacion en cadena
   def to_s 
      return "Centro = [ #{@x},  #{@y} ]; Radio = #{@radius}"
   end
end

# código de Prueba de las clases Point y Circle
def prueba
	  p = Point.new 3.5, 5.3 
      c = Circle.new  2.7, 1.2, 8.9 
      puts "Punto p: " + p.to_s
      puts "Circulo c: " + c.to_s 
      # Tratamiento del circulo como instancia de punto
      pointRef = c;   # asignar circulo c a pointRef no hace diferencia porque 
      # los identificadores no tienen tipo
      # en realidad Ruby lo reconoce dinámicamente como objeto Circle sin importar 
      # el identificador
      puts "Circulo c (via pointRef): " + pointRef.to_s
   
      # asigna circulo c a pointref. Se repite la operacion por claridad
      pointRef = c;   
      circleRef = pointRef  # es asignación de referencias sin importar el tipo
end

prueba
\end{minted}
\caption{Ejemplo de objetos de sub clase como de superclase en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Redefinición de métodos}

Ruby permite \textbf{redefinir} un método de la clase base en la clase derivada. Cuando se hace referencia al nombre del método, se ejecuta la versión de la clase en donde fue redefinida. Es posible sin embargo, utilizar el método de la clase base por medio la palabra \textit{super}. A diferencia de Java, aquí solo es necesaria esta palabra (y si se necesita la lista de argumentos) para llamar al método correspondiente de la clase base desde la clase derivada.


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
#clase empleado
class Empleado 
	@firstName
	@lastName      

	def initialize first, last
	   @firstName = String.new(first)
	   @lastName = String.new(last)
	end

	def print 
		puts @firstName.to_s + " " + @lastName.to_s
	end
end

#clase TrabajadorporHora
class TrabajadorPorHora < Empleado 
	@wage
	@hours
	           
	def initialize first, last, initHours, initWage
		super first, last
		@hours = initHours
		@wage = initWage
	end

	def getPay 
		@wage * @hours 
	end

	def print
		puts "Metodo print de Trabajador por hora"
		super   # llama a función de clase base
        puts " es un trabajador por hora con sueldo de" +" $" + getPay.to_s
	end
end

#prueba de clases
e= Empleado.new "nombre", "apellido"

h= TrabajadorPorHora.new "Juanito", "Perez", 40.0, 7.50
e.print
h.print();
\end{minted}
\caption{Ejemplo de refefinición de métodos en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



\subsection{Mixins en Ruby}

En lugar de interfaces, Ruby tiene \textit{mixins}, que es es la capacidad de un módulo de ser añadido a una clase o a otro módulo con la operación \textit{include} \cite{matsumoto2002ruby}. De hecho, un \textit{mixin} en Ruby puede verse como una interfaz pero con sus métodos implementados. Además, es posible heredar características de uno o más \textit{mixins} (módulos) obteniendo con esto un resultado similar al de la herencia múltiple. El concepto de \textit{mixin} apareció en el lenguaje \textit{Flavors}. El nombre fue inspirado en una máquina de helados que ofrecía en sabores básicos mezclados con ingredientes extras, estos helados eran llamados \textit{“Mix-In”}.\footnote{\textit{''For a real ice cream treat, try Steve's Ice Cream (191 Elm Street, Sommerville).  Steve's homemade ice cream is perhaps the best in town.  Cones are \$.35 and \$.55, and for \$.10 each you can choose ''mix-ins,''
consisting of M\&M's, Heath bars, and many others.  If you want fruit mixed in it costs \$.10 more.  Sundaes are \$.75 and \$1.25, banana splits are \$1.75, and egg creams are \$.40.  The portions at Steve's are large, and so are the lines, so expect to do a little waiting.  It's worth it.''} \cite{silver1975} pág. 224}

 Aunque también pueden ser añadidos a un objeto específico usando \textit{extend}.

Es importante señalar que en la definición del módulo pueden incluirse atributos y restricciones de acceso, mismos que serán pasados a la clase que incluye dicho módulo. Una vez definido el módulo, éste puede ser añadido a una clase de la siguiente forma:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
class unaClase
  include <nombre-módulo>
   ...
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}



%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
#modulo
module Stack                                                
    def push(item) end
    def pop; end
end

#clase incluye modulo
class StackImpl 
    include Stack                                
    @stackArray
    @tos
	public
	def initialize 
        @stackArray = [] 
        @tos = -1
	end

    #implementa el método definido en el módulo
    def push item
        @stackArray[@tos+=1] = item
    end

    #implementa el método definido en el módulo
    def pop                                         
        objRef = @stackArray[@tos]
        @stackArray[@tos] = nil
        @tos-=1
        return objRef
    end

    def peek 
        return @stackArray[@tos]
    end
end

# extendiendo un módulo puede ser hecho en el mismo módulo
# dinámicamente o en otro módulo. Pero en este caso las queremos separadas

=begin
module Stack                              
    def isEmpty
    end
    def isFull
    end
end
=end

module SafeStack                              
    def isEmpty
	end
    def isFull
    end
end

# esta clase hereda la implementación de la pila StackImpl
# e implementa la nueva interfaz extendida SafeStack
class SafeStackImpl < StackImpl 
    include SafeStack      

    def initialize 
        super 
    end
    
    # implementa los métodos de la interfaz
    def isEmpty 
        return tos < 0
    end                  
    def isFull 
        tos >= stackArray.length
    end
end 

def stackUser 
    safeStackRef = SafeStackImpl.new 
    
    safeStackRef.push("Dolar");                             
    safeStackRef.push "Peso"
    puts safeStackRef.pop
    puts safeStackRef.pop
      
    puts safeStackRef.class
end

stackUser
\end{minted}
\caption{Ejemplo de mixins en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Aunque la instrucción \textit{include} nos puede recordar a la misma instrucción en C/C++, en realidad es diferente. $\#include$ en C/C++ es ejecutada por el preprocesador e indica que el archivo correspondiente debe ser insertado momentos previos a la compilación. 

Además, en Ruby, no se copia el código, sino que se hace una referencia de la clase al módulo incluido. Múltiples clases pueden tener referencia al mismo módulo y si este módulo es modificado, inclusive mientras el programa esta ejecutándose, todas las clases se verán afectadas en su comportamiento \cite{thomas2005programming}. Mucha de la fuerza del uso de \textit{mixins} esta en la  funcionalidad que añade a las clases, pero en código bien diseñado este poder puede verse aún más si el código en el \textit{mixin} interactúa con el código de las clases.  

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%



%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Herencia: Implementación en Python}

El manejo de herencia en Python se hace de la siguiente manera\footnote{\href{https://docs.python.org/3/tutorial/classes.html#inheritance}{Multiple Inheritance}}:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
class <ClaseDerivada>(<ClaseBase>):
    <instrucciones>
    \end{minted}
\\
Si la clase se encuentra en otro módulo:
\\
   \begin{minted} [linenos=false]{python}
class <ClaseDerivada>(<Módulo>.<ClaseBase>):
    <instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Todas las clases en Python 3 derivan de la clase \textit{object}. Los métodos de la clase base pueden ser redefinidos. Un objeto ejecutando métodos puede ser que llame a métodos de la clase base o métodos redefinidos en la jerarquía de herencia, de manera similar a los métodos virtuales en C++.

Si fuera necesario llamar a un método de clase base que se haya redefinido en una clase derivada puede hacerse.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{python}| <ClaseBase>.<método>(self, <argumentos>)  |\\
\hline
\end{tabular}
\end{center}

Dos métodos útiles en herencia son $isinstance(<objeto>, <clase>)$, el cual devuelve verdadero si un objeto pertenece a una clase o subclase especificada (directa, indirecta o virtual); de forma similar, $issubclass(<clase>, <infoclase>)$ regresa verdadero si $<clase>$ es una subclase (directa, indirecta o virtual) de $<infoclase>$\footnote{Aquí, una clase es considerada subclase de si misma.}.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Persona:
	def __init__(self, nombre, apellido):
		self.nombre = nombre
		self.apellido = apellido

	def nombreCompleto(self):
		return self.nombre + " " + self.apellido

class Empleado(Persona):

	def __init__(self, nombre, apellido, staffnum):
		Persona.__init__(self,nombre, apellido)
		self.staffnum = staffnum

	def getEmpleado(self):
		return self.nombreCompleto() + ", " + self.staffnum

# script de ejecución inicial
x = Persona("Una", "Persona")
y = Empleado("Un", "Empleado", "121212")

print(x.nombreCompleto())
print(y.getEmpleado())
\end{minted}
\caption{Ejemplo de herencia en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Inicializadores de superclase}

En Python también es posible llamar al método inicializador de la superclase usando \textit{super} seguido de la lista de argumentos.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

class Persona:
	def __init__(self, nombre, edad, sexo):
		self.nombre = nombre
		self.edad = edad
		self.sexo = sexo

	def __str__(self):
		return self.nombre + " " + str(self.edad)+ " "+ self.sexo

class Estudiante(Persona):
	def __init__(self, nombre, edad, sexo, matr, horas):
		# en Python 3 no se necesita pasar self al llamar
		# a super() ni la sintaxis super(subclase, self)
		# de Python 2
		super().__init__(nombre, edad, sexo)
		self.matricula = matr
		self.horas = horas
	def __str__(self):
		return super().__str__() + " " + self.matricula + " " + str(self.horas)

#creando dos objetos
a = Persona("Ironman", 37, "m")
b = Estudiante("Spiderman", 36, "m", "000-13-5031", 24)

print(a)
print(b)
\end{minted}
\caption{Ejemplo con inicializadores de superclase en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Herencia Múltiple (\textit{mixins}) en Python}

Python soporta una forma limitada de herencia múltiple. Algunos autores se refieren a la implementación de Python de herencia múltiple como mixins\footnote{ \href{https://www.ianlewis.org/en/mixins-and-python}{Mixins and Python}}. La definición de una clase con herencia múltiple tiene la siguiente forma:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
class <ClaseDerivada>(<ClaseBase1>, <ClaseBase2>, ... ):
    <instrucciones>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
class Base1 :
	def __init__(self, x):
		self.value=x

	def getData(self):
		return self.value

class Base2 :
	def __init__(self, c):
		self.letter=c

	def getData(self):
		return self.letter

# herencia múltiple
class Derived (Base1, Base2) :

	def __init__(self, i, c, f):
		Base1.__init__(self, i)
		Base2.__init__(self, c)
		self.real=f

	def getReal(self) :
		return self.real

#script de inicio de ejecución
b1 = Base1(10)
b2 = Base2('Z')
d = Derived(7, 'A', 3.5)

print("Objeto b1 contiene entero ", b1.getData())
print("Objeto b2 contiene caracter ", b2.getData())
print("Objeto d contiene ", d.getData())
\end{minted}
\caption{Ejemplo de mixins en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En Python, la jerarquía de herencia es definida de derecha a izquierda por lo que hay que tener en cuenta que el resultado puede variar si una clase de más a la izquierda redefine métodos o atributos. Por eso se considera a la clase de la extrema derecha como la “clase base principal”, mientras que las otras clases agregan características (es por este aspecto por el que se maneja a veces como mixins). \textit{En caso de redefinir un método, se ejecutará el que se encuentre más a la extrema izquierda (el último en ser redefinido)}

Tener en cuenta que la llamada a múltiples inicializadores de clase en herencia múltiple si puede en la práctica generar conflictos. Lo sugerido es en caso de herencia múltiple siempre hacer llamadas a inicializadores de clase base mediante el nombre de la clase base (en lugar de super) \textbf{a través de toda la jerarquía de herencia}, no únicamente en la clase que tiene herencia múltiple




%%%%%%%%%%
% ADVANCED
%%%%%%%%%%
\ifadvanced

\subsubsection{Problema: Firmas de Métodos Incompatibles}
Si cada $\_\_init\_\_$ tiene parámetros fijos, el sistema se rompe. $super()$ llama al siguiente método en el MRO, pero no sabe qué parámetros espera ese método.
%Ejemplo fallido
\begin{minted}{python}
# EJEMPLO INCORRECTO - ESTO DARÁ UN ERROR
class Motor:
    def __init__(self, cilindros):
        self.cilindros = cilindros

class Chasis:
    def __init__(self, material):
        self.material = material

class Coche(Motor, Chasis):
    def __init__(self, cilindros, material, color):
        # ¿Cómo llamamos a super? ¿Con qué parámetros?
        # super().__init__(cilindros) # Falla porque Chasis no espera 'cilindros'
        # super().__init__(material)  # Falla porque Motor no espera 'material'
        self.color = color
\end{minted}

Este código está destinado a fallar porque no hay una forma de que $super().\_\_init\_\_$ satisfaga a \textit{Motor} y a \textit{Chasis} al mismo tiempo.

\textbf{La Solución Cooperativa con **kwargs}

Para solucionarlo, modificamos todos los inicializadores para que acepten $$**kwargs$. Cada método "consume" los argumentos que necesita del diccionario \textit{kwargs} y pasa el resto al siguiente nivel.

Veamos el ejemplo de una jerarquía con parámetros específicos para cada clase.
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
class SerVivo:
    def __init__(self, *, nombre, **kwargs):
        print(f"SerVivo necesita 'nombre'. Recibe: {nombre}")
        super().__init__(**kwargs) # Pasa los kwargs restantes
        self.nombre = nombre

class Ave(SerVivo):
    def __init__(self, *, envergadura, **kwargs):
        print(f"Ave necesita 'envergadura'. Recibe: {envergadura}")
        super().__init__(**kwargs) # Pasa los kwargs restantes
        self.envergadura = envergadura

class Mamifero(SerVivo):
    def __init__(self, *, tipo_pelaje, **kwargs):
        print(f"Mamifero necesita 'tipo_pelaje'. Recibe: {tipo_pelaje}")
        super().__init__(**kwargs) # Pasa los kwargs restantes
        self.tipo_pelaje = tipo_pelaje

class Murcielago(Ave, Mamifero):
    def __init__(self, *, habilidad_ecolocalizacion, **kwargs):
        print(f"Murcielago necesita 'habilidad_ecolocalizacion'. Recibe: {habilidad_ecolocalizacion}")
        super().__init__(**kwargs) # Pasa los kwargs restantes
        self.habilidad_ecolocalizacion = habilidad_ecolocalizacion

# --- Probemoslo ---
print("Creando un murciélago con todos los parámetros...")
# Al crear el objeto, debemos proveer TODOS los parámetros que la cadena necesita.
mi_murcielago = Murcielago(
    nombre="Batty",
    tipo_pelaje="Corto",
    envergadura=0.3,
    habilidad_ecolocalizacion=True
)

# Verificamos que todos los atributos se asignaron correctamente
print("\n--- Atributos del Murciélago ---")
print(f"Nombre: {mi_murcielago.nombre}")
print(f"Pelaje: {mi_murcielago.tipo_pelaje}")
print(f"Envergadura: {mi_murcielago.envergadura}m")
print(f"Ecolocalización: {mi_murcielago.habilidad_ecolocalizacion}")
    \end{minted}
\\ \hline
\end{tabular}
\end{center}	

\textbf{¿Cómo funcionó? 
}
    \begin{itemize}
        \item $Murcielago(nombre=..., tipo\_pelaje=..., ...)$: Se llama al inicializador de \textit{Murcielago} con un diccionario de 4 argumentos.
        \item $Murcielago.\_\_init\_\_$: Toma su argumento $habilidad\_ecolocalizacion$. Llama a $super().\_\_init\_\_$ pasándole los 3 argumentos restantes $(nombre, tipo_pelaje, envergadura)$.
        \item $Ave.\_\_init\_\_ (siguiente en el MRO)$: Recibe los 3 argumentos. Toma envergadura y llama a $super().\_\_init\_\_$ con los 2 restantes $(nombre, tipo\_pelaje)$.
        \item $Mamifero.\_\_init\_\_ (siguiente en el MRO)$: Recibe los 2 argumentos. Toma tipo_pelaje y llama a super().__init__ con el último que queda (nombre).
        \item $SerVivo.\_\_init\_\_ (último en el MRO con __init__ personalizado)$: Recibe el argumento nombre. Lo toma y llama a $super().\_\_init\_\_()$ sin argumentos.
        \item $object.\_\_init\_\_$: Finalmente, se llama al inicializador de la clase \textit{object} base, que no toma argumentos, y la cadena termina limpiamente.
    \end{itemize}
El uso de * \footnote{* por sí solo sirve para indicar que todos los parámetros que vienen después de él deben ser especificados usando su nombre (como argumentos de palabra clave) y no por su posición. Pensemos en el * como una barrera que separa los argumentos posicionales (a la izquierda) de los argumentos que son exclusivamente de palabra clave (a la derecha).} en la definición $(def \_\_init\_\_(self, *, nombre, **kwargs))$ fuerza a que nombre sea un argumento de palabra clave (\textit{keyword-only} argument), lo cual hace el código más robusto y legible.




%comparacion con tecnica directa
\textbf{Simplicidad Aparente vs. Robustez Real}

Al trabajar con herencia múltiple en Python, surge la pregunta de cómo inicializar las clases base desde una clase derivada. A primera vista, llamar directamente al inicializador de cada clase padre, como \mintinline{python}{Base1.__init__(self, ...)}, puede parecer más simple y directo. Sin embargo, esta simplicidad es engañosa y, a menudo, conduce a un código más frágil y difícil de mantener, especialmente en sistemas complejos.

El enfoque de llamada directa es \textbf{imperativo}: le indicamos a Python exactamente qué hacer y en qué orden. En contraste, el enfoque con \mintinline{python}{super()} es \textbf{cooperativo}: cada clase en la jerarquía confía en la siguiente de la cadena para que realice su parte correspondiente.

\section{Comparativa de Enfoques}

La siguiente tabla resume las diferencias fundamentales entre ambos métodos:

\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|>{\bfseries}p{0.2\textwidth}|p{0.35\textwidth}|p{0.35\textwidth}|}
\hline
\textbf{Característica} & \textbf{Llamada Directa (\mintinline{python}{Base.__init__})} & \textbf{\mintinline{python}{super()} Cooperativo} \\
\hline
\hline
\textbf{Simplicidad Inicial} & \textbf{Alta}. Es muy obvio lo que se está llamando. & \textbf{Moderada}. Requiere entender el patrón \mintinline{python}{**kwargs} y el MRO (Method Resolution Order). \\
\hline
\textbf{Problema del Diamante} & \textbf{No lo resuelve} \⚠️. Causa ejecuciones duplicadas del inicializador "abuelo". & \textbf{Lo resuelve} \✅. Garantiza que cada inicializador en la jerarquía se ejecute solo una vez. \\
\hline
\textbf{Mantenibilidad} & \textbf{Muy Baja}. Si la jerarquía de clases cambia, se debe reescribir el \mintinline{python}{__init__} de la clase hija. El código es frágil. & \textbf{Muy Alta}. La jerarquía puede cambiar. Mientras se respete el patrón \mintinline{python}{super()}, el código se adapta automáticamente. \\
\hline
\textbf{Acoplamiento} & \textbf{Alto}. La clase hija necesita conocer toda la estructura de herencia de sus padres para pasar los parámetros correctos. & \textbf{Bajo}. Cada clase solo necesita saber de sí misma. Toma sus argumentos y pasa el resto. No le importa quién es el siguiente. \\
\hline
\end{tabular}
\caption{Comparación entre llamada directa y \texttt{super()} cooperativo.}
\end{table}

\section{El Problema de la Responsabilidad}

Consideremos una jerarquía de clases donde \texttt{Murcielago} hereda de \texttt{Ave} y \texttt{Mamifero}, y ambas heredan de \texttt{SerVivo}. Si usamos la llamada directa, la clase \texttt{Murcielago} asume demasiada responsabilidad.

\subsection{Enfoque Frágil con Llamada Directa}

\begin{minted}[frame=single, framesep=5pt, linenos]{python}
class Murcielago(Ave, Mamifero):
    def __init__(self, nombre, tipo_pelaje, envergadura, habilidad_ecolocalizacion):
        # La clase Murcielago debe saber qué parámetros necesita cada padre.
        Ave.__init__(self, nombre=nombre, envergadura=envergadura)
        Mamifero.__init__(self, nombre=nombre, tipo_pelaje=tipo_pelaje)
        
        self.habilidad_ecolocalizacion = habilidad_ecolocalizacion
\end{minted}

Los problemas con este enfoque son:
\begin{enumerate}
    \item \textbf{Conocimiento Excesivo}: \texttt{Murcielago} está forzado a saber que tanto \texttt{Ave} como \texttt{Mamifero} necesitan el parámetro \texttt{nombre} para pasárselo a \texttt{SerVivo}. Si la estructura de herencia cambia, el código se rompe.
    \item \textbf{Duplicación de Lógica}: El método \mintinline{python}{SerVivo.__init__} se ejecuta dos veces, lo cual es ineficiente y puede causar errores.
\end{enumerate}

\textbf{Enfoque Robusto con \texttt{super()}}

Con \mintinline{python}{super()}, la responsabilidad se distribuye correctamente, siguiendo el principio de bajo acoplamiento.

\begin{minted}[frame=single, framesep=5pt, linenos]{python}
class Murcielago(Ave, Mamifero):
    def __init__(self, **kwargs):
        # Murcielago solo se preocupa por sus propios asuntos.
        # Pasa el resto de responsabilidades al siguiente en la cadena.
        super().__init__(**kwargs)
        # ...lógica específica de Murciélago...
\end{minted}

Este diseño sigue un principio clave de la POO: una clase no debería necesitar conocer los detalles internos de la implementación de sus padres.

Especificar cada inicializador es como darle a un taxista una lista de instrucciones detalladas para un viaje. Funciona para esa ruta específica, pero falla ante cualquier imprevisto. Usar \mintinline{python}{super()} es como darle la dirección final; el conductor (el MRO de Python) sabe cómo navegar de la manera más eficiente.

Aunque la llamada directa \textbf{parece más simple}, es una simplicidad que crea código rígido y propenso a errores. El modelo cooperativo de \mintinline{python}{super()} es la base para construir sistemas flexibles y mantenibles en Python.



\fi
%%%%%%%%%%
% ADVANCED_END
%%%%%%%%%%



\subsubsection{Comentarios finales sobre herencia múltiple en Python}
\begin{enumerate}
    \item \textbf{Inicialización redundante}:  En casos de herencia múltiple, atributos como `nombre` y `edad` pueden inicializarse más de una vez. Por ejemplo, en la clase `EstProf`, estos atributos se inicializan tanto en `EstudiantePosgrado` como en `Profesor`. Aunque esto no genera problemas en este caso porque los valores son idénticos, es importante tener cuidado en jerarquías más complejas donde los valores podrían diferir o causar inconsistencias.
    \item \textbf{Orden de resolución de métodos (MRO)}:  Python utiliza un mecanismo llamado \textit{Method Resolution Order} (MRO) para determinar el orden en el que busca métodos y atributos en la jerarquía de clases. Puedes verificar el MRO de una clase ejecutando el siguiente comando:  $<clase>.mro()$ .   Esto mostrará el orden en el que Python recorrerá las clases cuando se invoquen métodos o inicializadores.
    \item \textbf{Evitar \textit{super()} en herencia diamante}. En estructuras de herencia diamante (donde una clase hereda de dos clases que comparten un ancestro común), el uso de \textit{super()} puede no ser la mejor opción, ya que podría omitir la inicialización completa de ciertas clases. En estos casos, es más confiable llamar explícitamente a los inicializadores de los padres involucrados para asegurar que todos los atributos y métodos se configuren correctamente.   Sin embargo, llamar directamente a los inicializadores de clases base, puede llevar a la redundancia de inicialización de atributos y además a posibles errores de inicialización. En este caso se sugiere \textbf{rediseñar la inicialización }para que los atributos compartidos solo se inicialicen una vez, preferiblemente en la clase base más general. Las clases derivadas pueden encargarse de inicializar únicamente los atributos específicos que les corresponden.
\end{enumerate}






  
\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala
\newpage

\section{Herencia: Implementación en Scala}

En su forma más simple, la herencia en Scala se maneja de una forma bastante similar a Java\footnote{ \href{http://www.javabeat.net/inheritance-overriding-scala/}{Inheritance and Overriding in Scala}}.
	 
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{scala}
class <Derivada> extends <Base> {
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}	 

Solamente recordar que es posible definir los atributos como parámetro de las clases -polimórfica- (base y derivada) definiendo al mismo tiempo el constructor primario.


\subsection{Inicializadores de superclase}	

La inicialización de superclase  se hace en el momento de definir la herencia en la subclase. Los constructores auxiliares no pueden invocar directamente a constructores de la superclase; sólo pueden invocar al constructor primario de su clase quien a su vez invocará al constructor de la superclase.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
//ejemplo de herencia
class Vehiculo(var ruedas: Int, var pasajeros: Int){

   def setRuedas(num: Int){
                ruedas=num
   }

   def getRuedas(): Int= ruedas

   def setPasajeros(num: Int){
             pasajeros=num
   }

   def getPasajeros(): Int={
               return pasajeros
     }
}

//clase Camion con herencia  de Vehiculo
class Camion(ruedas: Int, pasajeros: Int, var carga: Int) 
  extends Vehiculo(ruedas, pasajeros) {

   def this() = this(0, 0, 0)

   def setCarga(num: Int){
         carga=num
   }

   def getCarga(): Int =  carga

   def muestra(){
          // uso de métodos heredados
             println("Ruedas: " + getRuedas());
              println("Pasajeros: " + getPasajeros());
                // método de la clase Camion
            println("Capacidad de carga: " + getCarga());
   }
}

object Main extends App {
   val ford: Camion = new Camion()
   ford.setRuedas(6)
   ford.setPasajeros(3)
   ford.setCarga(3200)
   ford.muestra()
}
\end{minted}
\caption{Ejemplo.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Redefinición de métodos}	

Comparado con Java, Scala añade unas restricciones para redefinir un método. El método redefinido debe usar el modificador \textit{override} (existe una anotación $@Override$ en Java, pero no es obligatoria). Adicionalmente, no se puede redefinir un \textit{var} con \textit{val} o \textit{def}. Pero puede redefinirse si en la superclase es abstracta. Un \textit{val} no puede ser redefinido por un \textit{var} o \textit{def} en una subclase.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Elemento(var precio:Double, var descripcion:String){
	//Sin descuento para el elemento
	def precioDescuento():Double = precio

	override def toString():String = {
		descripcion+" Costo: "+precioDescuento()
	}
}

class ElementoEspecial(precio:Double, descripcion:String, 
		var porcentajeDescuento:Double)
		extends Elemento(precio, descripcion){

	//Precio con descuento
	override def precioDescuento():Double = {
		precio - ((porcentajeDescuento/100) * precio)
	}
}

object Main extends App{
	val elem = new Elemento(335.65,"Libro,")
	println(elem)
	
	val elementoEspecialspecial = new ElementoEspecial(456.7,
	  "Un libro especial", 10)
	println(elementoEspecialspecial)
	
}
\end{minted}
\caption{Ejemplo de redefinición de métodos en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Empleado(var firstName: String, var lastName: String){
   	override def toString():String = 
               firstName+" "+lastName

	def print() {
           println(toString())
    }
}

class TrabajadorPorHora(firstName: String, lastName: String, 
                var wage: Float, var hours: Float)
              extends Empleado(firstName, lastName){

 	def getPay(): Float = wage * hours

    override def print() {
          println("Metodo print de Trabajador por hora")
          super.print()   // llama a función de clase base
          println(" es un trabajador por hora con sueldo de" + " $" + getPay())
    }
}

object Main extends App{
     val e = new Empleado("nombre", "apellido")
      val h = new TrabajadorPorHora ("Juanito", "Perez", 40.0f, 7.50f)

       e.print()
       h.print
}
\end{minted}
\caption{Ejemplo 2 de redefinición de métodos en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Traits \& Mixins en Scala}


Los \textit{traits} (rasgos), son un tipo abstracto utilizado en OOP. Un trait representa un conjunto de métodos que son usados para extender la funcionalidad de una clase. Los \textit{traits} son similares a los \textit{mixins}, y también pueden incluir definiciones para métodos de clase. Los \textit{traits} son una forma simple para reuso de comportamiento para los componentes de software. A diferencia de Java, Scala permite tener \textit{traits} parcialmente implementados (tener implementaciones para algunos métodos). Los \textit{traits} no pueden instanciarse y no tienen parámetros de constructor.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{scala}
trait <nombre> {
   def <método 1>(<parámetros>) : <tipo> [<implementación>]
   def <método 2>(<parámetros>) : <tipo> [<implementación>]
   … 
   def <método n>(<parámetros>) : <tipo> [<implementación>]
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

La clases que integren \textit{traits} deben implementar los  métodos que no se encuentren implementados. Los métodos implementados se heredan directamente. 

La clase \textit{Any} es la clase raíz de la jerarquía en Scala\footnote{ \href{http://www.scala-lang.org/api/2.7.2/scala/Any.html}{Class Any}}.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
trait Similar {
  def esSimilar(x: Any): Boolean
  def noEsSimilar(x: Any): Boolean = !esSimilar(x)
}

class Punto(xc: Int, yc: Int) extends Similar {
  var x: Int = xc
  var y: Int = yc
  def esSimilar(obj: Any) =
    obj.isInstanceOf[Punto] &&
    obj.asInstanceOf[Punto].x == x
}

object Main extends App {
  val p1 = new Punto(2, 3)
  val p2 = new Punto(2, 4)
  val p3 = new Punto(3, 3)
  println(p1.noEsSimilar(p2))
  println(p1.noEsSimilar(p3))
  println(p1.noEsSimilar(2))
}
\end{minted}
\caption{Ejemplo de mixins en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Una clase puede usar \textit{extends} para heredar un \textit{trait} sólo si no hereda ya de una clase base. Si ya se hereda de una clase o se quiere heredar más \textit{traits} se usa la palabra clave \textit{with}.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Base1(x: Int) {
  var value: Int = x
 //conflicto de miembros en clase derivada 
 //def getData() = value
 def getValue() = value
}

trait MiTrait {
  var letter: Char
  def setData(c: Char)
  def getData(): Char = letter
}

class Derivada(x:Int, c:Char, r: Float) extends Base1(x) with MiTrait {
  var real: Float = r
  var letter= c
  def setData(c: Char) {
         letter=c
  }
  def getReal(): Float = real 
}

object Main extends App {
  val b1 = new Base1(10)
  val d = new Derivada(7, 'A', 3.5f)
  println("Objeto b1 contiene entero " + b1.getValue())
  println("Objeto d contiene " + d.getData())
}
\end{minted}
\caption{Ejemplo mixins usando \textit{with} en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%

%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp
\newpage
\section{Herencia: Implementación en C\#}

C\# permite la herencia simple entre clases heredando de una clase base a una clase derivada.

La sintaxis de la herencia en C\# es similar a la implementación básica en C++.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{csharp}
class <claseDerivada> : <claseBase> {
	//cuerpo subclase
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System;

//ejemplo de herencia
public class Vehiculo{
	private int ruedas;
	private int pasajeros;

	public void setRuedas(int num){
		ruedas=num;
	}

	public int getRuedas(){
	return ruedas;
	}

	public void setPasajeros(int num){
	pasajeros=num;
	}

	public int getPasajeros(){
	return pasajeros;
	}
}

//clase Camion con herencia de Vehiculo
public class Camion : Vehiculo {
	private int carga;

	public void setCarga(int num){
		carga=num;
	}

	public int getCarga(){
		return carga;
	}

	public void muestra(){
		// uso de métodos heredados
		Console.WriteLine("Ruedas: " + getRuedas());
		Console.WriteLine("Pasajeros: " + getPasajeros());
		// método de la clase Camion
		Console.WriteLine("Capacidad de carga: " + getCarga());
	}

	public static void Main(){
		Camion ford= new Camion();
		ford.setRuedas(6);
		ford.setPasajeros(3);
		ford.setCarga(3200);
		ford.muestra();
	}
}
\end{minted}
\caption{Ejemplo de herencia en C\#.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Acceso a miembros}

Un miembro privado de una clase permanecerá privado a su clase. No será accesible fuera de la clase, incluidas sus clases derivadas. Un miembro privado tendrá que ser accedido mediante un método público o protegido.

\subsection{Constructores de clase base}

Como en otros lenguajes, el constructor de la clase base puede ser llamado desde la clase derivada, para inicializar los atributos heredados.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{csharp}| <constructor>(<lista de argumentos>) : base(<argumentos sin el tipo>)  |\\
\hline
\end{tabular}
\end{center}

\subsection{Interfaces en C\#}

C\#  cuenta con manejo de interfaces de una manera similar a Java.

	Una interfaz tiene un formato muy similar a una clase, sus principales características:


\begin{itemize}
\item Una interfaz proporciona los nombres de los métodos, pero no sus implementaciónes.
\item Una clase puede implementar varias interfaces, aunque solo pueda heredar una clase.
\item No es posible crear instancias de una interfaz.
\item La clase que implementa la interfaz debe escribir el código de todos los métodos, de otra forma no se podrá generar instancias de esa clase.
\end{itemize}

El formato general para la declaración de una interfaz es el siguiente:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{csharp}
[public] interface <nombreInterfaz> {
	//descripción de miembros
	//los métodos no incluyen código:
	<acceso> <tipo> <nombreMetodo> ( <parámetros> ) ;
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

El cuerpo de la interfaz generalmente es una lista de prototipos de métodos, pero puede contener atributos si se requiere.

	Una clase implementa una o más interfaces de la siguiente forma:
	
% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{csharp}
class <claseDerivada> : <claseBase> ,   <nombreInterfaz> [, ... <interfazN>] {
	//definición de la clase
	//debe incluirse la definición de los métodos de la interfaz
	//con la implementación del código de dichos métodos.
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}	

Además, una interfaz puede ser extendida de la misma forma que una clase, aprovechando las interfaces previamente definidas:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{csharp}
[public] interface <nombreInterfaz> : <InterfazBase> {
	//descripción de miembros
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {csharp}
using System;

//interfaz
interface IStack { 
	void push(Object item);
	Object pop();
}

//clase implementa la interfaz
class StackImpl : IStack { 
	protected Object[] stackArray;
	protected int tos;

	public StackImpl(int capacity) {
		stackArray = new Object[capacity];
		tos = -1;
	}

	//implementa el método definido en la interfaz
	public void push(Object item) 
		{ stackArray[++tos] = item; }

	//implementa el método definido en la interfaz
	public Object pop() { 
		Object objRef = stackArray[tos];
		stackArray[tos] = null;
		tos--;
		return objRef;
	}

	public Object peek() { return stackArray[tos];}
}

// extendiendo una interfaz
interface ISafeStack : IStack { 
	bool isEmpty();
	bool isFull();
}

//esta clase hereda la implementación de la pila StackImpl
// e implementa la nueva interfaz extendida ISafeStack
class SafeStackImpl : StackImpl, ISafeStack { 

	public SafeStackImpl(int capacity):base(capacity) { }

	//implementa los métodos de la interfaz
	public bool isEmpty() { return tos < 0; } 
	public bool isFull() { return tos >= stackArray.Length;
	} 
}

public class StackUser {

	public static void Main() { 
		SafeStackImpl safeStackRef = new SafeStackImpl(10);
		StackImpl stackRef = safeStackRef;
		ISafeStack isafeStackRef = safeStackRef;
		IStack istackRef = safeStackRef;
		Object objRef = safeStackRef;

		safeStackRef.push("Dolar"); 
		stackRef.push("Peso");
		Console.WriteLine(isafeStackRef.pop());
		Console.WriteLine(istackRef.pop());

		Console.WriteLine(objRef.GetType());
	}
}
\end{minted}
\caption{Ejemplo de interfaces en C\#.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

	
\fi
%%%%%%

%%%%
% CSHARP_END
%%%%%%%%%%



%%%%%%%%%%
% D
%%%%%%%%%%
\ifd
\newpage
\section{Herencia: Implementación en D}

D permite la herencia simple entre clases heredando de una clase base a una clase derivada.

Así como en C\#, la sintaxis de la herencia en D es similar a la implementación básica en C++.

Como en otros lenguajes (e.g., Java, C\#), todas las clases heredan directa o indirectamente de la clase \textit{Object}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
class <claseDerivada> : <claseBase> {
	//cuerpo claseDerivada
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Vehiculo;

import std.stdio;

//ejemplo de herencia
class Vehiculo{
	private:
	int ruedas;
	int pasajeros;

	public:
	void setRuedas(int num){
		ruedas=num;
	}

	int getRuedas(){
		return ruedas;
	}

	void setPasajeros(int num){
		pasajeros=num;
	}

	int getPasajeros(){
		return pasajeros;
	}
}

//clase Camion con herencia de Vehiculo
class Camion : Vehiculo {
	private: 
	int carga;

	public:
	void setCarga(int num){
		carga=num;
	}

	int getCarga(){
		return carga;
	}

	void muestra(){
		// uso de metodos heredados
		writeln("Ruedas: ", getRuedas());
		writeln("Pasajeros: ", getPasajeros());
		// metodo de la clase Camion
		writeln("Capacidad de carga: ", getCarga());
	}
}

void main(){
	Camion ford= new Camion();
	ford.setRuedas(6);
	ford.setPasajeros(3);
	ford.setCarga(3200);
	ford.muestra();
}
\end{minted}
\caption{Ejemplo de herencia en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Acceso a miembros}

En D existen los modificadores de acceso \textit{private}, \textit{package}, \textit{protected}, \textit{public} y \textit{export}\footnote{Classes, \url{http://dlang.org/spec/class.html}}.


\begin{itemize}
\item \textit{private}. Un miembro privado implica que únicamente miembros de la clase o miembros y funciones del módulo de la clase pueden acceder a ellos. Miembros privados no pueden ser redefinidos.
\item \textit{package}. El modificador \textit{package} extiende la privacidad de manera que estos miembros pueden ser accedidos por otros módulos en el mismo paquete.
\item \textit{protected}. Un miembro protegido miembros de su clase, clase derivada o miembros y funciones en el mismo módulo pueden acceder a dicho miembro.
\item \textit{public}. Un miembro público puede ser accedido donde el miembro sea visible.
\item \textit{export}. El modificador \textit{export} implica que cualquier código fuera del ejecutable al que pertenece puede acceder a éste. Es análogo a la definición de exportación para DLLs.
\end{itemize}

\subsection{Constructores de clase base}

Como en otros lenguajes, el constructor de la clase base puede ser llamado desde la clase derivada, para inicializar los atributos heredados.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
this<lista de argumentos>) {
   ...  
   super(<lista de argumentos sin el tipo>)
   ... 
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\subsection{Interfaces en D}

	D  cuenta con manejo de interfaces de una manera similar a Java y C\#.

	Una interfaz tiene un formato muy similar a una clase, sus principales características:

  
\begin{itemize}
\item Una interfaz proporciona los nombres de los métodos, pero no sus implementaciones.
\item Una clase puede implementar varias interfaces, aunque solo pueda heredar una clase.
\item No es posible crear instancias de una interfaz.
\item Métodos \textbf{estáticos} y \textbf{finales} deben llevar su implementación. Las clases no pueden redefinir estos tipos de miembros.
\item La clase que implementa la interfaz debe escribir el código de todos los métodos, de otra forma no se generará un error. 
\item Una interfaz no puede tener atributos.
\end{itemize}
      
El formato general para la declaración de una interfaz es el siguiente\footnote{ \href{http://dlang.org/spec/interface.html},{Interface}}:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
interface <nombreInterfaz> {
	//descripción de miembros
	//los métodos no incluyen código:
	<acceso> <tipo> <nombreMetodo> ( <parámetros> ) ;
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Una clase hereda una interfaz a través de la misma forma que hereda de una clase:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
class <clase> : <nombreInterfaz> {
	//definición de la clase
	//debe incluirse la definición de los métodos de la interfaz
	//con la implementación del código de dichos métodos.
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

De hecho, si la clase hereda una previa implementación de una interfaz pero también hereda la interfaz directamente, esta clase esta obligada a reimplementar la interfaz.

Ejemplo:
\begin{minted}{d}
interface D {
    int foo();
}

class A : D {
    int foo() { return 1; }
}

class B : A, D{
}       // error, no se reimplementó foo() para la interfaz D
\end{minted}

Además, una interfaz puede ser extendida de la misma forma que una clase, aprovechando las interfaces previamente definidas.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{d}
interface <nombreInterfaz> : <InterfazBase> {
	//descripción de miembros
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
module Stack;
import std.stdio;

//interfaz
interface IStack { 
	void push(Object item);
	Object pop();
}

//clase implementa la interfaz
class StackImpl : IStack { 
	protected:
   	Object[] stackArray;
    int tos;
   	public: 
    this(int capacity) {
    		stackArray = new Object[capacity];
      	tos = -1;
  	}

  	//implementa el metodo definido en la interfaz
	void push(Object item) 
	{ stackArray[++tos] = item; }

  	//implementa el metodo definido en la interfaz
  	Object pop() { 
    		Object objRef = stackArray[tos];
     	stackArray[tos] = null;
      	tos--;
      	return objRef;
  	}

 	Object peek() { return stackArray[tos];}
}

// extendiendo una interfaz
interface ISafeStack : IStack { 
	bool isEmpty();
 	bool isFull();
}

//esta clase hereda la implementacion de la pila StackImpl
// e implementa la nueva interfaz extendida ISafeStack
class SafeStackImpl : StackImpl, ISafeStack { 
	public: 
  	this(int capacity){super(capacity); }
  	//implementa los metodos de la interfaz
 	bool isEmpty() { return tos < 0; } 
  	bool isFull() { return tos >= stackArray.length;} 
}

class String{
    public:
    string myString;
    this(string s) {
        myString=s;
    }
}

void main() { 
	SafeStackImpl safeStackRef = new SafeStackImpl(10);
  	StackImpl stackRef = safeStackRef;
   	ISafeStack isafeStackRef = safeStackRef;
  	IStack istackRef = safeStackRef;
   	Object objRef = safeStackRef;
    //safeStackRef.push("dolar");   // strings no son objetos 
   	safeStackRef.push(new String("dolar"));
    	stackRef.push(new String("Peso"));
  	String s =cast(String) isafeStackRef.pop();
 	writeln(s.myString);
   	s =cast(String) istackRef.pop();
  	writeln(s.myString);
  	writeln(objRef.toString());
}
\end{minted}
\caption{Ejemplo de interfaces en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Traits y Mixins en D}

\textit{Traits} y \textit{mixins}  no van por el sentido del uso de la jerarquía de herencia, pero los mencionamos aquí para evitar confusión al respecto.

Los \textit{traits}  en D son extensiones  para permitir que los programas, en tiempo de compilación, obtengan información general para el compilador. Esto es también conocido como reflexión (\textit{reflection}) en tiempo de compilación.

Los \textit{mixins} en D permiten a unas cadenas constantes ser compiladas como código regular e insertado en el programa. De manera superficial, el concepto  es similar a las propiedades que realiza el preprocesador de C.

\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%

\chapter{Asociaciones entre clases}

\section{Introducción}

Una clase puede estar relacionada con otra clase, o en la práctica un objeto con otro objeto.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
 En el modelado de objetos a la relación entre clases se le conoce como \textbf{asociación}; mientras que a la relación entre objetos se llama instancia de una asociación. 
\\ \hline
\end{tabular}
\end{center}

Ejemplo:

\textit{Una clase \textbf{Estudiante} está asociada con una clase \textbf{Universidad}.
}
Una asociación es una \textbf{conexión} física o conceptual entre objetos. Las relaciones\footnote{ El término de relación es usado muchas veces como sinónimo de asociación, debido a que el concepto surge de las relaciones en bases de datos relacionales. Sin embargo el término más apropiado es el de asociación, ya que existen en objetos otros tipos de relaciones, como la relación de agregación y la de herencia.} se consideran de naturaleza \textbf{bidireccional}; es decir, ambos lados de la asociación tienen acceso a clase del otro lado de la asociación. Sin embargo, algunas veces únicamente es necesaria una asociación en una dirección (unidireccional).

\begin{figure}
    \centering
    \includegraphics{imagenes/asociacion.png}
    \caption{Ejemplo de asociación en UML}
    \label{fig:my_label}
\end{figure}

Comúnmente las asociaciones se representan en los lenguajes de programación orientados a objetos como apuntadores o referencias. Donde un apuntador  a una clase B en una clase A indicaría la asociación que tiene A con B; aunque no así la asociación de B con A.

Para una asociación bidireccional es necesario al menos un par de apuntadores, uno en cada clase. Para una asociación unidireccional basta un solo apuntador en la clase que mantiene la referencia.

En el caso de las asociaciones se asumirá que cada objeto puede seguir existiendo de manera independiente, a menos que haya sido creado por el objeto  de la clase asociada, en cuyo caso deberá ser eliminado por el destructor del objeto que la creó. Es decir:
	
% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Explicación} 
\end{center} 
\\ \hline
 Si el objeto \textbf{A} crea al objeto \textbf{B}, es responsabilidad de \textbf{A} eliminar a la instancia \textbf{B} antes de que \textbf{A} sea eliminada. En caso contrario, si \textbf{B} es independiente de la instancia \textbf{A}, \textbf{A} debería enviar un mensaje al objeto \textbf{B} para que asigne \textit{NULL} al apuntador de \textbf{B} o para que tome una medida pertinente, de manera que no quede apuntando a una dirección inválida.
\\ \hline
\end{tabular}
\end{center}


Es importante señalar que las medidas que se tomen pueden variar de acuerdo a las necesidades de la aplicación, pero bajo ningún motivo se deben dejar accesos a áreas de memoria no permitidas o dejar objetos "volando", sin que nadie haga referencia a ellos.

Mencionamos a continuación estructuras clásicas que pueden ser vistas como una asociación:

    
\begin{enumerate}
\item Ejemplo de asociación \textbf{unidireccional}: lista ligada.
\item Ejemplo de asociación \textbf{bidireccional}: lista doblemente ligada.
\end{enumerate}

\section{Asociaciones reflexivas }

Es posible tener un tipo de asociación conocida como asociación \textbf{reflexiva}.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
Si una clase mantiene una asociación consigo misma se dice que es una \textbf{asociación reflexiva}.    
\\ \hline
\end{tabular}
\end{center}

Ejemplo: \textit{Persona} puede tener asociaciones entre sí, si lo que nos interesa es representar a las personas que guardan una relación entre sí, por ejemplo si son parientes. Es decir, un objeto mantiene una asociación con otro objeto de la misma clase.

\begin{figure}
    \centering
    \includegraphics{imagenes/asociacion_Reflexiva.png}
    \caption{Asociación reflexiva}
    \label{fig:my_label}
\end{figure}

En términos de implementación significa que la clase tiene una referencia a si misma. De nuevo podemos poner de ejemplo a la clase Nodo en una lista ligada.

\section{Multiplicidad de una asociación}

La \textbf{multiplicidad} de una asociación especifica cuantas instancias de una clase se pueden asociar a una sola instancia de otra clase. 

Se debe determinar la multiplicidad para cada clase en una asociación.

\subsection{Tipos de asociaciones según su multiplicidad}

\textbf{''uno a uno''}: donde dos objetos se asocian de forma exclusiva, uno con el otro.
    Ejemplo: 
Uno: Un alumno tiene una boleta de calificaciones.
Uno: Una boleta de calificaciones pertenece a un alumno.

\textbf{''uno a muchos''}: donde uno de los objetos puede estar asociado con muchos otros objetos.
Ejemplo: 
Uno: un libro solo puede estar prestado a un alumno.
Muchos: Un usuario de la biblioteca puede tener muchos libros prestados.

\textbf{''muchos a muchos''}: donde cada objeto de cada clase puede estar asociado con muchos otros objetos.
Ejemplo: 
Muchos: Un libro puede tener varios autores. 
Muchos: Un autor puede tener varios libros.

Podemos apreciar en un diagrama las diversas multiplicidades:

\begin{figure}
    \centering
    \includegraphics{imagenes/multiplicidad.png}
    \caption{Ejemplo de multiplicidad}
    \label{fig:my_label}
\end{figure}

Finalmente, es importante señalar que el control de las asociaciones no se encuentra en general apoyado por los lenguajes de programación, a pesar de ser una necesidad natural en el modelado orientado a objetos, por lo que toda la responsabilidad recae sobre el programador.

	
%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Asociaciones en C++}

Ejemplo: un programa que guarda una asociación bidireccional entre clases A y B.

\begin{minted}{cpp}
class A{
	//lista de atributos

	B	*pB;
};

class B{
	//lista de atributos
	A	*pA;
};
\end{minted}

En el ejemplo anterior se presenta una asociación bidireccional, por lo que cada clase tiene su respectivo apuntador a la clase contraria de la asociación. Además, deben proporcionarse métodos de acceso a la clase asociada por medio del apuntador. 

\subsection{Multiplicidad de una asociacion en C++}

La forma de implementar en C++ este tipo de relaciones puede variar, pero la más común es por medio de apuntadores a objetos. Suponiendo que tenemos asociaciones bidireccionales: 

\begin{itemize}
\item \textbf{''uno a uno''}. Un apuntador de cada lado de la asociación, como se ha visto anteriormente.
\item \textbf{''uno a muchos''}. Un apuntador de un lado y un arreglo de apuntadores a objetos definido dinámica o estáticamente.
\end{itemize}

\begin{minted}{cpp}
class A{
	...
	B *pB;
};

class B{
	A *p[5];  
//ó 
A **p;
}
\end{minted}

Otra forma es manejar una clase que agrupe a pares de direcciones en un objeto independiente de la clase. Por ejemplo una lista o tabla de referencias.
	
\begin{figure}
    \centering
    \includegraphics{imagenes/muchos.png}
    \caption{Implementación de multiplicidad mediante tabla de referencias}
    \label{fig:my_label}
\end{figure}	


\begin{itemize}
\item \textbf{''muchos a muchos''}.  Normalmente se utiliza un objeto u objetos independientes que mantiene las asociaciones entre los objetos, de manera similar a la gráfica anterior.
\end{itemize}


Ejemplo:
Se muestra un código simplificado para manejo de asociaciones.

\textbf{Clase Libro}
\begin{minted}{cpp}
#ifndef LIBRO_H_
#define LIBRO_H_

class Persona;

class Libro {
	public:
	char nombre[10];
	Persona *pPersona;

	Libro();
	~Libro();
};

#endif /*LIBRO_H_*/


#include <iostream>
#include "Persona.h"
#include "Libro.h"

Libro::Libro(){
	nombre[0]='\0';
	pPersona=NULL;
}

Libro::~Libro(){ 
	if(pPersona!=NULL)
	for(int i=0; i<5; i++)
		if (pPersona->pLibrosPres[i]==this)
			pPersona->pLibrosPres[i]=NULL;

}
\end{minted}

\textbf{Clase Persona}
\begin{minted}{cpp}
#ifndef PERSONA_H_
#define PERSONA_H_

class Libro;

class Persona {
	public:
	Libro *pLibrosPres[5];

	Persona();
	~Persona();
};

#endif /*PERSONA_H_*/

#include <iostream>
#include "Libro.h"
#include "Persona.h"

Persona::Persona(){
	int i;

	for(i=0; i<5; i++)
		pLibrosPres[i]=NULL;
}

Persona::~Persona(){
		int i;
	for(i=0; i<5; i++)
		if(pLibrosPres[i]!=NULL)
			  pLibrosPres[i]->pPersona=NULL;  
}
\end{minted}
\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%

	
%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Asociaciones en Java}

Como en Java el manejo de objetos es mediante referencias, la implementación de la asociación se simplifica en la medida que la sintaxis de Java es más simple.

Ejemplo: un código que guarda una asociación bidireccional entre clases A y B.

\begin{minted}{java}
class A{
	//lista de atributos

	B	pB;
}

class B{
	//lista de atributos
	A	pA;
}
\end{minted}

	En el ejemplo anterior se presenta una relación bidireccional, por lo que cada clase tiene su respectiva referencia a la clase contraria de la relación. Además, deben proporcionarse métodos de acceso a la clase relacionada por medio de la referencia. 

	Una asociación unidireccional del ejemplo anterior sería más simple. Veamos el código si se requiere únicamente una relación de A a B.
	

Ejemplo:

\begin{minted}{java}
class A{
	//lista de atributos
	B	pB;
}

class B{
	//lista de atributos
}
\end{minted}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Recordar} 
\end{center} 
\\ \hline
  Si el objeto \textbf{A} crea al objeto \textbf{B}, es responsabilidad de \textbf{A} eliminar a la instancia \textbf{B} antes de que \textbf{A} sea eliminada. En caso contrario, si \textbf{B} es independiente de la instancia \textbf{A}, \textbf{A} debería enviar un mensaje al objeto \textbf{B} para que asigne \textit{null} al apuntador de \textbf{B} o para que tome una medida pertinente, de manera que no quede apuntando a una dirección inválida.
\\ \hline
\end{tabular}
\end{center}

En Java, ya que cuenta con un recolector de basura, la importancia radicaría en asegurarnos de  no mantener enlaces a objetos que ya no son necesarios.

\subsection{Multiplicidad de una asociación en Java}

La forma de implementar en Java este tipo de relaciones puede variar, pero la más común es por medio de referencias a objetos. Suponiendo que tenemos relaciones bidireccionales: 


\begin{itemize}
\item \textbf{''uno a uno''}. Una referencia de cada lado de la relación, como se ha visto anteriormente.
\item \textbf{''uno a muchos''}. Una referencia de un lado y un arreglo de referencias a objetos del otro lado.
\end{itemize}

\begin{minted}{java}
class A{
	...
	B pB;
}
class B{
	A p[];  
}
\end{minted}

Al igual que en C++, es posible manejar una clase independiente que agrupe a pares de direcciones en un objeto independiente de la clase\footnote{Ver figura en tema correspondiente de C++}. Por ejemplo, en una estructura de lista.

\begin{itemize}
\item \textbf{''muchos a muchos''}.  Normalmente se utiliza un objeto u objetos independientes que mantiene las relaciones entre los objetos, de manera similar a la solución descrita en el punto anterior.
\end{itemize}

Ejemplo:
Se muestra un código simplificado para manejo de asociaciones.

\begin{minted}{java}
//clase Libro
class Libro {
	private String nombreLibro;
	public Alumno pAlumno;

	public Libro(){
		//al momento de crearse la instancia, no existe
		// relación con ningún Alumno
		pAlumno=null;
	}

	protected void finalize(){
		//si es diferente de null, el libro está
		//asignado a algún Alumno
		if(pAlumno!=null)
			//busca la referencia de Alumno a 
			//Libro para ponerla en null
			for(int i=0; i<5; i++)
				if (pAlumno.pLibrosPres[i]==this)
					pAlumno.pLibrosPres[i]=null;
	}
}

//clase Alumno
class Alumno {
	public Libro pLibrosPres[];
	public Alumno(){
		int i;
		//se asume una multiplicidad de 5
		pLibrosPres = new Libro[5]
		for(i=0; i<5; i++)
			pLibrosPres[i]=null;
	}

	protected void finalize(){

		//pone en null todas las asociaciones de los Libros 
		// a su instancia de Alumno que se elimina
		for(int i=0; i<5; i++)
			if(pLibrosPres[i]!=null)
				pLibrosPres[i].pAlumno=null;
	}
}
\end{minted}

	Este es un ejemplo parcial de cómo se soluciona el manejo de asociaciones entre clases, ya que además se deben de agregar métodos para establecer y eliminar la asociación, en ambas clases si es una asociación bidireccional, o en una clase únicamente si se trata de una asociación unidireccional. Esos deben de ser los únicos métodos que tengan el control sobre los atributos que mantienen la asociación y no deberían ser manejados directamente, por lo que no deben ser públicos como aquí se presentaron.

	Una definición más completa - sin implementación - de la clase \textit{Libro} se aprecia a continuación:
	
\begin{minted}{java}
class Libro {
	private String nombreLibro;
	private String clave;
	public Alumno pAlumno;

	public Libro(){ 	}

	public Libro( Alumno pAlumno){ 	}

	public String getNombreLibro(){ 	}

	public void setNombreLibro(String n){	}

	public String getClave(){ 	}

	public void setClave(String cve){ 	}

	public boolean setAsociacion(Alumno pAlumno){ 	}

	public boolean unsetAsociacion(){ 	}

	public Alumno getAlumno(){	}

	protected finalize {}
}
\end{minted}

	Este sería un estilo más apropiado para el desarrollo de asociaciones, aunque existen otros más elaborados.
	
\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Asociaciones entre Clases en lenguajes dinámicos como Python o Ruby}

El manejo de asociaciones en Python o Ruby puede hacerse de forma similar a como se mencionó en Java. De hecho es todavía más simple la definición debido a que no es necesaria la declaración de tipos.

Ejemplo: un código en Ruby que guarda una asociación bidireccional entre clases A y B.

\begin{minted}{ruby}
class A
	#lista de atributos
	@pB
end

class B
	#lista de atributos
	@pA
end
\end{minted}

Veamos el código si se requiere únicamente una relación de A a B:

\begin{minted}{ruby}
class A
	#lista de atributos
	@pB
end

class B
	#lista de atributos
end
\end{minted}

\subsection{Multiplicidad de una asociación}

La forma de implementar en lenguajes dinámicos este tipo de relaciones puede variar, pero la más común es por medio de referencias a objetos, de forma similar a la usada en Java. 

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%


% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Actividad} 
\end{center} 
\\ \hline
\textbf{Ejercicio 1:}

Programa una lista ligada de enteros orientada a objetos. Desarrollarla con una clase \textit{Lista} que contenga al menos los métodos: 
\begin{itemize}
    \item insertaInicio(Nodo)
    \item insertaFinal(Nodo)
    \item eliminaInicio()
    \item eliminaFinal()
    \item recorreLista()
\end{itemize}

\textit{Lista} está asociada con la clase \textit{Nodo} en una asociación (de nombre \textit{primerNodo}) unidireccional hacia \textit{Nodo} con multiplicidad de 0 a 1.
La clase \textit{Nodo} contiene un atributo:
\begin{itemize}
    \item dato  - de tipo entero
\end{itemize}
y los métodos:
\begin{itemize}
    \item getDato()
    \item setDato(dato)
    \item getSiguiente()
    \item setSiguiente(Nodo sig)
\end{itemize}

El \textit{Nodo} mantiene una asociación reflexiva unidireccional con una multiplicidad de 0 a 1.
\\ \hline

\textbf{Ejercicio 2:} 
Crear una clase \textit{Alumno} que contiene un atributo \textit{matrícula}, \textit{grupo} y un objeto \textit{nombre}. Además mantiene una asociación bidireccional de ''uno a muchos'' con objetos de una clase \textit{Libro}. La clase \textit{Libro} contiene el \textit{nombre del libro}, \textit{edición}, \textit{año} y tiene un arreglo de 3 objetos de la clase \textit{Nombre} para identificar al autor.

El método \textit{prestamo()} establecería la asociación y el método \textit{devolución()} eliminaría la asociación entre un alumnos y un libro.

El código de prueba debe presentar un menú que permita establecer y deshacer asociaciones entre alumnos y libros. Un alumno puede tener hasta 3 libros prestados al mismo tiempo.
\\ \hline


\textbf{Ejercicio 3:} Modificar el ejercicio anterior y en lugar de que \textit{grupo} sea un atributo simple, deberá ser una clase \textit{Grupo} que contenga \textit{carrera}, el \textit{semestre} y que mantenga una relación con un máximo de 30 alumnos. Cuando se elimine al último alumno, el grupo debe desaparecer. 
\\ \hline
\end{tabular}

\end{center}


\chapter{Objetos compuestos}

Algunas veces una clase no puede modelar adecuadamente una entidad basándose únicamente en  tipos de datos simples. Los LPOO permiten a una clase \textbf{contener} objetos. Un objeto forma parte directamente de la clase en la que se encuentra declarado.  

El objeto compuesto es una especie de relación, pero con una asociación más fuerte con los objetos relacionados. A la noción de objeto \textbf{compuesto} se le conoce también como objeto \textbf{complejo} o \textbf{agregado}.  

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
\textbf{Rumbaugh} define a la agregación como \textit{''una forma fuerte de asociación, en la cual el objeto agregado está formado por componentes. Los componentes forman parte del agregado. El agregado, es un objeto extendido que se trata como una unidad en muchas operaciones, aún cuando conste físicamente de varios objetos menores.''\cite{rumbaugh1991object}}   
\\ \hline
\end{tabular}
\end{center}

	Ejemplo: Un automóvil se puede considerar ensamblado o agregado, donde el motor y la carrocería serian sus componentes.

El concepto de agregación puede ser relativo a la conceptualización que se tenga de los objetos que se quieran modelar. 

Dicho concepto implica obviamente cierta dependencia entre los objetos, por lo que hay que tener en cuenta que pasa con los objetos que son parte del objeto compuesto cuando éste último se destruye. En general tenemos dos opciones:


\begin{enumerate}
\item Cuando el objeto agregado se destruye, los objetos que lo componen no tienen necesariamente que ser destruidos.
\item Cuando el agregado es destruido también sus componentes se destruyen.
\end{enumerate}

	Un objeto que es parte de otro objeto, puede a su vez ser un objeto compuesto. De esta forma podemos tener múltiples niveles. Un objeto puede ser un \textbf{agregado recursivo}, es decir, tener un objeto de su misma clase. 

Ejemplo: Directorio de archivos.

%\begin{wrapfigure}{O}{0.05\textwidth}
%    \centering
%    \includegraphics[]{imagenes/Agregación directorio archivo.png}
%    \includegraphics[width=0.25\textwidth]{mesh}
%\end{wrapfigure}

	Sin embargo, la forma en que se implemente la agregación puede no permitir la agregación recursiva.


	
%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Objetos compuestos en C++}

Por el momento vamos a considerar la segunda opción mencionada anteriormente, por ser más fácil de implementar y porque es la acción natural de los objetos que se encuentran embebidos como un atributo más en una clase.

Ejemplo:
\begin{minted}{cpp}
class Nombre {
	private:
  	char paterno[20],
  	materno[20],
  	nom[15];
	public:
	set(char *, char*, char *);
	...
};

class Persona {
	private:
	int edad;
	Nombre nombrePersona;
	...
};
\end{minted}

	Al crear un objeto compuesto, cada uno de sus componentes es creado con sus respectivos constructores. Para inicializar esos objetos componentes tenemos dos opciones:


\begin{enumerate}
\item En el constructor del objeto compuesto llamar a los métodos \textit{set} correspondientes a la modificación de los atributos de los objetos componentes.
\item Pasar en el constructor del objeto compuesto los argumentos a los constructores de los objetos componentes.
\end{enumerate}

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
<clase>::<constructor>(<lista de argumentos>) 
   : <objeto componente 1>(<lista de argumentos sin el tipo>),...
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

donde la lista de argumentos del objeto compuesto debe incluir a los argumentos de los objetos componentes, para que puedan ser pasados en la creación del objeto.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Tema sugerido} 
\end{center} 
\\ \hline
Apéndice X: UMLGEC++ 
\\ \hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
#include <iostream>
#include <string.h>
using namespace std;

class Nombre {
	char *nombre, *paterno, *materno;
	public:
		Nombre(char *n, char *p, char*m){
			nombre=new char[strlen(n)+1];
			paterno=new char[strlen(p)+1];
			materno=new char[strlen(m)+1];
			strcpy(nombre, n);
			strcpy(paterno, p);
			strcpy(materno, m);
		}
		~Nombre(){
			cout<<"destructor de Nombre: "<<nombre<<endl;
			delete []nombre;
			delete []paterno;
			delete []materno;
		}
};

class Persona{
	Nombre miNombre;
	int	edad;
	public:
	Persona(char *n, char *p, char*m): miNombre(n, p, m){
		edad=0;
	}
};

int main() {
	Persona *per1;
	per1= new Persona("uno", "dos", "tres");
	Persona per2("Bob", "the", "builder");
	delete per1;
	return 0;
}
\end{minted}
\caption{Ejemplo de composición en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%



%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Objetos compuestos en Java}

En Java, puede no existir mucha diferencia entre la implementación de la asociación y la agregación, debido a que en Java los objetos siempre son manejados por referencias, pero el concepto se debe tener en cuenta para su manejo, además de ser relevante a nivel de diseño de software.

Recordemos que en general hay dos opciones para el manejo de la agregación:

    
\begin{enumerate}
\item Cuando el objeto agregado se destruye, los objetos que lo componen no tienen necesariamente que ser destruidos.
\item Cuando el agregado es destruido también sus componentes se destruyen.
\end{enumerate}

Al igual que en C++, vamos a considerar la segunda opción, por ser más fácil de implementar y es la acción natural de los objetos que se encuentran embebidos como un atributo más una clase.

Ejemplo:
\begin{minted}{java}
class Nombre {
	 private String paterno;
	 private String materno;
	 private String nom;

	 public	set(String pat, String mat, String n) {
		...
	 }
		...
}

class Persona {
	 private int edad;
	 private Nombre nombrePersona;
	 ...
}
\end{minted}

A diferencia de lo que sucede en C++, los atributos compuestos no tienen memoria asignada, es decir, los objetos compuestos no han sido realmente creados en el momento en que se crea el objeto componente. Es responsabilidad del constructor del objeto componente inicializar los objetos miembros o compuestos, si es que así se requiere.

Para inicializar esos objetos componentes tenemos dos opciones:


\begin{enumerate}
\item En el constructor del objeto compuesto llamar a los métodos set correspondientes a la modificación de los atributos de los objetos componentes, esto claro está, después de asignarle la memoria a los objetos componentes.
\item Llamar a algún constructor especializado del  objeto componente en el momento de crearlo.
\end{enumerate}

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Programa Persona
class Nombre {
	private String nombre,
		paterno,
		materno;
	public Nombre(String n, String p, String m){
			nombre= new String(n);
			paterno= new String(p);
			materno= new String(m);
	}
}

public class Persona{
	private Nombre miNombre;
	private int edad;
	public Persona(String n, String p, String m) {
		miNombre= new Nombre(n, p, m);
		edad=0;
	}

	public static void main(String args[]) {
		Persona per1;
		per1= new Persona("uno", "dos", "tres");
		Persona per2= new Persona("mi nombre", "mi apellido", 
		  "otro apellido");
	}
}
\end{minted}
\caption{Ejemplo de composición en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Pero también es posible que un objeto sea un agregado recursivo, es decir, tener como parte de su componente un objeto de su misma clase.  Considerar por ejemplo un directorio de archivos, donde cada directorio puede contener, además de archivos, a otros directorios\footnote{ Lo importante aquí es considerar en que solo existe la \textbf{posibilidad} de contener un objeto de si mismo. Si esto fuera una condición obligatoria y no opcional, estaríamos definiendo un \textbf{objeto infinito}.  Este problema se ve reflejado en lenguajes como C++, donde la forma más simple de implementar la agregación es definiendo un objeto al cual se le asigna espacio en tiempo de compilación, generando entonces el problema de que cada objeto debe reservar memoria para sus componentes, por lo que el compilador no permite que de esta manera se autocontenga. En Java esto no generaría problema porque implícitamente todos los atributos que no son datos simples requieren de una asignación de memoria dinámica.}.

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Objetos compuestos en Ruby}

En Ruby, como en Java, puede no existir mucha diferencia entre la implementación de la asociación y la agregación, debido a que en Ruby los objetos siempre son manejados por referencias, pero el concepto se debe tener en cuenta para su manejo, además de ser relevante a nivel de diseño de software.

Al igual que en C++ y Java, vamos a considerar la opción en la cual los componentes son destruidos cuando el agregado es destruido.

Ejemplo:

\begin{minted}{ruby}
class Nombre 
	 @paterno
	 @materno
	 @nom

	 def set (paterno, materno, nombre)
		...
	 end
		...
end

class Persona 
	 @edad
	 @nombrePersona
	 ...
end
\end{minted}

Como ya se sabe, los identificadores para los atributos no tienen un tipo asociado, sino que son asignados a un objeto en tiempo de ejecución. Es responsabilidad del inicializador del objeto componente inicializar los objetos miembros o compuestos, si es que así se requiere.

%ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
#Programa Persona
class Nombre 
	@nombre
	@paterno
	@materno
	def initialize(nombre, paterno, materno)
		@nombre= String.new nombre
		@paterno= String.new paterno
		@materno= String.new materno
	end
end
	
class Persona
	@miNombre
	@edad
	def initialize(n, p, m)
		@miNombre = Nombre.new(n, p, m)
		@edad =0
	end
end

#código de prueba
per1= Persona.new("uno", "dos", "tres")
per2= Persona.new("mi nombre", "mi apellido", "otro apellido")
\end{minted}
\caption{Ejemplo de composición en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

%ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
# Clase MyDate
class MyDate 
   @month  # 1-12
   @day    # 1-31 dependiendo del mes
   @yea;   # cualquier año
 def initialize (mn, dy, yr)    
      if ( mn > 0 && mn <= 12 )       
         @month = mn;
      else 
         @month = 1;
         puts "Mes #{mn} invalido. Se asigno el mes 1." 
      end

      @year = yr;                      
      @day = checkDay( dy );           # validar el dia

      puts "Inicializador de objeto MyDate para fecha " + to_s
   end

   # verifica que el dia sea correcto de acuerdo al mes
  def checkDay (testDay)  
      daysPerMonth = [0, 31, 28, 31, 30,
                             31, 30, 31, 31, 30,
                             31, 30, 31]
   
      if ( testDay > 0 && testDay <= daysPerMonth[@month] )
         return testDay
      end
   
      if ( @month == 2 &&   # Febrero, si el año es bisiesto
           testDay == 29 &&
           ( @year % 400 == 0 ||
             ( @year % 4 == 0 && @year % 100 != 0 ) ) )
         return testDay
  	  end
   
      puts "Dia #{testDay.to_s} invalido. Se asigno el dia 1." 
   
      return 1  # deja al objeto en un estado consistente
   end
   
   def to_s
       return @month.to_s + "/" + @day.to_s + "/" + @year.to_s
   end
end     

# Clase Empleado
class Employee 
   @firstName
   @lastName
   @birthDate
   @hireDate

   def initialize (fName, lName, bMonth, bDay, bYear,
                    hMonth, hDay, hYear) 
      @firstName = fName
      @lastName = lName
      @birthDate = MyDate.new( bMonth, bDay, bYear )
      @hireDate = MyDate.new( hMonth, hDay, hYear )
   end

   def to_s   
      return @lastName + ", " + @firstName +
             "  Contratado: " + @hireDate.to_s +
             "  Fecha nacimiento: " + @birthDate.to_s
   end
end
# clase EmployeeTest
class EmployeeTest
  attr_reader :e
   @e

   def initialize   
      @e = Employee.new( "Juanito", "Sanchez", 7, 24, 49,
                        3, 12, 88 )
   end
      
end

# codigo de prueba 
et= EmployeeTest.new
puts et.e.to_s
\end{minted}
\caption{Ejemplo 2 de composición en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%


\chapter{Polimorfismo}

El polimorfismo es la capacidad de ofrecer una interfaz para distintos tipos, de manera que un tipo polimórfico es al que se le pueden aplicar operaciones con distintos tipos. Existen distintos tipos de polimorfismo:


\begin{itemize}
\item \textbf{Polimorfismo ad-hoc\cite{strachey2000fundamental}. } Es cuando una función tiene un conjunto de implementaciones distintas sobre un rango de tipos de datos y sus combinaciones. Este tipo de polimorfismo es soportado en muchos lenguajes por medio de la sobrecarga y es también conocido como \textbf{polimorfismo estático}.

\item \textbf{Polimorfismo de subtipo o de inclusión\footnote{''Polymorphic types are types whose operations are applicable to values of more than one type.''}\cite{cardelli1985understanding}   .} Es el tipo de polimorfismo más común, en el que un conjunto de instancias de distintas clases están relacionadas por una superclase. Tan común que es lo que muchas veces se explica como polimorfismo. También conocido como \textbf{polimorfismo dinámico}.

\item \textbf{Polimorfismo paramétrico\cite{strachey2000fundamental} .} Cuando se escribe código sin especificar el tipo que va a ser usado. En POO es conocido como programación genérica. En programación funcional es llamado simplemente polimorfismo.
\end{itemize}





\chapter{Polimorfismo de subtipos}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
	''La capacidad de polimorfismo permite crear programas con mayores posibilidades de expansiones futuras, aún  para procesar en cierta forma objetos de clases que no han sido creadas o están en desarrollo.'' \cite{deitel2012c}  
\\ \hline
\end{tabular}
\end{center}


% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
  	El \textbf{polimorfismo} se define como la capacidad de objetos de clases diferentes, relacionados mediante herencia, a responder de forma distinta a una misma llamada de un método. \cite{deitel2006c++}
\\ \hline
\end{tabular}
\end{center}

Tener en cuenta que no es lo mismo que simplemente redefinir un método de clase base en una clase derivada, pues como se vio anteriormente, si se tiene a un apuntador de clase base y a través de el se hace la llamada a un método, se ejecuta el método de la clase base independientemente del objeto referenciado por el apuntador. Este no es un comportamiento polimórfico.


%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Polimorfismo y funciones virtuales C++}

	En C++, el polimorfismo se implementa a través de clases derivadas y \textbf{funciones virtuales}. Al hacer una solicitud de un método, a través de un apuntador a clase base para usar un método virtual, C++ determina el método que corresponda al objeto de la clase a la que pertenece, y no el método de la clase base.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
 	Una función virtual es un método miembro declarado como \textbf{virtual} en una clase base y siendo este método redefinido en una o más clases derivadas.  
\\ \hline
\end{tabular}
\end{center}

Las funciones virtuales son muy especiales, debido a que cuando una función es accedida por un apuntador a una clase base, y éste mantiene una referencia a un objeto de una clase derivada, el programa determina en tiempo de ejecución a que función llamar, de acuerdo al tipo de objeto al que se apunta. Esto se conoce como \textbf{ligadura tardía}\footnote{Término opuesto a \textbf{ligadura temprana} o \textbf{ligadura estática}, la cual asocia los métodos en tiempo de compilación.} y el compilador de C++ incluye en el código máquina el manejo de ese tipo de asociación de métodos.

	La utilidad se da cuando se tiene un método en una clase base, y éste es declarado virtual. De esta forma, cada clase derivada puede tener su propia implementación del método si es que así lo requiere la clase; y si un apuntador a clase base hace referencia a cualquiera de los objetos de clases derivadas, se determina dinámicamente cual de todos los métodos debe ejecutar.

	La sintaxis en C++ implica declarar al método de la clase base con la palabra reservada \textit{virtual}, redefiniendo ese método en cada una de las clases derivadas.

	Al declarar un método como virtual, este método se conserva así a través de toda la jerarquía de herencia, del punto en que se declaró hacia abajo. Aunque de este modo no es necesario volver a usar la palabra virtual en ninguno de los métodos inferiores del mismo nombre, es posible declararlo de forma explícita para que el programa sea más claro.

	Es importante señalar que las funciones virtuales que sean redefinidas en clases derivadas, deben tener además de la misma firma que la función virtual base, el mismo tipo de retorno.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
class base {
	virtual <tipo> <método> (<parámetros);
};
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
//ejemplo funciones virtuales
#include <iostream>
using namespace std;

class base {
public:
	virtual void quien(){
		cout<<"base\n";
	}
};

class primera: public base {
public:
	void quien(){
		cout<<"primera\n";
	}
};

class segunda: public base {
public:
	void quien(){
		cout<<"segunda\n";
	}
};

class tercera: public base {
};

class cuarta: public base {
public:
	//No se vale con un tipo de dato diferente
	/*int quien(){   
		cout<<"cuarta\n";
		return 1;
	}*/
};

int main() {
	base objBase, *pBase;
	primera obj1;
	segunda obj2;
	tercera obj3;
	cuarta  obj4;

	pBase=&objBase;
	pBase->quien();

	pBase=&obj1;
	pBase->quien();

	pBase=&obj2;
	pBase->quien();

	pBase=&obj3;
	pBase->quien();

	pBase=&obj4;
	pBase->quien();
	
	return 0;
}
\end{minted}
\caption{Ejemplo de polimorfismo en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Hay que hacer notar que las funciones virtuales pueden seguirse usando sin apuntadores, mediante un objeto de la clase. De esta forma, el método a ejecutar se determina de manera estática; es decir, en tiempo de compilación (\textbf{ligadura estática}). Obviamente el método a ejecutar es aquel definido en la clase del objeto o el heredado de su clase base, si la clase derivada no lo redefinió.

La sobrecarga no utiliza ligadura dinámica. Esta es resuelta en tiempo de compilación.
	Si se declara en una clase derivada un método con otro tipo de dato como retorno, el compilador manda un error, ya que esto no es permitido. 

Si se declara un método con el mismo nombre pero diferentes parámetros, la función virtual queda desactivada de ese punto hacia abajo en la jerarquía de herencia.

\subsection{Clase abstracta y clase concreta en C++}

	Existen clases que son útiles para representar una estructura en particular, pero que no van a tener la necesidad de generar objetos directamente a partir de esa clase, éstas se conocen como \textbf{clases abstractas}, o de manera más apropiada como \textbf{clases base abstractas}, puesto que sirven para definir una estructura jerárquica.

	La clase base abstracta entonces, tiene como objetivo proporcionar una clase base que ayude al modelado de la jerarquía de herencia, aunque esta sea muy general y no sea práctico tener instancias de esa clase. 

Por lo tanto, de una clase abstracta no se pueden tener objetos, mientras que en clases a partir de las cuales se puedan instanciar objetos se conocen como \textbf{clases concretas}.

	En C++, una clase se hace abstracta al declarar \textbf{al menos uno }de los métodos virtuales como puro. Un método o función virtual pura es aquel que en su declaración tiene el inicializador de $=0$ .

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}| virtual <tipo> <nombre>(<parámetros>) =0;   //virtual pura  |\\
\hline
\end{tabular}
\end{center}

Es importante tener en cuenta que una clase sigue siendo abstracta hasta que no se implemente la función virtual pura, en una de las clases derivadas. Si no se hace la implementación, la función se hereda como virtual pura y por lo tanto la clase sigue siendo considerada como abstracta.

	Aunque no se pueden tener objetos de clases abstractas, si se pueden tener apuntadores a objetos de esas clases, permitiendo una manipulación de objetos de las clases derivadas mediante los apuntadores a la clase abstracta.
	
\subsection{Destructores virtuales}	

	Cuando se aplica la instrucción \textit{delete} a un apuntador de clase base, será ejecutado el destructor de la clase base sobre el objeto, independientemente de la clase a la que pertenezca. La solución es declarar al destructor de la clase base como virtual. De esta forma al borrar a un objeto se ejecutará el destructor de la clase a la que pertenezca el objeto referenciado, a pesar de que los destructores no tengan el mismo nombre. 

	Un constructor no puede ser declarado como virtual.

Ejemplos de funciones virtuales y polimorfismo:

\ejemplo
\textbf{Programa de cálculo de salario.}
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// EMPLEADO.H
// Abstract base class Employee
#ifndef EMPLEADO_H_
#define EMPLEADO_H_

class Employee {
	public:
   	Employee(const char *, const char *);
   	~Employee();
   	const char *getFirstName() const;
   	const char *getLastName() const;

   	virtual float earnings() const = 0; // virtual pura
   	virtual void print() const = 0;     // virtual pura
	private:
   	char *firstName;
   	char *lastName;
};

#endif /*EMPLEADO_H_*/

// EMPLEADO.CPP
#include <iostream>
#include <string>
#include <assert.h>
#include "empleado.h"

Employee::Employee(const char *first, const char *last)
{
   firstName = new char[ strlen(first) + 1 ];
   assert(firstName != 0);    
   strcpy(firstName, first);

   lastName = new char[ strlen(last) + 1 ];
   assert(lastName != 0);     
   strcpy(lastName, last);
}

Employee::~Employee()
{
   delete [] firstName;
   delete [] lastName;
}

const char *Employee::getFirstName() const
{

   return firstName;
}

const char *Employee::getLastName() const
{
      return lastName;
}
// JEFE.H
// Clase drivada de empleado
#ifndef JEFE_H_
#define JEFE_H_

#include "empleado.h"

class Boss : public Employee {
	public:
   	Boss(const char *, const char *, float = 0.0);
   	void setWeeklySalary(float);
   	virtual float earnings() const;
   	virtual void print() const;
	private:
   	float weeklySalary; 
};

#endif /*JEFE_H_*/

// JEFE.CPP
#include <iostream>
#include "jefe.h"
using namespace std;
Boss::Boss(const char *first, const char *last, float s)
   : Employee(first, last)  
{ weeklySalary = s > 0 ? s : 0; }

void Boss::setWeeklySalary(float s)
{ weeklySalary = s > 0 ? s : 0; }

float Boss::earnings() const { return weeklySalary; }

void Boss::print() const
{
   cout << "\n             Jefe: " << getFirstName()
	<< ' ' << getLastName();
}


// COMIS.H
// Trabajador por comisión derivado de Empleado
#ifndef COMIS_H_
#define COMIS_H_
#include "empleado.h"

class CommissionWorker : public Employee {
	public:
   	CommissionWorker(const char *, const char *,
                    float = 0.0, float = 0.0, int = 0);
   	void setSalary(float);
   	void setCommission(float);
   	void setQuantity(int);
   	virtual float earnings() const;
   	virtual void print() const;
	private:
  	float salary;     // salario base por semana
   	float commission; // comisión por cada venta
   	int quantity;     // cantidad de elementos vendidos por semana
};

#endif /*COMIS_H_*/

// COMIS.CPP
#include <iostream>
#include "comis.h"
using namespace std;

CommissionWorker::CommissionWorker(const char *first,
   const char *last, float s, float c, int q)
   : Employee(first, last)  
{
   salary = s > 0 ? s : 0;
   commission = c > 0 ? c : 0;
   quantity = q > 0 ? q : 0;
}


void CommissionWorker::setSalary(float s)
{ salary = s > 0 ? s : 0; }

void CommissionWorker::setCommission(float c)
{ commission = c > 0 ? c : 0; }

void CommissionWorker::setQuantity(int q)
{ quantity = q > 0 ? q : 0; }

float CommissionWorker::earnings() const
{ return salary + commission * quantity; }

void CommissionWorker::print() const
{
   cout << "\nTrabajador  por comision: " << getFirstName()
	<< ' ' << getLastName();
}

// PIEZA.H
// Trabajador por pieza derivado de Empleado
#ifndef PIEZA_H_
#define PIEZA_H_

#include "empleado.h"

class PieceWorker : public Employee {
	public:
   	PieceWorker(const char *, const char *,
               float = 0.0, int = 0);
   	void setWage(float);
   	void setQuantity(int);
   	virtual float earnings() const;
   	virtual void print() const;
	private:
   	float wagePerPiece; // pago por cada pieza
   	int quantity;       // piezas por semana
};

#endif /*PIEZA_H_*/

// PIEZA.CPP
#include <iostream>
#include "pieza.h"
using namespace std;

// Constructor for class PieceWorker
PieceWorker::PieceWorker(const char *first,
             const char *last, float w, int q)
   : Employee(first, last)  
{
   wagePerPiece = w > 0 ? w : 0;
   quantity = q > 0 ? q : 0;
}

void PieceWorker::setWage(float w)
{ wagePerPiece = w > 0 ? w : 0; }

void PieceWorker::setQuantity(int q)
{ quantity = q > 0 ? q : 0; }

float PieceWorker::earnings() const
{ return quantity * wagePerPiece; }

void PieceWorker::print() const {
   cout << "\n     Tabajador por pieza: " << getFirstName()
	<< ' ' << getLastName();
}

// HORA.H
// Trabajador por hora derivado de Empleado
#ifndef HORA_H_
#define HORA_H_

#include "empleado.h"

class HourlyWorker : public Employee {
	public:
   	HourlyWorker(const char *, const char *,
                float = 0.0, float = 0.0);
   	void setWage(float);
   	void setHours(float);
   	virtual float earnings() const;
   	virtual void print() const;
	private:
   	float wage;   // salario por hora
   	float hours;  // horas trabajadas en la semana
};

#endif /*HORA_H_*/

// HORA.CPP
#include <iostream>
#include "hora.h"
using namespace std;

HourlyWorker::HourlyWorker(const char *first, const char *last,
                           float w, float h)
   : Employee(first, last)   
{
   wage = w > 0 ? w : 0;
   hours = h >= 0 && h < 168 ? h : 0;
}

void HourlyWorker::setWage(float w) { wage = w > 0 ? w : 0; }

void HourlyWorker::setHours(float h)
{ hours = h >= 0 && h < 168 ? h : 0; }

float HourlyWorker::earnings() const { return wage * hours; }

void HourlyWorker::print() const
{
   cout << "\n    Trabajador por hora: " << getFirstName()
	<< ' ' << getLastName();
}

// main.cpp
#include <iostream>
#include <iomanip>
#include "empleado.h"
#include "jefe.h"
#include "comis.h"
#include "pieza.h"
#include "hora.h"
using namespace std;

int main(){
   // formato de salida
   cout << setprecision(2);

   Employee *ptr;  // apuntador a clase base

   Boss b("John", "Smith", 800.00);
   ptr = &b;  // apuntador de clase base apuntando a objeto de clase derivada
   ptr->print();                           // ligado dinámico
   cout << " ganado $" << ptr->earnings(); // ligado dinámico
   b.print();                              // ligado estático
   cout << " ganado $" << b.earnings();    // ligado estático

   CommissionWorker c("Sue", "Jones", 200.0, 3.0, 150);
   ptr = &c;  
   ptr->print();                           
   cout << " ganado $" << ptr->earnings(); 
   c.print();                              
   cout << " ganado $" << c.earnings();    

   PieceWorker p("Bob", "Lewis", 2.5, 200);
   ptr = &p;  
   ptr->print();
   cout << " ganado $" << ptr->earnings(); 
   p.print();                              
   cout << " ganado $" << p.earnings();    

   HourlyWorker h("Karen", "Precio", 13.75, 40);
   ptr = &h;  
   ptr->print();
   cout << " ganado $" << ptr->earnings(); 
   h.print();                              
   cout << " ganado $" << h.earnings();    

   cout << endl;
   return 0;
}
\end{minted}
\caption{Ejemplo de funciones virtuales y polimorfismo en C++. Programa de cálculo de salario..}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\ejemplo
\textbf{Programa de figuras geométricas con una interfaz abstracta Shape (Forma)}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// Figura.H
#ifndef figura_H
#define figura_H

class Shape {
public:
   virtual float area() const { return 0.0; }
   virtual float volume() const { return 0.0; }
   virtual void printShapeName() const = 0; // virtual pura
};
#endif

// Punto.H
#ifndef PUNTO_H_
#define PUNTO_H_
#include <iostream>
#include "figura.h"

class Point : public Shape {
   friend ostream &operator<<(ostream &, const Point &);
public:
   Point(float = 0, float = 0);  
   void setPoint(float, float);
   float getX() const { return x; }
   float getY() const { return y; }
   virtual void printShapeName() const { cout << "Punto: "; }
private:
   float x, y;   
};
#endif /*PUNTO_H_*/

// Punto.CPP
#include <iostream.h>
#include "punto.h"
Point::Point(float a, float b)
{
   x = a;
   y = b;
}

void Point::setPoint(float a, float b)
{
   x = a;
   y = b;
}

ostream &operator<<(ostream &output, const Point &p)
{
   output << '[' << p.x << ", " << p.y << ']';
   return output; 
}

// Circulo.H
#ifndef CIRCULO_H_
#define CIRCULO_H_
#include "punto.h"

class Circle : public Point {
   friend ostream &operator<<(ostream &, const Circle &);
public:
   Circle(float r = 0.0, float x = 0.0, float y = 0.0);

   void setRadius(float);
   float getRadius() const;
   virtual float area() const;
   virtual void printShapeName() const { cout << "Circulo: "; }
private:
   float radius;   
};
#endif /*CIRCULO_H_*/

// Circulo.CPP
#include <iostream>
#include <iomanip>
#include "circulo.h"
using namespace std;

Circle::Circle(float r, float a, float b)
   : Point(a, b)
 { radius = r > 0 ? r : 0; }

void Circle::setRadius(float r) { radius = r > 0 ? r : 0; }

float Circle::getRadius() const { return radius; }

float Circle::area() const { return 3.14159 * radius * radius; }

ostream &operator<<(ostream &output, const Circle &c)
{
   output << '[' << c.getX() << ", " << c.getY()
          << "]; Radio=" << setprecision(2) << c.radius;

   return output; 
}

// Cilindro.H
#ifndef CILINDRO_H_
#define CILINDRO_H_
#include "circulo.h"

class Cylinder : public Circle {
   friend ostream &operator<<(ostream &, const Cylinder &);
public:
   Cylinder(float h = 0.0, float r = 0.0,
	    float x = 0.0, float y = 0.0);

   void setHeight(float);
   virtual float area() const;
   virtual float volume() const;
   virtual void printShapeName() const { cout << "Cilindro: "; }
private:
   float height;   // altura del cilindro
};
#endif /*CILINDRO_H_*/

// Cilindro.CPP
#include <iostream>
#include <iomanip>
#include "cilindro.h"

Cylinder::Cylinder(float h, float r, float x, float y)
   : Circle(r, x, y)
{ height = h > 0 ? h : 0; }

void Cylinder::setHeight(float h)
   { height = h > 0 ? h : 0; }

float Cylinder::area() const
{
      return 2 * Circle::area() +
          2 * 3.14159 * Circle::getRadius() * height;
}

float Cylinder::volume() const
{
   float r = Circle::getRadius();
   return 3.14159 * r * r * height;
}

ostream &operator<<(ostream &output, const Cylinder& c)
{
   output << '[' << c.getX() << ", " << c.getY()
          << "]; Radio=" << setprecision(2) << c.getRadius()
          << "; Altura=" << c.height;
   return output;  
}

// main.CPP
#include <iostream>
#include <iomanip>
using namespace std;

#include "figura.h"
#include "punto.h"
#include "circulo.h"
#include "cilindro.h"

int main(){
   Point point(7, 11);
   Circle circle(3.5, 22, 8);
   Cylinder cylinder(10, 3.3, 10, 10);

   point.printShapeName();     // ligado estático
   cout << point << endl;

   circle.printShapeName();    
   cout << circle << endl;

   cylinder.printShapeName();  
   cout << cylinder << "\n\n";
   cout << setprecision(2);
   Shape *ptr;                 // apuntador de clase base

   // apuntador de clase base referenciando objeto de clase derivada
   ptr = &point;
   ptr->printShapeName();      // ligado dinámico
   cout << "x = " << point.getX() << "; y = " << point.getY()
	<< "\nArea = " << ptr->area()
	<< "\nVolumen = " << ptr->volume() << "\n\n";

   ptr = &circle;
   ptr->printShapeName();  
   cout << "x = " << circle.getX() << "; y =" << circle.getY()
	<< "\nArea = " << ptr->area()
	<< "\nVolumen = " << ptr->volume() << "\n\n";

   ptr = &cylinder;
   ptr->printShapeName();      // dynamic binding
   cout << "x = " << cylinder.getX() << "; y = " << cylinder.getY()
	<< "\nArea = " << ptr->area()
	<< "\nVolumen = " << ptr->volume() << endl;
   return 0;
}
\end{minted}
\caption{Ejemplo de polimorfismo en C++. Programa de figuras geométricas con una interfaz abstracta Shape (Forma).}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%


%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Polimorfismo y clases abstractas Java}
El polimorfismo es implementado en Java a través de clases derivadas y clases \textbf{abstractas}.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
 Recordar:	El \textbf{polimorfismo} se define como la capacidad de objetos de clases diferentes, relacionados mediante herencia, a responder de forma distinta a una misma llamada de un método.  
\\ \hline
\end{tabular}
\end{center}

Al hacer una solicitud de un método, a través de una variable de referencia a clase base para usar un método, Java determina el método que corresponda al objeto de la clase a la que pertenece, y no el método de la clase base.

	Los métodos en Java - a diferencia de C++ - tienen este comportamiento por default, debido a que cuando un método es accedido por una referencia a una clase base, y esta mantiene una referencia a un objeto de una clase derivada, el programa determina \textbf{en tiempo de ejecución} a que método llamar, de acuerdo al tipo de objeto al que se apunta. 

Esto como ya se ha visto, se conoce como \textbf{ligadura tardía} y permite otro nivel de reutilización de código, resaltado por la simplificación con respecto a C++ de no tener que declarar al método como virtual.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//ejemplo Prueba
class base {
	public void quien(){
		System.out.println("base");
	}
}

class primera extends base {
	public void quien(){
		System.out.println("primera");
	}
}

class segunda extends base {
	public void quien(){
		System.out.println("segunda");
	}
}

class tercera extends base { }

class cuarta extends base {
	/*public int quien(){   No se vale con un tipo de dato diferente
	 	System.out.println("cuarta");
	  	return 1;
 	}*/
}

public class Prueba {
	public static void main(String args[]) {
		base objBase= new base(), pBase;
		primera obj1= new primera();
		segunda obj2= new segunda();
		tercera obj3= new tercera();
		cuarta  obj4= new cuarta();

		pBase=objBase;
		pBase.quien();

		pBase=obj1;
		pBase.quien();

		pBase=obj2;
		pBase.quien();

		pBase=obj3;
		pBase.quien();
	
		pBase=obj4;
		pBase.quien();
	}
}
\end{minted}
\caption{Ejemplo de polimorfismo en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Como se aprecia en el ejemplo anterior, en caso de que el método no sea redefinido, se ejecuta el método de la clase base.

	Es importante señalar que – al igual que en C++- los métodos que sean redefinidos en clases derivadas, deben tener además de la misma firma que método base, el mismo tipo de retorno. Si se declara en una clase derivada un método con otro tipo de dato como retorno, se generará un error en tiempo de compilación. 

\subsection{Clase abstracta y clase concreta en Java}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
  	Recordar: Una \textbf{clase base abstracta}, es aquella que es definida para especificar características generales que van a ser aprovechadas por sus clases derivadas, pero no se necesita instanciar a dicha superclase.
\\ \hline
\end{tabular}
\end{center}

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
abstract class ClaseAbstracta {
	//código de la clase
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Además, existe la posibilidad de contar con métodos abstractos:

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
 Un \textbf{método abstracto} lleva la palabra reservada \textit{abstract} y contiene sólo el nombre y su firma. No necesita implementarse, ya que esto es tarea de las subclases.  
\\ \hline
\end{tabular}
\end{center}

Si una clase contiene al menos un método abstracto, toda la clase es considerada abstracta y es conveniente, por claridad, declararla como tal. Es posible claro, declarar a una clase como abstracta sin que tenga métodos abstractos.

Ejemplo básico para un método abstracto:

\begin{minted}{java}
abstract class ClaseAbstracta {
	
 	public abstract void noTengoCodigo( int x);

}
\end{minted}

	Si se crea una subclase de una clase que contiene un método abstracto, deberá de especificarse el código de ese método; de lo contrario, el método seguirá siendo abstracto y por consecuencia también lo será la subclase\footnote{En C++, una clase se hace abstracta al declarar al menos uno de los métodos virtuales como puro.}.

	Aunque no se pueden tener objetos de clases abstractas, si se pueden tener referencias a objetos de esas clases, permitiendo una manipulación de objetos de las clases derivadas mediante las referencias a la clase abstracta.

El uso de clases abstractas \textbf{fortalece} al polimorfismo, al poder partir de clases definidas en lo general, sin implementación de código, pero pudiendo ser agrupadas todas mediante variables de referencia a las clases base.

Ejemplos de clases abstractas y polimorfismo:

\textbf{Programa de cálculo de salario}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// Clase base abstracta Employee
public abstract class Employee {
	private String firstName;
	private String lastName;

   	// Constructor
   	public Employee( String first, String last )  {
      firstName = new String ( first );
      lastName = new String( last );
   	}
   
   	public String getFirstName()  { 
   		return new String( firstName ); 
	}

   	public String getLastName()   { 
   		return new String( lastName ); 
	}

   	// el metodo abstracto debe de ser implementado por cada
   	// clase derivada de Employee para poder ser
   	// instanciadas las subclases
   	public abstract double earnings(); 
}

// Clase Boss class derivada de Employee
public final class Boss extends Employee {
	private double weeklySalary; 

public Boss( String first, String last, double s) {
		super( first, last );  // llamada al constructor de clase base
		setWeeklySalary( s );
   	}
   
	public void setWeeklySalary( double s ){ 
		weeklySalary = ( s > 0 ? s : 0 ); 
	}
   
	// obtiene pago del jefe
	public double earnings() { 
		return weeklySalary; 
	}
   
	public String toString() {
		return "Jefe: " + getFirstName() + ' ' +
             getLastName();
	}
}

// Clase PieceWorker derivada de Employee
public final class PieceWorker extends Employee {
	private double wagePerPiece; // pago por pieza
	private int quantity;        // piezas por semana

	public PieceWorker( String first, String last,
                       double w, int q )    {
		super( first, last );  
		setWage( w );
		setQuantity( q );
	}
   
	public void setWage( double w )    { 
		wagePerPiece = ( w > 0 ? w : 0 ); 
	}
   
	public void setQuantity( int q )    { 
		quantity = ( q > 0 ? q : 0 ); 
	}
   
	public double earnings()   { 
		return quantity * wagePerPiece; 
	}

	public String toString()   {
		return "Trabajador por pieza: " +
             getFirstName() + ' ' + getLastName();
	}  
}

// Clase HourlyWorker derivada de Employee
public final class HourlyWorker extends Employee {
	private double wage;   // pago por hora
	private double hours;  // horas trabajadas por semana

	public HourlyWorker( String first, String last, 
                        double w, double h )   {
		super( first, last );  
		setWage( w );
		setHours( h );
	}
   
	public void setWage( double w )   { 
		wage = ( w > 0 ? w : 0 ); 
	}
   
	public void setHours( double h )   { 
		hours = ( h >= 0 && h < 168 ? h : 0 ); 
	}
   
	public double earnings()    { 
		return wage * hours; 
	}
   
	public String toString()    {
		return "Trabajador por hora: " +
             getFirstName() + ' ' + getLastName();
	}
}
 
// Clase CommissionWorker derivada de Employee
public final class CommissionWorker extends Employee {
	private double salary;      // salario base por semana
	private double commission;  // monto por producto vendido
	private int quantity;       // total de productos vendidos por semana

	public CommissionWorker( String first, String last,
                            double s, double c, int q)   {
		super( first, last );  
		setSalary( s );
		setCommission( c );
		setQuantity( q );
	}
   
	public void setSalary( double s )   { 
		salary = ( s > 0 ? s : 0 ); 
	}
   
	public void setCommission( double c )    { 
		commission = ( c > 0 ? c : 0 ); 
	}
   
	public void setQuantity( int q )   { 
		quantity = ( q > 0 ? q : 0 ); 
	}
   
	public double earnings()   { 
		return salary + commission * quantity; 
	}
   
	public String toString()   {
		return "Trabajador por Comision : " +
             getFirstName() + ' ' + getLastName();
	}
}   
   
// Programa de ejemplo Polimorfismo
public class Polimorfismo {
	public static void main( String rgs[] ) {
		Employee ref;  // referencia de clase base
		Boss b;
		CommissionWorker c;
		PieceWorker p;
		HourlyWorker h;
		b = new Boss( "Alan", "Turing", 800.00 );
		c = new CommissionWorker( "Ada", "Lovelace", 
                                400.0, 3.0, 150);
		p = new PieceWorker( "Grace", "Hopper", 2.5, 200 );
		h = new HourlyWorker( "James", "Gosling", 13.75, 40 );
   
		ref = b;  // referencia de superclase a objeto de subclase
		System.out.println( ref.toString() + " ganó $" +
                    ref.earnings() );
		System.out.println( b.toString() + " ganó $" +
                    b.earnings() );
   
		ref = c;  // referencia de superclase a objeto de subclase
		System.out.println( ref.toString() + " ganó $" +
                    ref.earnings() );
		System.out.println( c.toString() + " ganó $" + 
                    c.earnings() );
   
		ref = p;  // referencia de superclase a objeto de subclase
		System.out.println( ref.toString() + " ganó $" + 
                    ref.earnings() );
		System.out.println( p.toString() + " ganó $" + 
                    p.earnings() );
   
		ref = h;  // referencia de superclase a objeto de subclase
		System.out.println( ref.toString() + " ganó $" + 
                    ref.earnings() );
		System.out.println( h.toString() + " ganó $" + 
                    h.earnings() );
	}
}
\end{minted}
\caption{Ejemplo de clase abstracta y polimorfismo en Java. Programa de cálculo de salario}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\ejemplo
\textbf{Programa de figuras geométricas con una clase abstracta Shape (Forma)}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// Definicion de clase base abstracta Shape
public abstract class Shape {
   
	public double area() { 
		return 0.0; 
	}
   
	public double volume() { 
		return 0.0; 
	}
   
	public abstract String getName();   
}

// Definicion de clase Point
public class Point extends Shape {
	protected double x, y; // coordenadas del punto

	public Point( double a, double b ) { setPoint( a, b ); }

	public void setPoint( double a, double b )   {
		x = a;
		y = b;
	}

	public double getX() { return x; }

	public double getY() { return y; }

	public String toString()
      { return "[" + x + ", " + y + "]"; }

	public String getName() { 
		return "Punto"; 
	}
}

// Definicion de clase Circle
public class Circle extends Point {  // hereda de Point
	protected double radius;

	public Circle()   {
		super( 0, 0 );  
		setRadius( 0 );  
	}

	public Circle( double r, double a, double b )   {
		super( a, b );  
		setRadius( r );  
	}

	public void setRadius( double r )
      { radius = ( r >= 0 ? r : 0 ); }

	public double getRadius() { return radius; }

	public double area() { return 3.14159 * radius * radius; }

	public String toString()
      { return "Centro = " + super.toString() + 
               "; Radio = " + radius; }

	public String getName() { 
		return "Circulo"; 
	}
}

// Definicion de clase Cylinder
public class Cylinder extends Circle {
	protected double height;  // altura del cilindro
      
	public Cylinder( double h, double r, double a, double b )         {
		super( r, a, b );  
		setHeight( h );
	}

	public void setHeight( double h ){ 
		height = ( h >= 0 ? h : 0 ); 
	}
   
	public double getHeight() { 
		return height; 
	}

	public double area()   {
		return 2 * super.area() +
			2 * 3.14159 * radius * height;
	}
    
	public double volume() { 
		return super.area() * height; 
	}

	public String toString(){ 
		return super.toString() + "; Altura = " + height; 
	}

	public String getName() { 
		return "Cilindro"; 
	}
}

// Codigo de prueba
public class Polimorfismo02 {

	public static void main (String args []) {
		Point point;          
		Circle circle;  
		Cylinder cylinder; 
		Shape arrayOfShapes[];

		point = new Point( 7, 11 );          
		circle = new Circle( 3.5, 22, 8 );  
		cylinder = new Cylinder( 10, 3.3, 10, 10 ); 

		arrayOfShapes = new Shape[ 3 ];

		// asigno las referencias de los objetos de subclase 
		// a un arreglo de superclase
		arrayOfShapes[ 0 ] = point;
		arrayOfShapes[ 1 ] = circle;
		arrayOfShapes[ 2 ] = cylinder;  

		System.out.println( point.getName() + ": " + point.toString());
   
		System.out.println( circle.getName() + ": " + circle.toString());
   
		System.out.println( cylinder.getName() + ": " + cylinder.toString());

		for ( int i = 0; i < 3; i++ ) {
			System.out.println( arrayOfShapes[ i ].getName() + 
					": " + arrayOfShapes[ i ].toString());
			System.out.println( "Area = " + arrayOfShapes[ i ].area() );
			System.out.println( "Volume = " + arrayOfShapes[ i ].volume() );
		}
	}
}
\end{minted}
\caption{Ejemplo de polimorfismo en Java. Programa de figuras geométricas con una clase abstracta Shape (Forma)}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsubsection{Clase abstracta o interfaz}
% Abstract classes are similar to interfaces. You cannot instantiate them, and they may contain a mix of methods declared with or without an implementation. However, with abstract classes, you can declare fields that are not static and final, and define public, protected, and private concrete methods. With interfaces, all fields are automatically public, static, and final, and all methods that you declare or define (as default methods) are public. In addition, you can extend only one class, whether or not it is abstract, whereas you can implement any number of interfaces.

%Which should you use, abstract classes or interfaces?

%    Consider using abstract classes if any of these statements apply to your situation:
%        You want to share code among several closely related classes.
%        You expect that classes that extend your abstract class have many common methods or fields, or require access modifiers other than public (such as protected and private).
%        You want to declare non-static or non-final fields. This enables you to define methods that can access and modify the state of the object to which they belong.
 %   Consider using interfaces if any of these statements apply to your situation:
 %       You expect that unrelated classes would implement your interface. For example, the interfaces Comparable and Cloneable are implemented by many unrelated classes.
%        You want to specify the behavior of a particular data type, but not concerned about who implements its behavior.
%        You want to take advantage of multiple inheritance of type.

% source: https://docs.oracle.com/javase/tutorial/java/IandI/abstract.html




\subsection{Ejemplo de Polimorfismo con una Interfaz en Java}

	Los programas anteriores estaban basados en clases y clases abstractas. Sin embargo, también es posible tener variables de referencia a interfaces, a través de las cuales se implemente el polimorfismo. El siguiente programa muestra otra estructura clásica de clases “gráficas”, todas contienen su propia implementación de $draw()$, y son organizadas en dos arreglos de ejemplo: uno de la clase principal, y el segundo del tipo de la interfaz. 
	
\begin{figure}
    \centering
    \includegraphics{imagenes/polimorfismo_interfaz_java.png}
    \caption{Ejemplo de polimorfismo con interfaces en Java}
    \label{fig:my_label}
\end{figure}	
	
\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//programa Polimorfismo
interface IDrawable {
    void draw();
}

class Shape implements IDrawable {
    public void draw() { System.out.println("Dibujando Figura."); }
}

class Circle extends Shape {
    public void draw() { System.out.println("Dibujando Circulo."); }
}

class Rectangle extends Shape {
    public void draw() { System.out.println("Dibujando Rectangulo."); }
}

class Square extends Rectangle {
    public void draw() { System.out.println("Dibujando cuadrado."); }
}

class Map implements IDrawable {
    public void draw() { System.out.println("Dibujando mapa."); }
}

public class Polimorfismo03 {
    public static void main(String args[]) {
        Shape[] shapes = {new Circle(), new Rectangle(), new Square()};   
        IDrawable[] drawables = {new Shape(), new Rectangle(), new Map()};

        System.out.println("Dibujando figuras:");
        for (int i = 0; i < shapes.length; i++)                           
            shapes[i].draw();

        System.out.println("Dibujando elementos dibujables:");
        for (int i = 0; i < drawables.length; i++)                        
            drawables[i].draw();
    }
}
\end{minted}
\caption{Ejemplo de polimorfismo con interfaces en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Polimorfismo en Ruby}

El polimorfismo es implementado en Ruby a través de clases derivadas. 

Al hacer una solicitud de un método, a través de una variable, Ruby determina \textbf{en tiempo de ejecución} a que método llamar, de acuerdo al tipo de objeto al que se apunta. 

%ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
#ejemplo Prueba
class Base 
	def quien
		puts "base"
	end
end

class Primera < Base 
	def	quien
		puts "primera"
	end
end

class Segunda < Base 
	def quien
		puts "segunda"
	end
end

class Tercera < Base 

end

class Cuarta < Base 
	def quien   #Si se vale con un tipo de retorno diferente (definido dinamicamente)
	 	puts "cuarta"
	  	return 1
	end
end

#codigo de prueba
def prueba 
	objBase= Base.new
	obj1= Primera.new
	obj2= Segunda.new
	obj3= Tercera.new
	obj4= Cuarta.new

	pBase=objBase
	pBase.quien

	pBase=obj1
	pBase.quien

	pBase=obj2
	pBase.quien

	pBase=obj3
	pBase.quien
	
	pBase=obj4
	pBase.quien
end

prueba
\end{minted}
\caption{Ejemplo de polimorfismo en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Como se aprecia en el ejemplo anterior, en caso de que el método no sea redefinido, se ejecuta el método de la clase base.

Es importante señalar que  \textbf{no} es necesario que el tipo de retorno coincida, pues éste se determina dinámicamente.

\subsection{¿Y la clase abstracta?}	

Ruby no tiene el concepto de clase abstracta y clase concreta. Si por cuestión de diseño es necesario definir una clase que no debe permitir instancias, es posible crear un método en dicha clase como sigue:

\begin{minted}{ruby}
class MiClase
	def self.abstract?
		return self == MiClase
	end
end
\end{minted}

Esto no limita realmente a que alguien pueda instanciar la clase, pero es posible preguntar si la clase es “abstract?”. 


%ejemplo
\textbf{Programa de cálculo de salario}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
# Clase base Employee
class Employee 
	attr_reader :firstName, :lastName
	
	@firstName
	@lastName

	def self.abstract?
		return self == Employee
	end
	
	# Inicializador
   	def initialize (first, last)  
   		@firstName = String.new( first )
		@lastName = String.new( last )
   	end
   
    # método sin código
   	def earnings
   	end	
end

# Clase Boss cderivada de Employee
 class Boss < Employee 
	 @weeklySalary 

	 def initialize (first, last, s) 
		super( first, last )  # llamada al constructor de clase base
		setWeeklySalary( s )
   	end
   
	def setWeeklySalary( s ) 
		@weeklySalary = ( s > 0 ? s : 0 ) 
	end
   
	# obtiene pago del jefe
	def earnings  
		return @weeklySalary 
	end
   
	def to_s 
		return "Jefe: " + @firstName + " " + @lastName
	end
end

# Clase PieceWorker derivada de Employee
class PieceWorker < Employee 
	attr_reader :wagePerPiece, :quantity
	
	@wagePerPiece # pago por pieza
	@quantity  # piezas por semana

	def initialize(first, last, w, q )    
		super( first, last )  
		setWage( w )
		setQuantity( q )
	end
   
	def setWage( w )     
		@wagePerPiece = ( w > 0 ? w : 0 ) 
	end
   
	def setQuantity( q )     
		@quantity = ( q > 0 ? q : 0 ) 
	end
   
	def earnings    
		return quantity * wagePerPiece 
	end

	def to_s   
		return "Trabajador por pieza: " + @firstName + " " + @lastName
	end  
end

# Clase HourlyWorker derivada de Employee
class HourlyWorker < Employee 
	attr_reader :wage, :hours
	
	@wage   # pago por hora
	@hours  # horas trabajadas por semana

	def initialize(first, last, w, h)   
		super( first, last )  
		setWage( w )
		setHours( h )
	end
   
	def setWage( w )    
		@wage = ( w > 0 ? w : 0 ) 
	end
   
	def setHours( h )    
		@hours = ( h >= 0 && h < 168 ? h : 0 ) 
	end
   
	def earnings     
		return @wage * @hours 
	end
   
	def to_s    
		return "Trabajador por hora: " + @firstName + " " + @lastName
	end
end

# Clase CommissionWorker derivada de Employee
class CommissionWorker < Employee 
	attr_reader :salary, :commission, :quantity
	
	@salary      # salario base por semana
	@commission  # monto por producto vendido
	@quantity    # total de productos vendidos por semana

	def initialize(first, last, s, c, q)   
		super( first, last )  
		setSalary( s )
		setCommission( c )
		setQuantity( q )
	end
   
	def setSalary( s )    
		@salary = ( s > 0 ? s : 0 ) 
	end
   
	def setCommission( c )     
		@commission = ( c > 0 ? c : 0 ) 
	end
   
	def setQuantity( q )    
		@quantity = ( q > 0 ? q : 0 ) 
	end
   
	def earnings    
		return @salary + @commission * @quantity 
	end
   
	def to_s   
		return "Trabajador por Comision : " + @firstName + " " + @lastName
	end
end   


# Codigo de ejemplo Polimorfismo
b = Boss.new( "Alan", "Turin", 800.00 )
c = CommissionWorker.new( "Ada", "Lovelace", 400.0, 3.0, 150)
p = PieceWorker.new( "Grace", "Hopper", 2.5, 200 )
h = HourlyWorker.new( "James", "Gosling", 13.75, 40 )

puts Employee.abstract?   

ref = b  # referencia a objeto de subclase
puts ref.to_s + " gano $" +  ref.earnings.to_s
puts  b.to_s + " gano $" + b.earnings.to_s 
   
ref = c  # referencia  a objeto de subclase
puts ref.to_s + " gano $" + ref.earnings.to_s
puts c.to_s + " gano $" + c.earnings.to_s
   
ref = p  # referencia a objeto de subclase
puts ref.to_s + " gano $" + ref.earnings.to_s
puts p.to_s + " gano $" + p.earnings.to_s
   
ref = h  # referencia a objeto de subclase
puts ref.to_s + " gano $" + ref.earnings.to_s
puts h.to_s + " gano $" + h.earnings.to_s
\end{minted}
\caption{Ejemplo polimorfismo en Ruby. Programa de cálculo de salario.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

%ejemplo
\textbf{Programa de figuras geométricas con una clase abstracta Shape (Forma)}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
# Definicion de clase base abstracta Shape
class Shape 
	def self.abstract?
		return self == Shape
	end
   
	def area 
		return 0.0 
	end
   
	def volume 
		return 0.0 
	end
   
	def getName  
	end	
end

# Definicion de clase Point
class Point < Shape 
	attr_reader :x, :y
	
	@x
	@y # coordenadas del punto

	def initialize (a, b) 
		setPoint( a, b ) 
	end

	def setPoint(a, b)
		@x, @y = a, b
	end

	def to_s
       return "[" + @x.to_s + ", " + @y.to_s + "]"
	end

	def getName 
		return "Punto" 
	end
end

# Definicion de clase Circle
class Circle < Point # hereda de Point
	attr_reader :radius
	
	@radius

	def initialize(r, a, b)
		super( a, b )
		setRadius( r )  
	end

	def setRadius(r)
    	@radius = ( r >= 0 ? r : 0 )
	end

	def area 
		return 3.14159 * radius * radius
	end

	def to_s
      	return "Centro = " + super + "; Radio = " + @radius.to_s
	end

	def getName 
		return "Circulo " 
	end
end

# Definicion de clase Cylinder
class Cylinder < Circle
	attr_reader :height
	alias_method :areaCircle, :area  #define un nuevo nombre para el metodo area de Circle
	# o puede usarse alias :areaCircle :area
	
	@height # altura del cilindro
      
	def initialize(h, r, a, b)       
		super(r, a, b)  
		setHeight(h)
	end

	def setHeight(h) 
		@height = ( h >= 0 ? h : 0 )
	end
   
	def area
		return 2 * super +	2 * 3.14159 * @radius * @height
	end
     
	def volume 
		return areaCircle * @height 
	end

	def to_s 
		return super + "; Altura = " + @height.to_s 
	end

	def getName 
		return "Cilindro " 
	end
end

# Codigo de prueba
#sh = Shape()           # genera error
point = Point.new( 7, 11 )          
circle = Circle.new( 3.5, 22, 8 )
cylinder = Cylinder.new( 10, 3.3, 10, 10 )

# asigno las referencias de los objetos de subclase 
# a un arreglo 
arrayOfShapes=[]
arrayOfShapes[0 ] = point
arrayOfShapes[1 ] = circle
arrayOfShapes[2 ] = cylinder 
  
puts point.getName + ": " + point.to_s
   
puts circle.getName + ": " + circle.to_s
   
dos?puts cylinder.getName + ": " + cylinder.to_s

for  elem in arrayOfShapes
	puts elem.getName + elem.to_s
	puts "  Area = " + elem.area.to_s
	puts "  Volumen = " + elem.volume.to_s
end
\end{minted}
\caption{Ejemplo polimorfismo en Ruby. Programa de figuras geométricas con una clase abstracta Shape (Forma).}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%

%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Polimorfismo en Python}

Debido a que Python es un lenguaje tipado dinámicamente, el polimorfismo se ejecuta en automático. De hecho, cada operación es una operación polimórfica en Python.
Cualquier método aplicado a un objeto funcionará mientras la clase del objeto la soporte, siendo determinado en tiempo de ejecución si es posible llevarse a cabo la operación.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
# Ejemplo de polimorfismo en Python
class base:
    def quien(self):
        print('base')
class primera (base):
    def quien(self):
        print('primera')
class segunda (base):
    def quien(self):
        print('segunda')
class tercera (base):
    def foo(self):
        return        
#script de ejecución
objBase = base()
obj1 = primera()
obj2 = segunda()
obj3 = tercera()

pBase= objBase
pBase.quien()
pBase= obj1
pBase.quien()
pBase= obj2
pBase.quien()
pBase= obj3
pBase.quien()
\end{minted}
\caption{Ejemplo de polimorfismo en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Clases abstractas y polimorfismo en Python}

El concepto de clases abstractas no está implementado directamente en Python. Sin embargo, si proporciona un módulo para clases bases abstractas (ABC – Abstract Base Class)\footnote{\href{https://docs.python.org/3/library/abc.html}{abc}}. El módulo proporciona una metaclase\footnote{\href{https://realpython.com/python-metaclasses/}{Metaclasses}} ABCMeta y una clase de ayuda ABC\footnote{El concepto de metaclases en Python va más allá del alcance del curso.}. Una clase que tiene una metaclase derivada de ABCMeta no puede ser instanciada. 
Se pueden definir métodos abstractos mediante el uso del decorador $@abstractmethod$. El uso de este decorador requiere que la metaclase de la clase sea ABCMeta o se derive de esta.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
from abc import ABC

class <MiClaseAbstracta>(ABC):
    <resto de la clase>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#polimorfismo y clase abstracta en Python
from abc import ABC, abstractmethod

class Shape(ABC):
    def area(self):
        return 0
    def volume(self):
        return 0

    @abstractmethod
    def getName(self):
        pass

class Point (Shape):
    def __init__(self, a, b):
        self.x = a
        self.y = b

    def setPoint(self, a, b):
        self.x = a
        self.y = b

    def getX(self):
        return self.x

    def getY(self):
        return self.y

    def toString(self):
        return "[" + str(self.x) + ", " + str(self.y) + "]"

    def getName(self):
        return 'Punto'
    
class Circle (Point):
    def __init__(self, r, a, b):
        super().__init__(a, b)
        self.radius = r

    def setRadius(self, r):
        if r>=0 :
            self.radius = r
        else:
            self.radius = 0

    def area(self):
        return 3.14159 * self.radius * self.radius

    def toString(self):
        return "Centro = " + super().toString() + "; Radio = " + str(self.radius)
        
    def getName(self):
        return 'Círculo'

class Cylinder (Circle):
    def __init__(self, h, r, a, b):
        super().__init__(r, a, b)
        self.height = h

    def setHeight(self, h):
        if h>=0:
            self.height  = h
        else:
            self.height = 0

    def getHeight(self):
        return self.height

    def area(self):
        return 2 * super().area() + 2 * 3.14159 * self.radius * self.height

    def volume(self):
        return super().area() * self.height

    def toString(self):
        return super().toString() + "; Altura = " + str(self.height)
        
    def getName(self):
        return 'Cilindro'

#script de prueba
point = Point(7, 11)
circle = Circle(3.5, 22, 8)
cylinder = Cylinder(10, 3.3, 10, 10)
arrayOfShapes = [point, circle, cylinder]

print(point.getName() + ": " + point.toString())
print(circle.getName() + ": " + circle.toString())
print(cylinder.getName() + ": " + cylinder.toString())

for sh in arrayOfShapes:
    print(sh.getName() + ": " + sh.toString())
    print( "Area = " + str(sh.area()) )
    print( "Volume = " + str(sh.volume()) )
\end{minted}
\caption{Ejemplo de clases abstractas y polimorfismo en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
\newpage

\section{Polimorfismo en C#}

\section{Polimorfismo en D}

\section{Polimorfismo en Scala}

\section{Principio de sustitución de Liskov y Polimorfismo}
El principio de sustitución de Liskov (LSP, por sus siglas en inglés) es uno de los principios fundamentales de la programación orientada a objetos, propuesto por Barbara Liskov en 1988. Este principio establece que los objetos de una clase derivada deben poder ser sustituidos por objetos de la clase base sin afectar la corrección del programa.

De manera más formal, el principio de sustitución de Liskov se puede expresar de la siguiente manera: "Si S es un subtipo de T, entonces los objetos del tipo T pueden ser reemplazados por objetos del tipo S (es decir, objetos del subtipo) sin alterar ninguna de las propiedades deseables de ese programa (corrección, ejecución de tareas, etc.)".

El principio de sustitución de Liskov es importante en el diseño orientado a objetos por las siguientes razones:

    \begin{enumerate}
        \item \textbf{Herencia y polimorfismo}: El LSP garantiza que la herencia y el polimorfismo funcionen correctamente. Si una clase derivada viola el LSP, puede introducir errores y comportamientos inesperados cuando se utiliza en lugar de la clase base.
        \item \textbf{Modularidad y extensibilidad}: Al cumplir con el LSP, las clases derivadas pueden extender el comportamiento de las clases base sin romper las suposiciones existentes. Esto facilita la modularidad y la extensibilidad del software.
        \item \textbf{Reusabilidad}: El LSP promueve la reusabilidad del código, ya que las clases derivadas que cumplen con el principio pueden ser sustituidas por la clase base sin problemas en diferentes partes del sistema.
        \item \textbf{Diseño robusto}: Al seguir el LSP, se evitan errores relacionados con la herencia y se promueve un diseño más robusto y mantenible.
    \end{enumerate}

Para cumplir con el principio de sustitución de Liskov, las clases derivadas deben adherirse a las siguientes reglas:

    \begin{enumerate}
        \item Las precondiciones de los métodos de la clase derivada no deben ser más estrictas que las precondiciones de los métodos de la clase base.
        \item Las postcondiciones de los métodos de la clase derivada no deben ser más débiles que las postcondiciones de los métodos de la clase base.
        \item Los invariantes de la clase derivada deben ser consistentes con los invariantes de la clase base.
        \item Las excepciones arrojadas por los métodos de la clase derivada deben ser subtipos de las excepciones arrojadas por los métodos de la clase base.
    \end{enumerate}

Al seguir el principio de sustitución de Liskov, se garantiza que las clases derivadas sean verdaderas extensiones de las clases base, lo que conduce a un diseño más modular, extensible y mantenible en la programación orientada a objetos.

\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%





\chapter{Polimorfismo paramétrico: programación genérica}

La programación genérica favorece la reutilización de código, permitiendo que se generen objetos específicos para un tipo a partir de \textbf{clases genéricas}. Las clases genéricas son conocidas también como \textbf{plantillas de clase} o \textbf{clases parametrizadas}.


%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Plantillas de clase en C++}
Antes se mencionó el uso de plantillas en C++ aplicado a funciones. El concepto de plantillas es aplicable también a la programación orientada a objetos en C++a través de \textbf{plantillas de clase}. 

	El uso de plantillas de clase no es diferente al uso de plantillas en operaciones no orientadas a objetos:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
template <class T>  

o 

template <typename T>
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Veamos el ejemplos clásicos aprovechando el uso de plantillas.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
#include <iostream>

using namespace std;

template <class T, class U>
class Pair {
private:
    T first;
    U second;
public:
    Pair(T f, U second) { 
        first=f;
        this->second=second; 
        
    }

    T getFirst() { 
        return first; 
        
    }
    U getSecond() { 
        return second; 
    }
};

int main() { 
    Pair<float, int> *pair = new Pair<float, int>(10.5,2);
    
    cout<<"Obten el primer elemento:" << pair->getFirst()<<endl;
    cout<<"Obten el segundo elemento:"<< pair->getSecond()<<endl;
    return 0;
} 
\end{minted}
\caption{Ejemplo de plantillas en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// stack.h
// Clase de plantilla Pila
#ifndef STACK_H_
#define STACK_H_

template< class T >
class Stack {
public:
	Stack( int = 10 );
	~Stack() { delete [] stackPtr; }
	char push( const T& );
	char pop( T& );
private:
	int size;
	int top;
	T *stackPtr;

	char isEmpty() const { return top == -1; }
	char isFull() const { return top == size - 1; }
};


template< class T >
Stack< T >::Stack( int s )
{
	size = s > 0 ? s : 10;
	top = -1;
	stackPtr = new T[ size ];
}

template< class T >
char Stack< T >::push( const T &pushValue )
{
	if ( !isFull() ) {
		stackPtr[ ++top ] = pushValue;
		return 1;
	}
	return 0;
}

template< class T >
char Stack< T >::pop( T &popValue )
{
	if ( !isEmpty() ) {
		popValue = stackPtr[ top-- ];
		return 1;
	}
	return 0;
}

#endif /*STACK_H_*/

// Ejemplo uso de plantillas de clase
#include <iostream>
#include "stack.h"

using namespace std;

int main() {
	Stack< double > doubleStack( 5 );
	double f = 1.1;
	cout << "Insertando elementos en doubleStack \n";

	while ( doubleStack.push( f ) ) {
		cout << f << ' ';
		f += 1.1;
	}

	cout << "\nLa pila está llena. No se puede insertar el elemento " << f
		  << "\n\nSacando elementos de doubleStack\n";

	while ( doubleStack.pop( f ) )
		cout << f << ' ';

	cout << "\nLa pila está vacía. No se pueden eliminar más elementos\n";

	Stack< int > intStack;
	int i = 1;
	cout << "\nInsertando elementos en intStack\n";

	while ( intStack.push( i ) ) {
		cout << i << ' ';
		++i;
	}

	cout << "\nLa pila está llena.  " << i
		  << "\n\nSacando elementos de intStack\n";

	while ( intStack.pop( i ) )
		cout << i << ' ';

	cout << "\nLa pila está vacía. No se pueden eliminar más elementos \n";
	return 0;
}
\end{minted}
\caption{Ejemplo, una pila con plantillas en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


Las plantillas de clase ayudan a la reutilización de código, al permitir varias versiones de clases para un tipo de dato a partir de clases genéricas. A estas clases específicas se les conoce como \textbf{clases de plantilla}.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
Una clase de plantilla es entonces como una instanciación de una plantilla de clase.   
\\ \hline
\end{tabular}
\end{center}

Con respecto a la herencia en combinación con el uso de plantillas, se deben tener en cuenta las siguientes situaciones\cite{josuttis2003c++}:


\begin{itemize}
\item Una plantilla de clase se puede derivar de una clase de plantilla.
\item Una plantilla de clase se puede derivar de una clase que no sea plantilla.
\item Una clase de plantilla se puede derivar de una plantilla de clase.
\item Una clase que no sea de plantilla se puede derivar de una plantilla de clase.
\end{itemize}


En cuanto a los miembros estáticos, cada clase de plantilla que se crea a partir de una plantilla de clases mantiene sus propias copias de los miembros estáticos.

\section{Standard Template Library (STL)}

Las plantillas de clase son una herramienta muy poderosa en C++. Esto ha llevado a desarrollar lo que se conoce como STL. STL es el acrónimo de \textit{Standard Template Library}, y es una biblioteca de C++ que proporciona un conjunto de clases contenedoras, iteradores y de algoritmos genéricos:

\begin{itemize}
\item Las clases contenedoras incluyen vectores, listas, deques, conjuntos, multiconjuntos, multimapas, pilas, colas  y colas de prioridad.
\item Los iteradores son generalizaciones de apuntadores: son objetos que apuntan a otros objetos. Son usados normalmente para iterar sobre un conjunto de objetos. Los iteradores son importantes porque son típicamente usados como interfaces entre las clases contenedoras y los algoritmos.
\item Los algoritmos genéricos incluyen un amplio rango de algoritmos fundamentales para los más comunes tipos de manipulación de datos, como ordenamiento, búsqueda, copiado y transformación.
\item STL es una biblioteca estándar de ANSI/ISO desde julio de 1994.
\end{itemize}

La STL está altamente parametrizada, por lo que casi cada componente en la STL es una plantilla\cite{graphics1997standard} . Podemos usar por ejemplo la plantilla $vector<T>$ para hacer uso de vectores sin necesidad de preocuparnos del manejo de memoria:

\begin{minted}{cpp}
        vector<int> v(3);     // Declara un vector de 3 elementos.
    	v[0] = 7;
    	v[1] = v[0] + 3;
    	v[2] = v[0] + v[1];   // v[0] == 7, v[1] == 10, v[2] == 17
\end{minted}

Los algoritmos proporcionados por la STL ayudan a manipular los datos de los contenedores\cite{graphics1997standard}. Por ejemplo, podemos invertir el orden de los elementos de un vector, usando el algoritmo $reverse()$:

\mint[linenos=false]{cpp}| reverse(v.begin(), v.end()); // v[0]==17, v[1]==10, v[2]==7 |

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
#ifndef STACK_HPP_
#define STACK_HPP_
#include <vector> 

template <typename T> 
class Stack { 
  private: 
    std::vector<T> elems;     // elementos 

  public: 
    void push(T const&);       
    void pop();                
    T top() const;            // regresa elemento en el tope 
    bool empty() const {      // regresa si la pila esta vacia 
        return elems.empty(); 
    } 
}; 

template <typename T> 
void Stack<T>::push (T const& elem) 
{ 
    elems.push_back(elem);    // añade una copia de elem 
} 

template<typename T> 
void Stack<T>::pop () 
{ 
    if (elems.empty()) { 
        std::cout<<"Stack<>::pop(): pila vacia";
        return; 
    } 
    elems.pop_back();         // remueve el ultimo elemento 
} 

template <typename T> 
T Stack<T>::top () const 
{ 
    if (elems.empty()) { 
        std::cout<<"Stack<>::top(): pila vacia";
    } 
    return elems.back();      // regresa copia del elemento en el tope 
} 
#endif /*STACK_HPP_*/

#include <iostream> 
#include <string> 
#include <cstdlib> 
#include "stack.hpp" 

int main() 
{ 
        Stack<int>         intStack;       // pila de enteros 
        Stack<std::string> stringStack;    // pila de strings 

        // manipulapila de enteros 
        intStack.push(7); 
        std::cout << intStack.top() << std::endl; 

        // manipula pila de strings 
        stringStack.push("hola"); 
        std::cout << stringStack.top() << std::endl; 
        stringStack.pop(); 
        stringStack.pop(); 
} 
\end{minted}
\caption{Ejemplo de STL.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



%tabla de ejemplos de clases de la STL

%para ajustar el código de la columna de ejemplo
\lstset{
  basicstyle=\ttfamily\footnotesize,
  columns=flexible,
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny,
  tabsize=2
}

%\begin{document}

%\title{Clases más Usadas de la STL en C++}
%\author{}
%\date{}
%\maketitle

\section*{Tabla de Clases más Usadas de la STL en C++}

\newcommand{\code}[1]{\texttt{#1}}


\begin{tabularx}{\textwidth}{|l|X|X|}
	\hline
	\textbf{Clase} & \textbf{Descripción} & \textbf{Ejemplo} \\
	\hline
	
	\texttt{vector} &
	Contenedor dinámico que permite almacenar una colección de elementos en un arreglo redimensionable. &
	\code{std::vector<int> v = \{1, 2, 3\}; v.push\_back(4);} \\
	\hline
	
	\texttt{list} &
	Lista doblemente enlazada que permite inserciones y eliminaciones rápidas en cualquier posición. &
	\code{std::list<int> l = \{1, 2, 3\}; l.push\_back(4);} \\
	\hline
	
	\texttt{deque} &
	Contenedor que permite inserciones y eliminaciones rápidas tanto al principio como al final. &
	\code{std::deque<int> d; d.push\_front(1); d.push\_back(2);} \\
	\hline
	
	\texttt{set} &
	Contenedor que almacena elementos únicos y los mantiene ordenados automáticamente. &
	\code{std::set<int> s = \{3, 1, 2\}; s.insert(4);} \\
	\hline
	
	\texttt{map} &
	Contenedor que almacena pares clave-valor, ordenado por las claves. &
	\code{std::map<std::string, int> m; m["Alicia"] = 25;} \\
	\hline
	
	\texttt{unordered\_map} &
	Contenedor similar a \texttt{map}, pero no mantiene los elementos ordenados. &
	\code{std::unordered\_map<std::string, int> um; um["Alicia"] = 25;} \\
	\hline
	
	\texttt{stack} &
	Contenedor que sigue la estructura LIFO (Last In, First Out). &
	\code{std::stack<int> st; st.push(1); st.push(2);} \\
	\hline
	
	\texttt{queue} &
	Contenedor que sigue la estructura FIFO (First In, First Out). &
	\code{std::queue<int> q; q.push(1); q.push(2);} \\
	\hline
	
	\texttt{priority\_queue} &
	Cola de prioridad que permite almacenar elementos ordenados según un criterio. &
	\code{std::priority\_queue<int> pq; pq.push(3); pq.push(1);} \\
	\hline
	
	\texttt{pair} &
	Estructura que permite almacenar un par de valores relacionados. &
	\code{std::pair<int, std::string> p = \{1, "Alicia"\};} \\
	\hline
	
	\texttt{tuple} &
	Similar a \texttt{pair}, pero permite almacenar más de dos valores de distintos tipos. &
	\code{std::tuple<int, std::string, float> t = \{1, "Alicia", 3.14\};} \\
	\hline
\end{tabularx}

%%%


\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%


%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Clases Genéricas en Java}

Java 1.5 introdujo finalmente el uso de clases genéricas (\textit{generics})\cite{bracha2004generics}. El uso de clases genéricas es una característica poderosa usada en otros lenguajes, siendo C++ el ejemplo más conocido que soporta programación genérica mediante el uso de plantillas o \textit{templates}.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}| class NombreClase <Lista de parámetros de tipos> { ... }  |\\
\hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class Pair<T, U> {
  private final T first;
  private final U second;
  public Pair(T first, U second) { this.first=first; this.second=second; }
  public T getFirst() { return first; }
  public U getSecond() { return second; }
}

public class PairExample {
	public static void main(String[] args) {
		
		Pair<String, Integer> pair = new Pair<String, Integer>("one",2);
		
		// no acepta tipos de datos básicos o primitivos
		//Pair<String, int> pair2 = new Pair<String, Integer>("one",2);
		
		// siguiente linea generaría un warning de seguridad de tipos 
		//Pair<String, Integer> pair3 = new Pair("one",2);

		System.out.println("Obtén primer elemento:" + pair.getFirst());
		System.out.println("Obtén segundo elemento:" + pair.getSecond());
	}
}
\end{minted}
\caption{Ejemplo de clases genéricas en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Es también posible parametrizar interfaces, como se muestra a continuación.

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}| interface NombreInterfaz <Lista de parámetros de tipos> { ... }  |\\
\hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
interface IPair<T, U>{
	public T getFirst();
	public U getSecond();
}

class Pair<T, U> implements IPair<T, U>{
  private final T first;
  private final U second;
  public Pair(T first, U second) { this.first=first; this.second=second; }
  public T getFirst() { return first; }
  public U getSecond() { return second; }
}

public class PairExample {
	public static void main(String[] args) {
		
		IPair<String, Integer> ipair = new Pair<String, Integer>("one",2);

		System.out.println("Obtén primer elemento:"+ipair.getFirst());
		System.out.println("Obtén segundo elemento:"+ipair.getSecond());
	}

}
\end{minted}
\caption{Ejemplo clases e interfaces genéricas en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Un requerimiento para el uso tipos genéricos en Java es que no pueden usarse tipos de datos primitivos, porque los tipos primitivos o básicos no son subclases de Object\cite{kreft2004}. Por lo que sería ilegal por ejemplo querer instanciar $Pair<int, String>$ . La ventaja es que el uso de la clase \textit{Object} significa que solo un archivo de clase (\textit{.class}) necesita ser generado por cada clase genérica\cite{turner2001}.

Restriciones de las clases genéricas, ver\footnote{\href{https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html#createArrays}{Java generics}}.

\section{Biblioteca de Clases Genéricas en Java}

Al igual que C++ con la STL, Java tiene un conjunto de clases genéricas predefinidas. Su uso, de manera similar que con las clases genéricas definidas por el programador, no está permitido para tipos primitivos, por lo que solo objetos podrán ser contenidos. Las principales clases genéricas en Java son, como en la STL, clases contenedoras o colecciones\footnote{ Las colecciones en Java eran implementadas antes de la versión 1.5 pero sin el uso de clases genéricas. El uso de versiones anteriores de colecciones con colecciones genéricas es permitido por compatibilidad hacia atrás pero debe tenerse especial cuidado pues hay situaciones que el compilador no puede validar.}. El \textit{Java Collections Framework }(JCF) es un conjunto de interfaces y clases definidos en los paquetes $java.util$ y $java.util.concurrent$.

Las interfaces del JCF son:

  
\begin{itemize}
\item \textit{Collection}. Contiene la funcionalidad básica requerida en casi cualquier colección de objetos (con excepción de \textit{Map})
\item \textit{Set}. Es una colección sin duplicados, donde el orden es no significante. Sin embargo contiene un método que devuelve el conjunto ordenado (\textit{SortedSet}).
\item \textit{Queue}. Define el comportamiento básico de una estructura de cola.
\item \textit{List}. Es una colección donde el orden es significativo, permitiendo además valores duplicados.
\item \textit{Map}. Define una colección donde un valor clave es asociado para almacenar y recuperar elementos.
\end{itemize}

La siguiente figura muestra las principales interfaces de la JCF\cite{naftalin2007java}:

\begin{figure}
    \centering
    \includegraphics{imagenes/biblioteca_generica_java.png}
    \caption{Biblioteca genérica en Java}
    \label{fig:my_label}
\end{figure}	

Los iteradores son objetos que te permiten recorrer una colección de objetos, obteniendo o removiendo elementos. Un objeto iterador implementa la interfaz \textit{Iterator} o la interfaz \textit{ListIterator}. En general, para usar un iterador para recorrer una colección se debe:
    1. Obtener un iterador al inicio de la colección llamando al método $iterator()$ de la colección.
    2. Definir un ciclo que haga la llamada a $hasNext()$. El ciclo iterará mientras el método sea verdadero.
    3. En el ciclo, obtener cada elemento llamando al método $next()$.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// Usando la interfaz Collection
import java.util.List;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class CollectionTest {
	private static final String[] colors = 
       { "MAGENTA", "RED", "WHITE", "BLUE", "CYAN" };
	private static final String[] removeColors = 
       { "RED", "WHITE", "BLUE" };
  
    // crea ArrayList, añade Colors y la manipula
    public CollectionTest() {
    	List< String > list = new ArrayList< String >();      
        List< String > removeList = new ArrayList<String>();
    
        // añade elementos del arreglo colors a list
        for ( String color : colors )
             list.add( color );   

       // añade elementos del arreglo removeColors a removeList
       for ( String color : removeColors )
             removeList.add( color ); 
    
       System.out.println( "ArrayList: " );
       // despliega contenido de list
       for ( int count = 0; count < list.size(); count++ )
             System.out.printf( "%s ", list.get( count ) );
    
       // remueve de list colores contenidos en removeList
       removeColors( list, removeList );
    
       System.out.println( "\n\nArrayList después de llamar removeColors: " );
       // despliega contenido de list
       for ( String color : list )
             System.out.printf( "%s ", color );
    } // end CollectionTest constructor
    
    // remueve colores especificados en collection2 de collection1
    private void removeColors( 
       Collection< String > collection1, Collection< String > collection2 ) {
    	   // obtiene iterator
    	   Iterator< String > iterator = collection1.iterator(); 
    
    	   // mientras colección tiene elementos
    	   while ( iterator.hasNext() )         
       		   if ( collection2.contains( iterator.next() ) )
    			   iterator.remove(); // remueve color actual
    } 
    
    public static void main( String args[] )  {
          new CollectionTest();
    } 
}
\end{minted}
\caption{Ejemplo usando la JCF en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Ejemplos complementarios de Clases Genéricas en Java}

\textcolor{blue}{Ejemplo} de una pila genérica simple\footnote{Basado en: \href{http://cs.fit.edu/~ryan/java/programs/generic/GenericStack-java.html}{Generic Stack}}:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import java.util.*;

public class PilaGenérica <T> {
	private ArrayList<T> pila = new ArrayList<T> ();
    private int tope = 0;
   
    public int size () { 
    	  return tope; 
    }
   
    public void push (T elemento) {
    	  pila.add (tope++, elemento);
    }
  
    public T pop () {
        return pila.remove (--tope);
    }
  
    public static void main (String[] args) {
        PilaGenérica<Integer> p = new PilaGenérica<Integer> ();
        
        p.push (17);
        int i = p.pop ();
        System.out.format ("%4d%n", i);
     }
 }
\end{minted}
\caption{Ejemplo de una pila genérica simple en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\textcolor{blue}{Ejemplo} de una pila genérica como lista ligada\footnote{Ejemplo basado de: \href{http://introcs.cs.princeton.edu/java/43stack/Stack.java.html}{Stack}}:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import java.util.Iterator;
import java.util.NoSuchElementException;

public class Pila<Elemento> implements Iterable<Elemento> {
    private int tamaño;          // tamaño de la pila
    private Nodo primer;     // tope de la pila

    // clase anidada Nodo
    private class Nodo {
        private Elemento elemento;
        private Nodo siguiente;
    }

    // Crea una pila vacia.
    public Pila() {
        primer = null;
        tamaño = 0;
    }

    // Esta vacia la pila?
    public boolean estaVacia() {
        return primer == null;
    }

    // Regresa el número de elementos en la pila
    public int getTamaño() {
        return tamaño;
    }

    // Añade elemento a la pila.
    public void push(Elemento elemento) {
        Nodo viejoPrimer = primer;

     primer = new Nodo();
        primer.elemento = elemento;
        primer.siguiente = viejoPrimer;
        tamaño++;
    }

   /**
     *Regresa el elemento en el tope de la pila y lo elimina.
     *Lanza una excepción si no hay elemento porque la pila este vacia.*/
    public Elemento pop() {
        if (estaVacia()) 
        	throw new RuntimeException("Pila vacía");
        Elemento elemento = primer.elemento;    // guarda elemento para retornarlo
        primer = primer.siguiente;  // elimina el primer nodo
        tamaño--;
        return elemento;                  // regresa elemento 
    }

   /*** Regresa el elemento en el tope de la pila sin modificarla.
     * Lanza una excepción si la pila esta vacía.*/
    public Elemento ver() {
        if (estaVacia()) 
        	throw new RuntimeException("Pila vacía");
        return primer.elemento;
    }

   /*** Regresa representación en cadena.*/
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (Elemento elemento : this)
            s.append(elemento + " ");
        return s.toString();
    }
    //  Regresa un iterador a la pila que itera a través de los elementos en orden LIFO
    public Iterator<Elemento> iterator()  { 
    	return new ListIterator();  
    	}
  // Iterador, no se implementa remove() dado que es opcional
    private class ListIterator implements Iterator<Elemento> {
        private Nodo actual = primer;
        
        public boolean hasNext()  { 
        	return actual != null;                     
        }
        
        public void remove() { 
        	throw new UnsupportedOperationException();  
        }

        public Elemento next() {
            if (!hasNext()) 
            	throw new NoSuchElementException();
            Elemento elemento = actual.elemento;
            actual = actual.siguiente; 
            return elemento;
        }
    }

    public static void main(String[] args) {
        Pila<String> s = new Pila<String>();
        
        String elemento1 = "un texto";
        String elemento2 = "otro elemento";
        String elemento3 = "xxxx";
        
        s.push(elemento1);
        s.push(elemento2);
        s.push(elemento3);
        
        while (!s.estaVacia()) {
           System.out.println(s.pop());
           System.out.println("(" + s.getTamaño() + " elemento(s) quedan en la pila)");
        }
    }
}
\end{minted}
\caption{Ejemplo de una pila genérica como lista ligada en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


%%%PENDIENTE
%Clases Genéricas en Java y comodines (wildcard)  (PENDIENTE) \footnote{https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html} \footnote{https://www.journaldev.com/1663/java-generics-example-method-class-interface}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%



%%%%%%%%%%
% SCALA
%%%%%%%%%%
\ifscala
\newpage
\section{Clases Genéricas en Scala\protect\footnote{\url{https://docs.scala-lang.org/tour/generic-classes.html}}}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {scala}
class Stack[T] {
  var elems: List[T] = Nil
  def push(x: T) { elems = x :: elems }
  def top: T = elems.head
  def pop() { elems = elems.tail }
}

object StackTest {
   def main(args: Array[String]) {
       val stack = new Stack[Int]
        stack.push(1)
        stack.push('a')
        println(stack.top)
        stack.pop()
        println(stack.top)
   }
}
\end{minted}
\caption{Ejemplo de clases genéricas en Scala.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% SCALA_END
%%%%%%%%%%


%%%%%%%%%%
% CSHARP
%%%%%%%%%%
\ifcsharp
\newpage
\section{Clases Genéricas en C\#\protect\footnote{\url{https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/}}}

\ejemplo


\fi
%%%%%%%%%%
% CSHARP_END
%%%%%%%%%%

%%%%%%%%%%
% D
%%%%%%%%%%
\ifd
\newpage
\section{Plantillas en D\protect\footnote{\url{https://dlang.org/spec/template.html}}}

\ejemplo
Ejemplo: \footnote{\url{https://en.wikibooks.org/wiki/A_Beginner\%27s_Guide_to_D/Templates_and_Generic_Programming/Template_Classes}}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {d}
class LinkedStack(T){
    private Node head;
    class Node{
        T item;
        Node next;
        Node prev;
    }
    this(){
        head = new Node;
        head.prev = head;
        head.next = head;
    }

    void push(T t){
        Node temp = new Node;
        temp.item = t;
        head.prev.next = temp;
        temp.prev = head.prev;
        temp.next = head;
        head.prev = temp;
    }
    T pop(){
        Node temp = head.prev;
        temp.prev.next = head;
        head.prev = temp.prev;
        return temp.item;
    }
    T peek(){
        return head.prev.item;
    }
}

void main() {
    import std.stdio;
    
    auto list = new LinkedStack!(int);
    list.push(1);
    list.push(2);
    list.push(3);

    writeln (list.pop());
    
    auto strList = new LinkedStack!(string);
    strList.push("hello");
    strList.push("world!");
    
    writeln(strList.pop());
}
\end{minted}
\caption{Ejemplo de plantillas en D.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% D_END
%%%%%%%%%%


% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Ejercicios de clases genéricas} 
\end{center} 
\\ \hline
   Diseñe una \textbf{clase genérica ''Matriz''} que almacene una matriz de cualquier tipo. La clase debe tener métodos para acceder a un elemento específico en la matriz, para establecer el valor de un elemento específico en la matriz, para obtener el número de filas y columnas de la matriz, y para imprimir la matriz en la consola. Proporcione un ejemplo de cómo se utilizaría la clase para crear una matriz de enteros y una matriz de cadenas.
   Para C++ es posible hacer uso de la clase $vector<T>$ y para Java la clase $ArrayList<E>$
\\ \hline
Implementar una \textbf{clase genérica $Arbol$}, que permita almacenar elementos de cualquier tipo en una estructura de datos de tipo árbol binario. La clase debería tener los siguientes métodos:

\begin{enumerate}
    \item $add(element: T)$: Agrega un elemento al árbol.
    \item $remove(element: T)$: Elimina un elemento específico del árbol.
    \item $search(element: T) -> bool$: Busca un elemento específico en el árbol y devuelve verdadero si se encuentra, falso en caso contrario.
    \item $traverse(order: str) -> List[T]$: Recorre el árbol en el orden especificado ($in-order, pre-order, post-order$) y devuelve una lista con los elementos del árbol en ese orden.
    \item $get\_height() -> int$: devuelve la altura del arbol.
    \item $get\_size() -> int$: devuelve el número de elementos en el árbol.
\end{enumerate}
\\ \hline

\textbf{Almacenamiento Genérico de Datos}

Crea una \textbf{clase genérica llamada \textit{AlmacenamientoDatos\<T\>}} que pueda almacenar y manipular datos de cualquier tipo \textit{T}. La clase debe tener las siguientes funcionalidades:

    \begin{enumerate}
        \item \textbf{Inicialización}: La clase debe inicializarse con una capacidad inicial para almacenar elementos.
        \item \textbf{Agregar Elemento}: Implementa un método\textit{ void agregarElemento(T elemento)} que añade un elemento al almacenamiento. Si el almacenamiento alcanza su capacidad, debería redimensionarse automáticamente para acomodar más elementos.
        \item \textbf{Recuperar Elemento}: Implementa un método \textit{T obtenerElemento(int indice)} que recupera el elemento en el índice especificado.
        \item \textbf{Eliminar Elemento}: Implementa un método\textit{ bool eliminarElemento(T elemento) }que elimina la primera ocurrencia del elemento especificado del almacenamiento. Debería devolver \textit{true} si se encuentra y elimina el elemento; de lo contrario, devolver \textit{false}.
        \item \textbf{Imprimir Todos los Elementos}: Implementa un método \textit{void ImprimirTodosLosElementos()} que imprime todos los elementos en el almacenamiento.
        \item \textbf{Método Genérico}: Implementa un método genérico\textit{ U ProcesarDatos<U>(Func<T, U> funcionProceso) }que tome una función como argumento y la aplique a cada elemento en el almacenamiento. El resultado debería ser una colección de los elementos procesados.
    \end{enumerate}

Probar la clase genérica con varios tipos de datos, como enteros, cadenas y objetos personalizados. También  crear múltiples instancias de la clase \verb|\textit{AlmacenamientoDatos}| con capacidades iniciales diferentes para observar cómo funciona el mecanismo de redimensionamiento.
\\ \hline
Crear una \textbf{subclase} de \verb|\textit{\textbf{AlmacenamientoDatos<T>}}| que agregue funcionalidades o restricciones adicionales, demostrando cómo funciona la herencia y la extensión en el contexto de las clases genéricas.
\\ \hline

\end{tabular}
\end{center}

 

\chapter{Manejo de Excepciones}

Siempre se ha considerado importante el manejo de los errores en un programa, pero no fue hasta que surgió el concepto de\textbf{ manejo de excepciones }que se dio una estructura más formal para hacerlo.

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
 El término de \textbf{excepción} viene de la posibilidad de detectar eventos que no forman parte del curso normal del programa, pero que de todas formas ocurren. 
\\ \hline
\end{tabular}
\end{center}

Un evento \textbf{''excepcional''} puede ser generado por una falla en la conexión a red, un archivo que no puede encontrarse, o un acceso indebido en memoria. La intención de una excepción es responder de manera dinámica a los errores, sin que afecte gravemente la ejecución de un programa, o que al menos se controle la situación posterior al error.

	¿Cuál es la ventaja con respecto al manejo común de errores? 

Normalmente, cada programador agrega su propio código de manejo de errores y queda revuelto con el código del programa. El manejo de excepciones indica claramente en que parte se encuentra el manejo de los errores, separándolo del código normal.  

Además, es posible recibir y tratar muchos de los errores de ejecución y tratarlos correctamente, como podría ser una división entre cero.

Se recomienda el manejo de errores para aquellas situaciones en las cuales el programa necesita ayuda para recuperarse. 

%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Manejo de Excepciones en C++}


El manejo de excepciones en C++, involucra los siguientes elementos sintácticos:
 
\textbf{try}. El bloque definido por la instrucción try, especifica el código que potencialmente podría generar un error que deba ser manejado por la excepción:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
try {
        // instrucciones donde las excepciones 
        // pueden ser generadas
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\textbf{throw}. Esta instrucción seguida por una expresión de un cierto tipo, genera  una excepción del tipo de la expresión. Esta instrucción debería ser ejecutada dentro de algún bloque \textit{try}, de manera directa o indirecta:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}| throw "Se genera una excepción de tipo char *";  |\\
\hline
\end{tabular}
\end{center}

\textbf{catch}. La instrucción \textit{catch} va seguida de un bloque \textit{try}. \textit{Catch} define un segmento de código para tratar una excepción (de un tipo) lanzada:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{cpp}
catch (char *mensaje) {
        // instrucciones donde la excepción
        // thrown char * 
        // será procesada
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// exceptions
#include <iostream>
using namespace std;

int main () {
  try
  {
    throw 20;
  }
  catch (int e)
  {
    cout << "Una excepción ocurrió. Número: " << e << endl;
  }
  return 0;
}
\end{minted}
\caption{Ejemplo de manejo de excepciones en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\subsection{Excepciones estandar en C++}

La biblioteca estándar de C++ proporciona una clase base diseñada específicamente para declarar objetos que pueden ser lanzados como excepciones. La clase \textit{exception} esta declarada en $<exception>$ (en el espacio de nombres \textit{std}).  La clase tiene entre otras cosas un método virtual llamado \textit{what} que regresa un arreglo de caracteres y puede ser redefinida en clases derivadas para describir la excepción.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// excepciones estándar
#include <iostream>
#include <exception>
using namespace std;

class myexception: public exception
{
  virtual const char* what() const throw()
  {
    return "Mi excepción se ejecutó";
  }
} myex;

int main () {
  try
  {
    throw myex;
  }
  catch (exception& e)
  {
    cout << e.what() << endl;
  }
  return 0;
}
\end{minted}
\caption{Ejemplo excepciones estandar en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Las clases de la biblioteca estándar implementan clases derivadas de la clase \textit{exception} para poder lanzar excepciones derivadas de esta clase.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
// excepción bad_alloc 
#include <iostream>
#include <exception>
using namespace std;

int main () {
  try
  {
    int* myarray= new int[1000];
  }
  catch (exception& e)
  {
    cout << "Excepción estándar: " << e.what() << endl;
  }
  return 0;
}
\end{minted}
\caption{Ejemplo excepción C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%



%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Manejo de Excepciones en Java}

El modelo de excepciones de Java es similar al de C y C++, pero mientras en estos lenguajes no estamos obligados a manejar las excepciones, en Java es forzoso para el uso de ciertas clases; de lo contrario, el compilador generará un error.

\subsection{¿Cómo funciona?}

Muchas tipos de errores pueden provocar una excepción, desde un desbordamiento de memoria o un disco duro estropeado hasta un intento de dividir por cero o intentar acceder a un arreglo fuera de sus límites. Cuando esto ocurre, la máquina virtual de Java crea un objeto de la clase \textit{Exception} o \textit{Error} y se notifica el hecho al sistema de ejecución. En este punto, se dice que se ha lanzado una excepción. 

Un método se dice que es capaz de tratar una excepción si ha \textbf{previsto} el error que se ha producido y prevé también las operaciones a realizar para “recuperar” el programa de ese estado de error.

En el momento en que es lanzada una excepción, la máquina virtual de Java recorre la pila de llamadas de métodos en busca de alguno que sea capaz de tratar la clase de excepción lanzada. Para ello, comienza examinando el método donde se ha producido la excepción; si este método no es capaz de tratarla, examina el método desde el que se realizó la llamada al método donde se produjo la excepción y así sucesivamente hasta llegar al último de ellos. En caso de que ninguno de los métodos de la pila sea capaz de tratar la excepción, la máquina virtual de Java muestra un mensaje de error y el programa termina.

Los programas escritos en Java también pueden lanzar excepciones explícitamente mediante la instrucción throw, lo que facilita la devolución de un código de error al método que invocó el método que causó el error. 

	Un \textcolor{blue}{ejemplo} de una excepción generada (y no tratada) es el siguiente programa:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class Excepcion {
	public static void main(String argumentos[]) {
		int i=5, j=0;
		int k=i/j; // División por cero
	}
}
\end{minted}
\caption{Ejemplo de excepción en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Al ejecutarlo, se verá que la máquina virtual Java ha detecta una condición de error y ha crea un objeto de la clase $java.lang.ArithmeticException$. Como el método donde se ha producido la excepción no es capaz de tratarla, es manejada por la máquina virtual Java, que muestra un mensaje de error y finaliza la ejecución del programa.

\subsection{Lanzamiento de excepciones (\textit{throw})}

Como se ha comentado anteriormente, un método también es capaz de lanzar excepciones. 

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
método ( ) throws <lista de excepciones> {
	//código
	...	
	throw new <nombre Excepción>
	...
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

donde $<lista de excepciones>$ es el nombre de cada una de las excepciones que el método puede lanzar.

Por ejemplo, en el siguiente programa se genera una condición de error si el dividendo es menor que el divisor:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class LanzaExcepcion {
	public static void main(String argumentos[]) throws ArithmeticException {
		
		int i=1, j=0;
		if (j==0)
			throw new ArithmeticException();
		else
			System.out.println(i/j);
	}
}
\end{minted}
\caption{Ejemplo lanzamiento de excepción en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Para lanzar la excepción es necesario crear un objeto de tipo \textit{Exception} o alguna de sus subclases (por ejemplo: $ArithmeticException$) y lanzarlo mediante la instrucción \textit{throw}.

Los dos ejemplos vistos anteriormente, son capaces de lanzar una excepción en un momento dado, pero hasta aquí no difieren en mucho en su ejecución, ya que el resultado finalmente es la terminación del programa. En la siguiente sección se menciona como podemos darles un manejo especial a las excepciones, de tal forma que el resultado puede ser previsto por el programador.

\subsection{Manejo de excepciones}

En Java, de forma similar a C++ se pueden tratar las excepciones previstas por el programador utilizando unos mecanismos, los manejadores de excepciones, que se estructuran en tres bloques:


\begin{itemize}
\item El bloque \textit{try}.
\item El bloque \textit{catch}.
\item El bloque \textit{finally}.
\end{itemize}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Concepto} 
\end{center} 
\\ \hline
Un \textbf{manejador de excepciones} es una porción de código que se va a encargar de tratar las posibles excepciones que se puedan generar. 
\\ \hline
\end{tabular}
\end{center}

\subsubsection{El bloque \textit{try}}

Lo primero que hay que hacer para que un método sea capaz de tratar una excepción generada por la máquina virtual Java o por el propio programa mediante una  instrucción \textit{throw}, es encerrar las instrucciones susceptibles de generarla en un bloque \textit{try}.

\begin{minted}{java}
try {
<instrucciones>
}
...
\end{minted}

Cualquier excepción que se produzca dentro del bloque \textit{try} será analizada por el bloque o bloques \textit{catch} que se verá en el punto siguiente. En el momento en que se produzca la excepción, se abandona el bloque \textit{try} y, por lo tanto, las instrucciones que sigan al punto donde se produjo la excepción no serán ejecutadas. 

\subsubsection{El bloque catch}

Cada bloque \textit{try} debe tener asociado por lo menos un bloque \textit{catch}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
try {
	<instrucciones>
} catch (TipoExcepción1 nombreVariable1) {
<instruccionesBloqueCatch1>
} catch (TipoExcepción2 nombreVariable2) {
<instruccionesBloqueCatch2>
}
...
catch (TipoExcepciónN nombreVariableN) {
<instruccionesBloqueCatchN>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Por cada bloque \textit{try} pueden declararse uno o varios bloques \textit{catch}, cada uno de ellos capaz de tratar un tipo de excepción.

Para declarar el tipo de excepción que es capaz de tratar un bloque \textit{catch}, se declara un objeto cuya clase es la clase de la excepción que se desea tratar o una de sus superclases.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class ExcepcionTratada {
	public static void main(String argumentos[]) {
		int i=5, j=0;
		try {
			int k=i/j;
			System.out.println("Esto no se va a ejecutar.");
		}
		catch (ArithmeticException ex) {
			System.out.println("Ha intentado dividir por cero");
		}
		System.out.println("Fin del programa");
	}
}
\end{minted}
\caption{Ejemplo de excepción tratada en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

La ejecución se resuelve de la siguiente forma:

    
\begin{enumerate}
\item Cuando se intenta dividir por cero, la máquina virtual Java genera un objeto de la clase \textit{ArithmeticException}. 
\item Al producirse la excepción dentro de un bloque \textit{try}, la ejecución del programa se pasa al primer bloque \textit{catch}. 
\item Si la clase de la excepción se corresponde con la clase o alguna subclase de la clase declarada en el bloque \textit{catch}, se ejecuta el bloque de instrucciones catch y a continuación se pasa el control del programa a la primera instrucción a partir de los bloques \textit{try-catch}.
\end{enumerate}

También se podría haber utilizado en la declaración del bloque \textit{catch}, una superclase de la clase \textit{ArithmeticException}. 

Por ejemplo:

\mint[linenos=false]{java}| catch (RuntimeException ex) |

o

\mint[linenos=false]{java}| catch (Exception ex) |

Sin embargo, es mejor utilizar excepciones más cercanas al tipo de error previsto, ya que lo que se pretende es recuperar al programa de alguna condición de error y si tratan de capturar todas las excepciones de una forma muy general, posiblemente habrá que averiguar después qué condición de error se produjo para poder dar una respuesta adecuada. 

\subsubsection{El bloque \textit{finally}}

El bloque \textit{finally} se utiliza para ejecutar un bloque de instrucciones sea cual sea la excepción que se produzca. Este bloque se ejecutará en cualquier caso, \textbf{incluso} si no se produce ninguna excepción. 

Este bloque \textbf{garantiza} que el código que contiene será ejecutado independientemente de que se genere o no una excepción:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
try {
	<instrucciones>
	}
catch (TipoExcepción1 nombreVariable1) {
	<instruccionesBloqueCatch1>
} 

catch (TipoExcepción2 nombreVariable2) {
	<instruccionesBloqueCatch2>
}
	...
catch (TipoExcepciónN nombreVariableN) {
	<instruccionesBloqueCatchN>
}
finally {
	<instruccionesBloqueFinally>
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Es utilizado para no tener que repetir código en el bloque \textit{try} y en los bloques \textit{catch}. Este código sirve para llevar a buen término el bloque de código independientemente del resultado.

Veamos ahora la clase \textit{ExcepcionTratada} con el bloque \textit{finally}. \ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class ExcepcionTratada {
	public static void main(String argumentos[]) {
		int i=5, j=0;
		try {
			int k=i /* /j */;//probar con y sin error
		} 
		catch (ArithmeticException ex) {
			System.out.println("Ha intentado dividir por cero");
		}
		finally {
			System.out.println("Salida de finally");
		}
		System.out.println("Fin del programa");
	}
}
\end{minted}
\caption{Ejemplo de excepción con \textit{finally} en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Un \textcolor{blue}{ejemplo} derivando la clase Exception de Java en un estilo similar al uso de la clase correspondiente en C++:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class DivisionByZeroException extends Exception {
		DivisionByZeroException(String msg) { super(msg); }
}  
 
public class DivisionByZero {
    public void division() throws DivisionByZeroException {            
        int num1 = 10;
        int num2 = 0;

        if (num2 == 0) 
        	throw new DivisionByZeroException("/ entre 0");  
        System.out.println(num1 + " / " + num2 + " = " + (num1 / num2));
        System.out.println("terminando division().");
    }

    public static void main(String args[]) {
         try {
        	 new DivisionByZero().division();
         } catch (DivisionByZeroException e) {                       
        	 System.out.println("En main, tratando con " + e);
         } finally {                                               
             System.out.println("Finally ejecutado en main.");
         }
         System.out.println("Finalizando main.");               
    }
}
\end{minted}
\caption{Ejemplo derivando de \textit{Exception} en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Jerarquía de excepciones}

Las excepciones son objetos pertenecientes a la clase \textit{Throwable} o alguna de sus subclases.

Dependiendo del lugar donde se produzcan existen dos tipos de excepciones:


\begin{enumerate}
\item Las excepciones \textbf{síncronas} no son lanzadas en un punto arbitrario del programa sino que, en cierta forma, son previsibles en determinados puntos del programa como resultado de evaluar ciertas expresiones o la invocación de determinadas  instrucciones o métodos.
\item Las excepciones \textbf{asíncronas} pueden producirse en cualquier parte del programa y no son tan previsibles. Pueden producirse excepciones asíncronas debido a dos razones:
\begin{itemize}
\item La invocación del método \textit{stop()} de la clase \textit{Thread} que se está ejecutando. 
\item Un error interno en la máquina virtual Java.
\end{itemize}
\end{enumerate}


Dependiendo de si el compilador comprueba o no que se declare un manejador para tratar las excepciones, se pueden dividir en:


\begin{enumerate}
\item Las excepciones \textbf{comprobables} son repasadas por el compilador Java durante el proceso de compilación, de forma que si no existe un manejador que las trate, generará un mensaje de error.
\item Las excepciones \textbf{no comprobables} son la clase \textit{RuntimeException} y sus subclases junto con la clase \textit{Error} y sus subclases.
\end{enumerate}

También pueden definirse por el programador subclases de las excepciones anteriores. Las más interesantes desde el punto de vista del programador son las subclases de la superclase \textit{Exception} ya que éstas pueden ser \textbf{comprobadas} por el compilador.

La jerarquía completa de excepciones existentes en el paquete $java.lang$ se puede consultar más adelante\footnote{Para un listado actual ver la documentación del jdk de Java más reciente.}.


\subsection{Excepciones definidas por el usuario}

A partir de la jerarquía de excepciones definidas, es posible para el programador especificar su propia excepción tomando como base alguna de las excepciones de la jerarquía. Por ejemplo:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class MiExcepcion extends Exception{
    String cad;
    
    /* El constructor de nuestra excepción copia a una cadena
    el mensaje que se pasa al lanzar la excepción
    */
    
    MiExcepcion(String msj) {
     cad=msj;
    }
    public String toString(){ 
     return ("Se lanzó MiExcepcion: "+cad) ;
    }
 }
 
 class EjemploMiExcepcion{
    public static void main(String args[]){
     try{
         System.out.println("Iniciando bloque try");
         // Lanzando mi propia excepción
         throw new MiExcepcion("Mi mensaje de error");
     }
     catch(MiExcepcion exp){
         System.out.println("Bloque catch") ;
         System.out.println(exp) ;
     }
    }
 }
\end{minted}
\caption{Ejemplo de excepción definida por el programador.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}




\subsection{Ventajas del tratamiento de excepciones}

Las ventajas, mencionadas por Díaz-Alejo\footnote{Díaz-Alejo Gómez, J.A., Programación con Java, IES Camp, Valencia, España, Last access: September 2006}, de un mecanismo de tratamiento de excepciones como este son varias:


\begin{itemize}
\item Separación del código ''útil'' del tratamiento de errores.
\item Propagación de errores a través de la pila de métodos.
\item Agrupación y diferenciación de errores mediante jerarquías.
\item Claridad del código y obligación del tratamiento de errores.
\end{itemize}

\subsection{Lista de Excepciones\protect\footnote{Lista obtenida de la documentación del jdk en su versión 1.6}}

La jerarquía de clases derivadas de \textit{Error} existentes en el paquete $java.lang$ es la siguiente:

\begin{alltt}
    •  java.lang.Object
        ◦ java.lang.Throwable (implements java.io.Serializable) 
    • java.lang.Error
        ◦ java.lang.AssertionError
        ◦ java.lang.LinkageError
             java.lang.ClassCircularityError
             java.lang.ClassFormatError
                • java.lang.UnsupportedClassVersionError
             java.lang.ExceptionInInitializerError
             java.lang.IncompatibleClassChangeError
                • java.lang.AbstractMethodError
                • java.lang.IllegalAccessError
                • java.lang.InstantiationError
                • java.lang.NoSuchFieldError
                • java.lang.NoSuchMethodError
             java.lang.NoClassDefFoundError
             java.lang.UnsatisfiedLinkError
             java.lang.VerifyError
        ◦ java.lang.ThreadDeath
        ◦ java.lang.VirtualMachineError
             java.lang.InternalError
             java.lang.OutOfMemoryError
             java.lang.StackOverflowError
             java.lang.UnknownError
\end{alltt}

La jerarquía de clases derivadas de \textit{Exception} existentes en el paquete $java.lang$ es la siguiente:

\begin{alltt}
    • java.lang.Object
        ◦ java.lang.Throwable (implements java.io.Serializable) 
        ◦ java.lang.Exception
    • java.lang.ClassNotFoundException
    • java.lang.CloneNotSupportedException
    • java.lang.IllegalAccessException
    • java.lang.InstantiationException
    • java.lang.InterruptedException
    • java.lang.NoSuchFieldException
    • java.lang.NoSuchMethodException
    • java.lang.RuntimeException
        ◦ java.lang.ArithmeticException
        ◦ java.lang.ArrayStoreException
        ◦ java.lang.ClassCastException
        ◦ java.lang.EnumConstantNotPresentException
        ◦ java.lang.IllegalArgumentException
             java.lang.IllegalThreadStateException
             java.lang.NumberFormatException
        ◦ java.lang.IllegalMonitorStateException
        ◦ java.lang.IllegalStateException
        ◦ java.lang.IndexOutOfBoundsException
             java.lang.ArrayIndexOutOfBoundsException
             java.lang.StringIndexOutOfBoundsException
        ◦ java.lang.NegativeArraySizeException
        ◦ java.lang.NullPointerException
        ◦ java.lang.SecurityException
        ◦ java.lang.TypeNotPresentException
        ◦ java.lang.UnsupportedOperationException
\end{alltt}

Las  principales excepciones en otros paquetes Java son:

\begin{alltt}
    • class java.lang.Object
        ◦ class java.lang.Throwable 
             class java.lang.Error 
                • java.awt.AWTError
             class java.lang.Exception 
    • java.io.IOException
    • java.io.EOFException
    • java.io.FileNotFoundException
    • java.io.InterruptedIOException
    • java.io.UTFDataFormatException
    • java.net.MalformedURLException
    • java.net.ProtocolException
    • java.net.SocketException
    • java.net.UnknownHostException
    • java.net.UnknownServiceException
    • RuntimeException
    • java.util.EmptyStackException
    • java.util.NoSuchElementException
    • java.awt.AWTException
\end{alltt}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% RUBY
%%%%%%%%%%
\ifruby
\newpage
\section{Manejo de Excepciones en Ruby}

Ruby soporta el manejo de excepciones como cualquier lenguaje actual de programación. El manejo de excepciones en Ruby, involucra los siguientes elementos sintácticos:


\subsection{\textit{Raise \& Rescue}}

	La ejecución de \textit{raise} produce una excepción. \textit{raise} es un método del módulo Kernel y tiene un alias definido como \textit{fail}. La sintaxis se presenta a continuación:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{ruby}| raise ExceptionClass[, "message"]  |\\
\hline
\end{tabular}
\end{center}

Ejemplo:
\begin{minted}{ruby}
raise  	# se relanza la ultima excepcion
raise "Danger, Will Robinson!"
raise “Houston, we have a problem”
raise ArgumentError, "Falla de datos"
raise ArgumentError.new("Falla de datos")
raise "Falta nombre" if nombre.nil?
\end{minted}

Ahora, ¿Cómo agrupamos un segmento de código en el cual se quieren manejar excepciones? Podemos agrupar el código usando un bloque \textit{begin end}. Dentro podemos incluir la claúsula \textit{rescue}, por ejemplo: 

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
begin
  expr..
[rescue [tipo_de_error [=> var],..]
  expr..]..
[else
  expr..]
[ensure
  expr..]
end
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

La sintaxis anterior implica que podemos poner una serie de clausulas \textit{rescue} especificando diferentes tipos de errores que pueden ser “rescatados” y la claúsula \textit{else} recibiría aquellos errores que no entren dentro de los especificados por \textit{rescue}. 

La cláusula \textit{ensure} es usada para especificar código que queremos que se ejecute independientemente del error generado. Por ejemplo:

\begin{minted}{ruby}
begin
  # Error...
rescue
  # intento de recuperación...
  retry # tratar de nuevo
ensure
  # Este código es siempre ejecutado
end
\end{minted}

%ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
def raise_exception  
   puts 'Antes de raise.'  
   raise 'Ocurrio un error'  
   puts 'Después de raise'  
end  
raise_exception

def raise_y_rescue  
	begin  
		puts 'Antes de raise.'  
    	raise 'Ocurrio un error.'  
    	puts 'Después de raise.'  
    	rescue  
    	puts 'Siendo rescatado.'  
	end  
	puts 'Despues del bloque begin - end.'  
end  
raise_y_rescue

begin
	# ...  
	rescue UnaExepcion  
   	# ...  
   	rescue OtroTipoDeExepcion  
   	# ...  
   	else  
    # Otras exceciones  
end

begin  
	raise "Probando excepciones." 
    rescue Exception => e
    	puts "Salida:"
		puts e.message  
		puts e.backtrace.inspect  
		puts "fin salida."
end

x = a/b rescue puts("Division entre cero!")
\end{minted}
\caption{Ejemplo de excepciones en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Jerarquía de excepciones}

Las excepciones en Ruby dependen de una jerarquía de herencia la cual tiene como superclase a \textit{Exception}\footnote{Davis, R., Ruby QuickRef, 2004, \url{http://www.zenspider.com/Languages/Ruby/QuickRef.html, Last access: June 2008}}:

\begin{alltt}
*  Exception
          o NoMemoryError
          o ScriptError
                + LoadError
                + NotImplementedError
                + SyntaxError
          o SignalException
                + Interrupt
          o StandardError (default for rescue)
                + ArgumentError
                + IOError
                      # EOFError
                + IndexError
                + LocalJumpError
                + NameError
                      # NoMethodError
                + RangeError
                      # FloatDomainError
                + RegexpError
                + RuntimeError (default for raise)
                + SecurityError
                + SystemCallError
                      # Errno::*
                + SystemStackError
                + ThreadError
                + TypeError
                + ZeroDivisionError
          o SystemExit
          o fatal
\end{alltt}

De igual forma es posible derivar algunas de las clases de la jerarquía de excepciones para crear una excepción más especializada.

\subsection{\textit{Catch \& Throw}}

Es posible en Ruby usar también los clásicos \textit{catch \& throw} los cuales son usados comúnmente cuando es necesario saltar de un punto de anidamiento más profundo\cite{thomas2005programming}.

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{ruby}
catch (:label) do 
	#... 
end

throw :label  #salta atrás hasta el catch correspondiente y ejecuta el bloque
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

%ejemplo


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {ruby}
def pregunta pr
print pr
res = readline.chomp
throw :salida_solicitada if res == "!"
res
end

catch :salida_solicitada do
nombre = pregunta "Nombre: "
edad = pregunta "Edad: "
sexo = pregunta "Sexo: "
# ...
end
\end{minted}
\caption{Ejemplo \textit{catch \& throw} en Ruby.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% RUBY_END
%%%%%%%%%%


%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Manejo de Excepciones en Python}

Como la mayoría de los lenguajes actuales, Python soporta el manejo de excepciones. Un resumen de la forma en que funcionan se muestra a continuación:

\begin{itemize}
\item \textit{try/except}. Capturar y recuperarse de excepciones levantadas por Python o por nuestro código.
\item \textit{try/finally}. Ejecutar acciones de limpieza ya sea que ocurran o no excepciones.
\item \textit{raise}. Lanzar una excepción manualmente en nuestro código.
\end{itemize}

De manera similar a otros lenguajes, podemos ver excepciones que son generadas por diversas situaciones y al no ser manejadas implican la interrupción de la ejecución del programa.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#Ejemplo de excepción lanzada por un error en código

i=5
j=0
k=i/j
\end{minted}
\caption{Ejemplo de excepción lanzada en python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En el siguiente ejemplo vemos el uso de \textit{raise} para lanzar una excepción manualmente en nuestro código.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#ejemplo de lanzamiento de excepción sin tratamiento

i=1
j=0
if j==0 :
    raise ZeroDivisionError('División entre 0')
else:
    print(i/j)
\end{minted}
\caption{Ejemplo de lanzamiento de excepción sin tratamiento en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

De manera similar a los otros lenguajes, lo adecuado es manejar las posibles excepciones mediante bloques especiales. La sintaxis general es:

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{python}
try: 
     <instrucciones>
except [<tipo> [as <variable>]]: 
     <instrucciones>
[except [<tipo> [as <variable>]]: 
     <instrucciones>]* 
[else: 
     <instrucciones>] 
[finally: 
     <instrucciones>] 
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

En el siguiente ejemplo, vemos como se maneja la división entre cero con el bloque \textit{try/except}.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#tratamiento de excepciones

i=5
j=0

try:
    k=i/j
    print('Esto no se va a ejecutar')
except ZeroDivisionError:
    print('Ha intentado dividir por cero')

print('fin del programa')
\end{minted}
\caption{Ejemplo de tratamiento de excepciones en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En el siguiente agregamos el bloque \textit{finally}, que se ejecuta independientemente de que se genere o no la excepción.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#tratamiento de excepciones y tratamiento general con finally

i=5
j=0

try:
    k=i/j
    print('Esto no se va a ejecutar')
except ZeroDivisionError:
    print('Ha intentado dividir por cero')
finally:
    print('Salida de finally')

print('fin del programa')
\end{minted}
\caption{Ejemplo de tratamiento de excepciones y tratamiento general con finally en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

También podemos definir nuestra propia jerarquía de excepciones si así lo consideramos necesario.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#Excepción definida por el usuario

class DivisionByZeroException (Exception):
    def __str__(self):
        return 'Mi excepcion'

class DivisionByZero:
    def division(self):
        num1=10
        num2=0

        if num2==0:
            raise DivisionByZeroException()

        print('División: ' + str(num1/num2)) 

#script
try:
    DivisionByZero().division()
except DivisionByZeroException:
    print('Ejecutando script, detectando excepción')
finally:
    print('Finally siendo ejecutado en el script de pruebe')

print('Finalizando main')
\end{minted}
\caption{Ejemplo de excepción definida por el usuario en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Toda excepción que creemos debe ser una subclase de \textit{Exception}. La figura \ref{fig:excep_python_jerarquia} muestra la jerarquía de herencia de las excepciones de Python.

\begin{figure}
    \centering
    \includegraphics[scale=.6]{imagenes/excepciones_python.png}
    \caption{ Jerarquía de herencia de las excepciones en Python }
    \label{fig:excep_python_jerarquia}
\end{figure}

Un resumen se puede ver en el cuadro \ref{tab:resumen_excep_python}.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\caption{Resumen de excepciones de Python}
\label{tab:resumen_excep_python}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|}
\hline
\rowcolor[HTML]{C0C0C0} 
Opción                                                                                                       & Interpretación                                                                   \\ \hline
except:                                                                                                      & Recibe todas las excepciones. O todas las demás si ya se recibieron otras antes. \\ \hline
except \textless{}tipo\textgreater{}:                                                                        & Recibe una excepción en particular.                                              \\ \hline
except \textless{}tipo\textgreater as \textless{}variable\textgreater{}:                                     & Recibe la excepción y asigna su instancia                                        \\ \hline
except (\textless{}tipo1\textgreater{}, \textless{}tipo2\textgreater{}):                                     & Recibe todas las excepciones indicadas.                                          \\ \hline
except (\textless{}tipo1\textgreater{}, \textless{}tipo2\textgreater{}) as \textless{}variable\textgreater{} & Recibe todas las excepciones indicadas y asigna su instancia a una variable.     \\ \hline
else:                                                                                                        & Se ejecuta si no es lanzada ninguna excepción en el bloque try.                  \\ \hline
finally:                                                                                                     & Siempre se ejecuta al salir del segmento de manejo de excepciones.               \\ \hline
\end{tabular}%
}
\end{table}

Un ejemplo resumiendo las opciones en un solo programa:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
# Ejemplo try/except/else/finally
sep = '-' * 45 + '\n'
print(sep + 'Excepción lanzada y cachada')
try:
    x = 'spam'[99]
except IndexError as e:
    print('except: ', e)
finally:
    print('finally')
print('después de bloque try')

print(sep + 'NO se lanza excepción')
try:
    x = 'spam'[3]
except IndexError:
    print('except')
finally:
    print('finally')
print('después de bloque try')

print(sep + 'NO se lanza excepción, con opción else')
try:
    x = 'spam'[3]
except IndexError:
    print('except')
else:
    print('else')
finally:
    print('finally')
print('after')

print(sep + 'Excepción lanzada pero no cachada')
try:
    x=1 /0
except IndexError:
    print('except')
finally:
    print('finally')
print('after')
\end{minted}
\caption{Ejemplo resumiendo opciones de manejo de excepciones en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%

\part{Más allá de los Objetos}

\chapter{Afirmaciones}

Las afirmaciones son usadas para verificar \textbf{invariantes} en un programa \cite{gosling2005java}. Es una manera simple de probar una condición que \textbf{siempre} debe ser verdadera. Si la afirmación resulta ser falsa se considera un error y se interrumpe la ejecución. Escribir afirmaciones mientras se programa es una de las más rápidas y efectivas formas de detectar y corregir errores \cite{sun2002}. 

Las afirmaciones por lo tanto son usadas para comprobar código que se asume será verdadero, siendo la afirmación la parte responsable de verificar que realmente es verdadero.

Las afirmaciones pueden ser utilizadas como una aproximación de la técnica de \textbf{diseño por contrato}. Podemos usar afirmaciones para definir\footnote{\href{https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html}{Java assert}}:

\begin{itemize}
\item Precondiciones. Predicados que deben ser verdaderos cuando un método es invocado.
\item Postcondiciones. Predicados que deben ser verdaderos después de la ejecución exitosa de un método. 
\item Invariantes de clase. Predicados que deben ser verdaderos para cada instancia de una clase.
\end{itemize}


%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section{Afirmaciones en C++}
Las afirmaciones en C++ se manejan a través de la macro\footnote{\href{http://www.cplusplus.com/reference/cassert/assert/}{C++ assert}}:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{cpp}| assert (int expression)  |\\
\hline
\end{tabular}
\end{center}

Que se encuentra en la biblioteca \textit{assert.h}.  Si la expresión dentro de \textit{assert} es falsa, se interrumpirá la ejecución del programa.

Las afirmaciones serán deshabilitadas si previo a la introducción de la biblioteca se introduce la instrucción de preprocesador definiendo la macro \textit{NDEBUG}:

\mint[linenos=false]{cpp}| #define NDEBUG |

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {cpp}
/* Ejemplo assert  */
#include <stdio.h>     
#include <assert.h>    

void print_number(int* myInt) {
  assert (myInt!=NULL);
  printf ("%d\n",*myInt);
}

int main (){
  int a=10;
  int * b = NULL;
  int * c = NULL;

  b=&a;
  print_number (b);
  print_number (c);

  return 0;
}
\end{minted}
\caption{Ejemplo de afirmaciones en C++.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%


%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\newpage
\section{Afirmaciones en Java}

Las afirmaciones fueron introducidas en Java desde la versión 1.4 del jdk.  Cada afirmación debe contener una expresión booleana (\textit{boolean} o \textit{Boolean}). 

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}| assert Expression1;  |\\
 o \\
 \mint[linenos=false]{java}| assert Expression1 : Expression2 ;  |\\
\hline
\end{tabular}
\end{center}

donde \textit{Expression1} es una expresión booleana. Esta expresión es la evaluada y si es falsa la excepción \textit{AssertionError} es lanzada. \textit{Expression2} es una expresión que devuelve un valor (no \textit{void}) que generalmente es usado para proveer de un mensaje para la excepción \textit{AssertionError}.

\subsection{Usando afirmaciones}

Es importante no introducir código en las afirmaciones que en realidad sea una acción del programa. Por ejemplo:

\mint[linenos=false]{java}| assert ++i < max; |

Es inapropiado pues se esta modificando el estado del programa al mismo tiempo que validando. Lo correcto sería algo del estilo:

\begin{minted}{java}
i++;
assert i < max;
\end{minted}

Errores detectados con afirmaciones deben ser errores que no deben pasar. Es por esto que se lanza un subtipo de \textit{Error} en lugar de un subtipo de \textit{Exception}. Si falla la validación de una afirmación se asume un error grave que nunca debe pasar.

\subsection{Habilitando y deshabilitando las afirmaciones}

Por omisión, las afirmaciones están deshabilitadas en tiempo de ejecución. Para cambiar de un estado a otro deben aplicarse parámetros especiales en la ejecución de la máquina virtual de Java:

\begin{alltt}
-enableassertions | -ea 
-disableassertions | -da   
\end{alltt}

Estos modificadores pueden no llevar a su vez argumentos, por lo que active o desactiva las afirmaciones para todas las clases, o pueden indicarse nombres de paquetes ó clases específicas:

\begin{alltt}
-enablesystemassertions | –esa
-disablesystemassertions | -dsa.
\end{alltt}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Recuerda habilitar el uso de afirmaciones
public class AssertionEjemplo {
   public static void main(String argv[])  {
      //obtener un número del primer argumento
      int num = Integer.parseInt(argv[0]);
      
	  assert num <=10;  //se detiene si num>10
         
      System.out.println("Pasó");
   }
}
\end{minted}
\caption{Ejemplo de afirmaciones en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%

%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Afirmaciones en Python}

Python también soporta la instrucción \textit{assert} para  lanzar una excepción de manera condicional en nuestro código. La sintaxis es la siguiente:

%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{python}| assert <expresión> [, ‘mensaje opcional’]  |\\
\hline
\end{tabular}
\end{center}

Que en realidad equivale a lanzar la excepción

\mint[linenos=false]{python}| raise AssertionError() |

bajo una condición.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#Ejemplo de assert

def printNumber(myInt):
    assert myInt!=None, 'Dato no debe ser nulo'
    print(myInt)

a=10
b=None
c=None

b=a
printNumber(b)
printNumber(c)
\end{minted}
\caption{Ejemplo de afirmaciones en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Para descartar la ejecución de las afirmaciones se tiene que ejecutar el Python con la opción en la línea de comandos de  -O (activando modo de Optimización), poniendo la variable $\_\_debug\_\_$ en falso\footnote{\href{https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement}{Assert statement}}:

\mint[linenos=false]{bash}| $ python -O |



\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%

%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\section{Pruebas de unidad en Python}

Las pruebas unitarias, también conocidas como unit testing en inglés, son una práctica fundamental en el desarrollo de software que se utiliza para verificar que las unidades individuales de código, como funciones o métodos, funcionen correctamente de forma aislada. Estas pruebas se centran en evaluar pequeñas partes del código de manera independiente, lo que facilita la identificación temprana de errores y garantiza que cada componente del programa se comporte como se espera.

Las pruebas unitarias son esenciales para asegurar la calidad y la robustez del código Python. Al realizar pruebas unitarias, se pueden detectar y corregir problemas antes de que se propaguen a otras partes del sistema. Esto promueve una mayor confiabilidad y mantenibilidad del código, ya que los errores se encuentran y se corrigen de manera más eficiente.

En Python, existen varios módulos y bibliotecas que se utilizan comúnmente para realizar pruebas unitarias y pruebas de software. Algunos de los módulos de pruebas más populares son:

    \begin{itemize}
        \item \textbf{unittest}: Este es el módulo de pruebas unitarias estándar en la biblioteca estándar de Python. Está inspirado en el marco de pruebas JUnit de Java y proporciona un conjunto completo de herramientas para escribir y ejecutar pruebas unitarias.
        \item \textbf{pytest}: pytest es una biblioteca de pruebas muy popular que ofrece una sintaxis simple y poderosa para escribir pruebas. Se destaca por su capacidad para descubrir y ejecutar automáticamente pruebas en un proyecto, lo que hace que la configuración sea más sencilla.
    \end{itemize}


\subsection{Pytest}

Pytest es un marco de pruebas unitarias en Python que simplifica la escritura y ejecución de pruebas. A diferencia de la biblioteca de pruebas estándar "unittest", pytest ofrece una sintaxis más sencilla y expresiva para crear pruebas, lo que facilita su adopción y uso. Además, pytest proporciona una amplia gama de características avanzadas y complementos para abordar diferentes situaciones de prueba.

Ventajas de pytest:

    \begin{enumerate}
        \item Sintaxis Clara: La sintaxis de pytest es simple y legible, lo que permite escribir pruebas de manera más eficiente y comprensible.
        \item Descubrimiento Automático de Pruebas: pytest puede descubrir y ejecutar automáticamente pruebas en todo un proyecto sin requerir una configuración extensa. Esto ahorra tiempo y esfuerzo en la configuración de pruebas.
        \item Amplia Compatibilidad: Pytest es compatible con otros marcos de pruebas como unittest, lo que facilita la migración de pruebas existentes.
        \item Parametrización: Permite ejecutar la misma prueba con múltiples conjuntos de datos, lo que simplifica las pruebas con diferentes casos de entrada.
    \end{enumerate}


\subsubsection{Ejemplos de Prueba Unitaria con pytest en Python}

Supongamos que estamos desarrollando una función simple que suma dos números en Python. Primero, escribimos la función en el archivo \textit{calculadora.py}:

%multiple lines
\begin{minted}{python}
# calculadora.py

def suma(a, b):
    return a + b
\end{minted}

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

# test_calculadora.py

import calculadora

def test_suma():
    resultado = calculadora.suma(2, 3)
    assert resultado == 5, "La suma de 2 y 3 debería ser 5"


\end{minted}
\caption{Ejemplo de prueba de unidad con módulo pytest en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo:

    \begin{itemize}
        \item Importamos el módulo calculadora que contiene la función suma.
        \item Definimos una función llamada \textit{test\_suma} que verifica si la función suma devuelve el resultado esperado cuando se le dan los argumentos 2 y 3.
        \item Usamos la afirmación (\textit{assert}) para verificar si el resultado es igual a 5 y proporcionamos un mensaje de error personalizado si la afirmación falla.
    \end{itemize}

Para ejecutar estas pruebas con pytest, simplemente abre una terminal en la ubicación de tus archivos y ejecuta el siguiente comando:

\mint[linenos=false]{console}| pytest test_calculadora.py |


Otro ejemplo:


Supongamos que tenemos una función simple que calcula el área de un rectángulo en un archivo llamado geometria.py:

%multiple lines
\begin{minted}{python}
# geometria.py

def area_rectangulo(base, altura):
    if base <= 0 or altura <= 0:
        raise ValueError("La base y la altura deben ser números positivos.")
    return base * altura

\end{minted}

Ahora, creemos pruebas unitarias para esta función utilizando pytest en un archivo llamado test_geometria.py:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
# test_geometria.py

import pytest
import geometria

def test_area_rectangulo():
    resultado = geometria.area_rectangulo(3, 4)
    assert resultado == 12, "El área del rectángulo con base 3 y altura 4 debe ser 12"

def test_area_rectangulo_excepcion():
    with pytest.raises(ValueError):
        geometria.area_rectangulo(-1, 5)

\end{minted}
\caption{Ejemplo de prueba de unidad con módulo pytest en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En el código de prueba:

    \begin{itemize}
        \item Importamos pytest y el módulo geometria, que contiene la función que estamos probando.
        \item Creamos dos funciones de prueba, \textit{test\_area\_rectangulo} y \textit{test\_area\_rectangulo\_excepcion}, que verifican si la función area\_rectangulo se comporta como se espera en diferentes situaciones.
        \item Utilizamos \textit{assert} para verificar si los resultados son los esperados.
        \item En \textit{test\_area\_rectangulo\_excepcion}, usamos \textit{pytest.raises} para verificar que la función eleve una excepción cuando se le proporciona una entrada inválida.
    \end{itemize}

Con esto, pytest descubrirá automáticamente las pruebas en el archivo y proporcionará información detallada sobre su ejecución.

pytest es una herramienta esencial en el desarrollo de software en Python que simplifica la escritura y ejecución de pruebas unitarias. Su sintaxis clara y sus características avanzadas lo convierten en una elección poderosa para garantizar la calidad del código.
    
\subsection{unittest}

Unittest es un módulo incorporado en Python que ofrece un marco de trabajo para la creación y ejecución de pruebas unitarias. Este módulo se inspira en el marco de pruebas JUnit de Java y sigue el enfoque de la orientación a objetos para organizar las pruebas. Permite a los desarrolladores crear pruebas efectivas al proporcionar una estructura coherente y herramientas para verificar el comportamiento de las funciones y métodos.

Características Clave de "unittest":

    \begin{enumerate}
        \item Organización de Pruebas: "Unittest" fomenta la organización de pruebas en clases, lo que facilita la gestión de conjuntos de pruebas relacionadas.
        \item Métodos de Aserción: Ofrece una variedad de métodos de aserción, como assertEqual, assertTrue, assertFalse, entre otros, para verificar resultados esperados.
        \item Descubrimiento Manual de Pruebas: A diferencia de algunos otros marcos de pruebas, "unittest" no ofrece descubrimiento automático de pruebas. Los desarrolladores deben especificar manualmente las pruebas a ejecutar.
        \item Fixture: Permite la configuración y limpieza compartida para las pruebas a través de métodos especiales de configuración (setUp) y limpieza (tearDown).
    \end{enumerate}


\subsubsection{Ejemplos de Prueba Unitaria con unittest en Python}

Supongamos que estamos desarrollando una función simple que suma dos números en Python. Primero, escribimos la función en el archivo \textit{calculadora.py}:

%multiple lines
\begin{minted}{python}
# calculadora.py

def suma(a, b):
    return a + b
\end{minted}


A continuación, creamos un archivo de prueba unitaria llamado \textit{test\_calculadora.py} para verificar si la función suma funciona correctamente:


\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
# test_calculadora.py

import unittest
from calculadora import suma

class TestCalculadora(unittest.TestCase):

    def test_suma(self):
        resultado = suma(2, 3)
        self.assertEqual(resultado, 5, "La suma de 2 y 3 debería ser 5")

if __name__ == '__main__':
    unittest.main()

\end{minted}
\caption{Ejemplo de pureba de unidad con módulo unittest en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


En este ejemplo:

    \begin{itemize}
        \item Importamos el módulo \textit{unittest} para crear nuestras pruebas unitarias.
        \item Importamos la función suma desde el módulo calculadora.
        \item Creamos una clase llamada \textit{TestCalculadora} que hereda de \textit{unittest.TestCase}. Esto nos permite definir métodos de prueba.
        \item Dentro de la clase TestCalculadora, definimos un método llamado \textit{test\_suma}. Este método verifica si la función suma devuelve el resultado esperado cuando se le dan los argumentos 2 y 3.
        \item Usamos el método \textit{self.assertEqual} para comparar el resultado con el valor esperado.
    \end{itemize}

Para ejecutar estas pruebas unitarias, simplemente ejecutamos el archivo \textit{test\_calculadora.py}. Si la función suma se comporta como se espera, no se mostrarán errores.



Para el ejemplo de geometria.py visto anteriormente el código de prueba en \textit{unittest} queda como sigue:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
# test_geometria.py

import unittest
import geometria

class TestGeometria(unittest.TestCase):

    def test_area_rectangulo(self):
        resultado = geometria.area_rectangulo(3, 4)
        self.assertEqual(resultado, 12, 
          "El área del rectángulo con base 3 y altura 4 debe ser 12")

    def test_area_rectangulo_excepcion(self):
        with self.assertRaises(ValueError):
            geometria.area_rectangulo(-1, 5)

if __name__ == '__main__':
    unittest.main()

\end{minted}
\caption{Ejemplo de prueba de unidad con módulo unittest en Python.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este código de prueba:

    \begin{itemize}
        \item Importamos el módulo unittest y el módulo geometria que contiene la función que estamos probando.
        \item Creamos una clase llamada TestGeometria que hereda de unittest.TestCase, lo que nos permite definir métodos de prueba.
        \item Dentro de la clase TestGeometria, definimos dos métodos de prueba, test_area_rectangulo y test_area_rectangulo_excepcion, que verifican si la función area_rectangulo se comporta como se espera en diferentes situaciones.
        \item Usamos los métodos de aserción self.assertEqual y self.assertRaises para verificar si los resultados son los esperados y si se eleva una excepción cuando se le proporciona una entrada inválida.
    \end{itemize}

Para ejecutar estas pruebas con \textit{unittest}, simplemente ejecutamos el archivo test_geometria.py.

\textit{unittest} es un módulo importante para realizar pruebas unitarias en Python. Su enfoque orientado a objetos y sus métodos de aserción facilitan la creación de pruebas estructuradas y confiables para garantizar que las unidades individuales de código funcionen correctamente.


\section{Manejo de archivos: de texto, JSON y CSV}

\subsection{Manejo de archivos de texto}

el manejo de archivos de texto se refiere a la capacidad de leer y escribir información en archivos de texto plano. Los archivos de texto son una forma común de almacenar datos estructurados de manera legible por humanos, lo que los hace ideales para tareas como guardar configuraciones, registros de actividad o información tabular. A continuación, se proporcionan ejemplos de cómo manejar archivos de texto en Python, centrándonos en las operaciones básicas de lectura y escritura.

\subsubsection{Lectura de Archivos de Texto}

Para leer información de un archivo de texto en Python, primero debemos abrir el archivo en modo lectura ('r'). Luego, podemos usar ciclos o métodos de lectura para procesar su contenido. Aquí hay un ejemplo:


\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

# Abrir un archivo en modo lectura
with open('archivo.txt', 'r') as archivo:
    # Leer todo el contenido del archivo
    contenido = archivo.read()
    
# Imprimir el contenido leído
print(contenido)

\end{minted}
\caption{Ejemplo de lectura de archivo de texto.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


En este ejemplo, utilizamos la declaración \textit{with} para garantizar que el archivo se cierre correctamente después de su uso. El método\textit{ read() }se emplea para leer todo el contenido del archivo y almacenarlo en la variable contenido.

\subsubsection{Escritura en Archivos de Texto}

Para escribir en un archivo de texto, debemos abrirlo en modo escritura ('w'). Si el archivo no existe, se creará; si existe, su contenido se sobrescribirá. A continuación, se muestra un ejemplo de escritura en un archivo de texto:


\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

# Abrir un archivo en modo escritura
with open('nuevo_archivo.txt', 'w') as archivo:
    # Escribir datos en el archivo
    archivo.write("Este es un ejemplo de escritura en un archivo de texto.\n")
    archivo.write("Python es un lenguaje de programación poderoso.\n")

\end{minted}
\caption{Ejemplo de escritura de archivo de texto.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


En este caso, utilizamos \textit{with} nuevamente para asegurarnos de que el archivo se cierre correctamente después de escribir en él. Los datos se escriben en el archivo utilizando el método \textit{write()}. Nota que agregamos el carácter de nueva línea ('\n') para separar las líneas.

\subsubsection{Lectura Línea por Línea}

Si deseamos leer un archivo línea por línea, podemos usar un ciclo \textit{for}. Esto es especialmente útil para archivos grandes, ya que no cargamos todo el contenido en la memoria al mismo tiempo:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

# Abrir un archivo en modo lectura
with open('archivo_grande.txt', 'r') as archivo:
    for linea in archivo:
        # Procesar cada línea
        print(linea.strip())  # strip() 
          elimina espacios en blanco y saltos de línea al final
        
\end{minted}
\caption{Ejemplo de lectura línea por línea de archivo de texto.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



En este ejemplo, el ciclo \textit{for} itera sobre cada línea del archivo, y utilizamos \textit{strip()} para eliminar espacios en blanco y saltos de línea al final de cada línea.


El manejo de archivos de texto en Python es fundamental para leer y escribir datos de manera eficiente y efectiva. Con las operaciones básicas de lectura y escritura, los programadores pueden manipular archivos de texto de diversas maneras, lo que resulta esencial en muchas aplicaciones y tareas de procesamiento de datos.

\subsection{Manejo de archivos JSON }

Los archivos JSON (JavaScript Object Notation) son una forma eficiente y ampliamente utilizada para el intercambio de datos estructurados entre aplicaciones. A continuación, se proporcionarán ejemplos detallados de cómo manejar archivos JSON en Python, ilustrando su relevancia en el ámbito de la programación.

\subsubsection{Lectura de Archivos JSON}

La lectura de archivos JSON en Python es un proceso esencial cuando se necesita acceder a datos estructurados almacenados en este formato. Para llevar a cabo esta tarea, se utiliza la biblioteca estándar json. A continuación, se presenta un ejemplo de lectura de un archivo JSON:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

import json

# Abrir y leer un archivo JSON en modo lectura
with open('datos.json', 'r') as archivo_json:
    # Cargar los datos desde el archivo
    datos = json.load(archivo_json)

# Acceder a los datos y realizar operaciones
print("Nombre:", datos["nombre"])
print("Edad:", datos["edad"])

\end{minted}
\caption{Ejemplo de lectura de archivo JSON.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


En este ejemplo, se utiliza json.load() para cargar los datos desde el archivo JSON en la variable datos. Luego, se pueden acceder y procesar los datos como diccionarios de Python.

\subsubsection{Escritura en Archivos JSON}

La escritura en archivos JSON es igualmente fundamental, ya que permite almacenar datos estructurados en un formato que es fácilmente comprensible por otros programas. Para llevar a cabo esta tarea, también empleamos la biblioteca json. Aquí se presenta un ejemplo de escritura en un archivo JSON:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

import json

# Datos que se desean escribir en el archivo JSON
nuevos_datos = {
    "nombre": "Ana",
    "edad": 28,
    "ciudad": "Ejemploville"
}

# Abrir y escribir en un archivo JSON en modo escritura
with open('nuevos_datos.json', 'w') as archivo_json:
    # Escribir los datos en el archivo
    json.dump(nuevos_datos, archivo_json)

print("Datos escritos en el archivo JSON.")

\end{minted}
\caption{Ejemplo de escritura de archivo JSON.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


En este caso, se utiliza \textit{json.dump()} para escribir los datos en el archivo JSON. Estos datos pueden ser un diccionario de Python, como se muestra en el ejemplo.

\subsubsection{Ventajas del Uso de Archivos JSON}

El manejo de archivos JSON en Python es crucial para la interoperabilidad de datos entre sistemas y aplicaciones. JSON es un formato ligero y fácil de leer, lo que lo hace ideal para la transferencia y el almacenamiento de datos estructurados. Además, Python proporciona herramientas integradas para trabajar con archivos JSON de manera eficiente, lo que simplifica las tareas de lectura y escritura de datos. 


\subsection{Manejo de archivos CSV}

Los archivos CSV son una forma común de almacenar datos tabulares en un formato que es fácilmente legible y editable tanto por humanos como por máquinas. A continuación, se presentarán ejemplos completos de cómo manejar archivos CSV en Python, destacando su relevancia en el ámbito de la programación y el procesamiento de datos.

\subsubsection{Lectura de Archivos CSV}

La lectura de archivos CSV en Python es esencial para analizar y procesar datos tabulares provenientes de diversas fuentes, como hojas de cálculo o bases de datos. Para llevar a cabo esta tarea, se utiliza la biblioteca estándar csv. A continuación, se presenta un ejemplo de lectura de un archivo CSV:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

import csv

# Abrir y leer un archivo CSV en modo lectura
with open('datos.csv', 'r', newline='') as archivo_csv:
    lector_csv = csv.reader(archivo_csv)
    
    # Iterar a través de las filas del archivo CSV
    for fila in lector_csv:
        # Procesar cada fila (que es una lista de valores)
        print("Nombre:", fila[0])
        print("Edad:", fila[1])

\end{minted}
\caption{Ejemplo de lectura de archivo CSV.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo, se utiliza \textit{csv.reader() }para crear un objeto que nos permite iterar a través de las filas del archivo CSV. Cada fila se convierte en una lista de valores que podemos procesar según sea necesario.

\subsubsection{Escritura en Archivos CSV}

La escritura en archivos CSV es igualmente importante, ya que nos permite almacenar datos tabulares en un formato que puede ser compartido y utilizado por otros programas. También utilizamos la biblioteca csv para esta tarea. Aquí se presenta un ejemplo de escritura en un archivo CSV:

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

import csv

# Datos que se desean escribir en el archivo CSV
nuevos_datos = [
    ["Ana", 28],
    ["Carlos", 35],
    ["Elena", 22]
]

# Abrir y escribir en un archivo CSV en modo escritura
with open('nuevos_datos.csv', 'w', newline='') as archivo_csv:
    escritor_csv = csv.writer(archivo_csv)
    
    # Escribir los datos en el archivo CSV
    for fila in nuevos_datos:
        escritor_csv.writerow(fila)

print("Datos escritos en el archivo CSV.")

\end{minted}
\caption{Ejemplo de escritura de archivo CSV.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este caso, utilizamos \textit{csv.writer()} para crear un objeto que nos permite escribir datos en el archivo CSV. Usamos el método \textit{writerow() }para escribir cada fila de datos.

\subsubsection{Ventajas del Uso de Archivos CSV en Python}

El manejo de archivos CSV en Python es crucial para la manipulación y análisis de datos tabulares, lo que es esencial en una amplia variedad de aplicaciones, desde procesamiento de datos hasta análisis estadístico. Los archivos CSV son ampliamente compatibles y su estructura simple los hace ideales para el intercambio de datos entre diferentes sistemas. Python proporciona herramientas eficientes y flexibles para trabajar con archivos CSV, lo que simplifica las tareas de lectura y escritura de datos tabulares. 

\section{Casos de estudio orientados al aprendizaje computacional}

\subsection{¿Qué es el aprendizaje computacional?}
El aprendizaje computacional es una rama de la inteligencia artificial que se ocupa de la construcción de sistemas capaces de aprender a partir de datos. Estos sistemas, también conocidos como modelos de aprendizaje automático, pueden ser utilizados para realizar una amplia gama de tareas, como la clasificación de imágenes, la predicción de resultados y la detección de patrones.
El aprendizaje computacional se basa en la idea de que los sistemas pueden aprender a realizar tareas sin ser explícitamente programados para ello. En lugar de ello, los sistemas aprenden a partir de datos de entrenamiento, que son ejemplos de cómo se debe realizar la tarea. Por ejemplo, un sistema de aprendizaje automático para clasificar imágenes podría ser entrenado con un conjunto de datos de imágenes etiquetadas, cada una de las cuales tiene un nombre de objeto. El sistema aprendería a identificar los patrones que distinguen a cada objeto, y luego podría utilizar esos patrones para clasificar nuevas imágenes.
El aprendizaje computacional tiene una amplia gama de aplicaciones, que incluyen:
\begin{itemize}
    \item \textbf{Reconocimiento de imágenes y voz}: Los sistemas de aprendizaje automático se utilizan para reconocer rostros, objetos y palabras.
    \item \textbf{Predicción}: Los sistemas de aprendizaje automático se pueden utilizar para predecir el comportamiento futuro, como el riesgo de que un cliente abandone una empresa o la probabilidad de que un paciente desarrolle una enfermedad.
    \item \textbf{Robótica}: Los sistemas de aprendizaje automático se utilizan para que los robots puedan aprender a realizar tareas en entornos complejos.
    \item \textbf{Médico}: Los sistemas de aprendizaje automático se utilizan para diagnosticar enfermedades, personalizar tratamientos y desarrollar nuevos fármacos.
\end{itemize}
El aprendizaje computacional es una disciplina en rápido desarrollo, y se espera que tenga un impacto cada vez mayor en nuestras vidas.
Tipos de aprendizaje computacional
Existen tres tipos principales de aprendizaje computacional:
\begin{itemize}
    \item \textbf{Aprendizaje supervisado}: En el aprendizaje supervisado, el sistema de aprendizaje automático se proporciona con datos de entrenamiento que están etiquetados con la respuesta correcta. El sistema aprende a identificar los patrones que distinguen a cada respuesta correcta, y luego puede utilizar esos patrones para predecir la respuesta correcta para nuevos datos.
    \item \textbf{Aprendizaje no supervisado}: En el aprendizaje no supervisado, el sistema de aprendizaje automático no se proporciona con datos de entrenamiento etiquetados. El sistema aprende a identificar los patrones en los datos, y luego puede utilizar esos patrones para agrupar los datos en grupos o para identificar clusters.
    \item \textbf{Aprendizaje por refuerzo}: En este enfoque, un agente de aprendizaje interactúa con un entorno y toma decisiones para maximizar una recompensa acumulada a lo largo del tiempo. A medida que el agente interactúa con el entorno, aprende a tomar decisiones óptimas para lograr sus objetivos.
\end{itemize}

\subsection{Bibliotecas de Python usadas en aprendizaje computacional}

Python es un lenguaje de programación de propósito general que es cada vez más popular en el campo del aprendizaje computacional. Esto se debe a que Python es un lenguaje fácil de aprender y usar, y tiene una amplia gama de bibliotecas y herramientas disponibles para el aprendizaje automático.

Las principales bibliotecas de Python usadas en aprendizaje computacional son:

    \begin{itemize}
        \item \textbf{Scikit-learn}: Es una biblioteca de aprendizaje automático de código abierto que proporciona una amplia gama de algoritmos para el aprendizaje supervisado, no supervisado y refuerzo.
        \item \textbf{TensorFlow}: Es una biblioteca de aprendizaje profundo de código abierto que es popular para el desarrollo de redes neuronales.
        \item \textbf{PyTorch}: Es una biblioteca de aprendizaje profundo de código abierto que es similar a TensorFlow, pero se centra en la velocidad y la eficiencia.
        \item \textbf{Keras}: Es un marco de aprendizaje profundo de alto nivel que se basa en TensorFlow o PyTorch.
        \item \textbf{SciPy}: Es una biblioteca de matemáticas y ciencias computacionales que proporciona funciones para el análisis de datos, la visualización y el cálculo numérico.
        \item \textbf{NumPy}: Es una biblioteca de cálculo numérico que proporciona matrices y funciones para el análisis de datos.
        \item \textbf{Pandas}: Es una biblioteca de análisis de datos que proporciona estructuras de datos y herramientas para la manipulación de datos tabulares.
        \item \textbf{Matplotlib}: Es una biblioteca de visualización de datos que proporciona funciones para crear gráficos y diagramas.
    \end{itemize}

Estas bibliotecas proporcionan una amplia gama de funciones y capacidades para el aprendizaje computacional, incluyendo:

    \begin{itemize}
        \item \textbf{Algoritmos de aprendizaje automático}: La mayoría de estas bibliotecas proporcionan una amplia gama de algoritmos de aprendizaje automático, tanto para el aprendizaje supervisado como no supervisado.
        \item \textbf{Herramientas de preprocesamiento de datos}: Estas bibliotecas proporcionan herramientas para limpiar, transformar y preparar los datos para el aprendizaje automático.
        \item \textbf{Herramientas de evaluación de modelos}: Estas bibliotecas proporcionan herramientas para evaluar el rendimiento de los modelos de aprendizaje automático.
        \item \textbf{Herramientas de visualización de datos}: Estas bibliotecas proporcionan herramientas para visualizar los resultados del aprendizaje automático.
    \end{itemize}
Elegir la biblioteca adecuada para una tarea de aprendizaje computacional depende de una serie de factores, incluyendo:

    \begin{itemize}
        \item \textbf{El tipo de algoritmo de aprendizaje automático que se necesita}: Algunas bibliotecas se especializan en ciertos tipos de algoritmos de aprendizaje automático, mientras que otras proporcionan una gama más amplia de opciones.
        \item \textbf{Las características y capacidades de la biblioteca}: Algunas bibliotecas proporcionan más funciones y capacidades que otras.
        \item E\textbf{l nivel de experiencia del usuario}: Algunas bibliotecas son más fáciles de usar que otras.
    \end{itemize}

En general, las bibliotecas de Python son una herramienta poderosa para el aprendizaje computacional. Proporcionan una amplia gama de funciones y capacidades que pueden ayudar a los usuarios a desarrollar modelos de aprendizaje automático eficaces.

\subsection{Casos de estudio orientados al aprendizaje computacional}

El aprendizaje computacional tiene una amplia gama de aplicaciones, y se utiliza en una gran variedad de industrias. Aquí hay algunos ejemplos de casos de estudio orientados al aprendizaje computacional:

\begin{itemize}
    \item \textbf{Reconocimiento de imágenes y voz}. El reconocimiento de imágenes y voz es una de las aplicaciones más comunes del aprendizaje computacional. Se utiliza en una amplia gama de productos y servicios, como los asistentes virtuales, las cámaras de seguridad y los sistemas de reconocimiento facial.
    \item \textbf{Predicción}. El aprendizaje computacional se utiliza para predecir el comportamiento futuro. Se puede utilizar para predecir el riesgo de que un cliente abandone una empresa, la probabilidad de que un paciente desarrolle una enfermedad o el rendimiento de una inversión.
    \item \textbf{Robótica}. El aprendizaje computacional se utiliza para que los robots puedan aprender a realizar tareas en entornos complejos. Se puede utilizar para enseñar a los robots a navegar por un entorno, a interactuar con los humanos y a realizar tareas complejas.
    \item \textbf{Médico}. El aprendizaje computacional se utiliza en el campo de la medicina para diagnosticar enfermedades, personalizar tratamientos y desarrollar nuevos fármacos. Se puede utilizar para analizar imágenes médicas, para identificar patrones de enfermedad y para predecir la respuesta a los tratamientos.
\end{itemize}

\subsubsection{Otros casos de estudio}

El aprendizaje computacional se utiliza en una amplia gama de otros campos, como el marketing, la educación y el transporte. Por ejemplo, se puede utilizar para personalizar la publicidad, para mejorar el aprendizaje de los estudiantes y para optimizar el tráfico.

Ejemplos específicos

Aquí hay algunos ejemplos específicos de casos de estudio orientados al aprendizaje computacional:

    \begin{itemize}
        \item Google utiliza el aprendizaje computacional para clasificar imágenes en su motor de búsqueda.
        \item Amazon utiliza el aprendizaje computacional para recomendar productos a sus clientes.
        \item Netflix utiliza el aprendizaje computacional para recomendar películas y programas de televisión a sus usuarios.
        \item Tesla utiliza el aprendizaje computacional para que sus coches autónomos puedan navegar por la carretera.
        \item IBM Watson utiliza el aprendizaje computacional para diagnosticar enfermedades.
        \item Duolingo utiliza el aprendizaje computacional para personalizar el aprendizaje de idiomas.
        \item Uber utiliza el aprendizaje computacional para optimizar el tráfico.
    \end{itemize}

Estos son solo algunos ejemplos de los muchos casos de estudio en los que el aprendizaje computacional se está utilizando para resolver problemas y mejorar nuestras vidas.


\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%


%  TEMAS PENDIENTES
%

%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
\newpage

%
%
\chapter{Diseño por contratos}
\section{Diseño por contratos en D}
%
%

\chapter{Pruebas de unidad}
% D y Ruby incluyen biblioteca de pruebas de unidad
% Java puede usar JUnit u otro

\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%




%%%%%%%%%%
% Java
%%%%%%%%%%
\ifjava
\chapter{Multihilos: Introducción a la Programación Concurrente en Java}

\section{Introducción}

Un programa concurrente es aquel que puede ejecutar varias tareas al mismo tiempo. Aunque en la vida diaria las cosas suceden concurrentemente o en paralelo, es interesante notar que los principales lenguajes de programación no permiten especificar actividades concurrentes de manera natural. Antes de Java, el lenguaje Ada implemento, como parte de su lenguaje, primitivas de concurrencia. Sin embargo, \textbf{Ada} no se hizo un lenguaje popular  a pesar de haber sido el lenguaje oficial para el desarrollo de aplicaciones para el Departamento de Defensa de los Estados Unidos.

En general, si se quieren crear tareas concurrentes en un lenguaje como C++, se realiza a través de llamadas a primitivas de control del sistema operativo. Lógicamente, estas primitivas dependen del dominio que tenga el programador sobre la plataforma (no tanto del lenguaje) y varían de un sistema operativo a otro.

El lenguaje Java permite un manejo relativamente fácil de procesos concurrentes, respetando la independencia de la plataforma. Esto quiere decir que un programa con manejo de concurrencia en Java corre sin ninguna modificación en las máquinas cuyos sistemas operativos cuenten con una máquina virtual de java\footnote{En realidad puede existir alguna diferencia en el comportamiento de los programas, pero se ahondará en el tema más adelante.}. 

\section{Concurrencia}

Pero retrocedamos un poco y vamos a ponernos de acuerdo en el concepto de concurrencia. Veamos la diferencia entre concurrencia y paralelismo.

Creo que estaremos de acuerdo en que las \textbf{operaciones secuenciales} son aquellas que ocurren una después de otra; es decir, están ordenadas en el tiempo. De aquí se desprende que las \textbf{operaciones paralelas} son aquellas que ocurren al mismo tiempo. Es común hablar de paralelismo cuando hablamos de operaciones de hardware.  

Sin embargo al hablar de concurrencia nos referimos por lo general al código fuente, donde un conjunto de operaciones son concurrentes si pueden ejecutarse en paralelo, lo que no quiere decir que obligatoriamente se ejecuten así. Es por eso que podemos tener procesos concurrentes sin tener hardware paralelo. Por ejemplo, las computadoras con \textit{Windows} que realizan varios procesos al mismo tiempo como mandar a imprimir, bajar un archivo de Internet, enviar un \textit{eMail}, etc. Las PC's son por lo general de un solo procesador y no cuentan con procesamiento paralelo; sin embargo, estamos realizando procesos concurrentes. Lo mismo sucede con todas las máquinas que tienen un solo procesador y cuentan con sistema operativo  multitareas como  \textit{Unix} o \textit{Linux}\footnote{Independientemente de que algunos sistemas operativos pueden ser usados en máquinas con múltiples procesadores.}.  Podemos decir que la concurrencia es cuando un conjunto de instrucciones no depende de otro conjunto y no importa el orden de ejecución entre ellas: son \textbf{potencialmente paralelas}.	

\section{Multihilos}

Existen diversas técnicas de manejo de procesos concurrentes. Java maneja la concurrencia a través de los hilos (\textit{threads}) de control. Los hilos tienen la característica de ejecutarse cada uno de ellos como un proceso independiente pero compartiendo un único espacio de direcciones.  Estos procesos se conocen como \textbf{procesos ligeros} o hilos\footnote{También llamados \textbf{contextos de ejecución}}, a diferencia de los demás procesos que no comparten el espacio de direcciones y donde la comunicación tiene que darse a través de primitivas de comunicación (semáforos, monitores o mensajes).

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{imagenes/multihilos01.png}
    \caption{ Múltiples procesos vs. múltiples hilos en un proceso }
    \label{fig:multihilos01}
\end{figure}	

Los procesos ligeros o hilos son como miniprocesos, pues cada hilo se ejecuta de forma secuencial, con su propio contador de programa y pila de control. Además, al igual que los procesos, en una máquina de un solo procesador se van turnando su ejecución, lo que se conoce como \textbf{tiempo compartido}.

Anteriormente se mencionó que los hilos comparten un único espacio de direcciones. Esto quiere decir que tienen acceso a las mismas variables globales\footnote{ El concepto de variables globales no existe en Java, pero es un término común que nos da la idea del alcance. No olvidar además que el manejo de hilos nuevo o exclusivo del lenguaje Java.} o ámbito  de trabajo. En términos de objetos, los objetos de un hilo pueden ver a los de otro hilo si el alcance y las restricciones de acceso se lo permiten. 

\section{Multihilos en Java}

Aunque de manera estricta todos los programas de Java manejan más de un hilo, de vista al usuario los programas por lo general son de un único hilo de control (\textbf{flujo único}). Sin embargo pueden contar con varios hilos de control (\textbf{flujo múltiple}).

Existen dos formas de implementar hilos en un programa de Java. La forma más común es mediante herencia, extendiendo la clase \textit{Thread}.

\subsection{Programas de flujo único}

Un programa de flujo único utiliza un único hilo de control  para controlar su ejecución. Muchos programas no necesitan la potencia o utilidad de múltiples flujos de control. Sin necesidad de especificar explícitamente que se quiere un único flujo de control, muchas de las aplicaciones son de flujo único.

Por ejemplo, en la aplicación clásica de ''Hola mundo!'':

\begin{minted}{java}
public class HolaMundo {
    static public void main( String args[] ) {
        System.out.println( "Hola Mundo!" );
    }
}
\end{minted}

Aquí, cuando se llama a \textit{ main()}, la aplicación imprime el mensaje y termina. Esto ocurre dentro de un único hilo.

\subsection{Programas de flujo múltiple}

Los programas en Java implementan un flujo único de manera implícita. Sin embargo, Java posibilita la creación y control de hilos explícitamente. La utilización de hilos en Java, permite una enorme flexibilidad a los programadores a la hora de plantearse el desarrollo de aplicaciones. La simplicidad para crear, configurar y ejecutar hilos, permite que se puedan implementar muy poderosas y portables aplicaciones. 

Las aplicaciones multihilos utilizan muchos contextos de ejecución para cumplir su trabajo. Hacen uso del hecho de que muchas tareas contienen subtareas distintas e independientes. Se puede utilizar un hilo para cada subtarea.

Mientras que los programas de flujo único pueden realizar su tarea ejecutando las subtareas secuencialmente, un programa multihilos permite que cada hilo comience y termine tan pronto como sea posible. Este comportamiento presenta una mejor respuesta a las necesidades de muchas aplicaciones.

	Veamos un ejemplo de un pequeño programa multihilos en Java.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class MiHilo extends Thread {

  public MiHilo (String nombre) {
    super (nombre);
  }
 
  public void run() {
    for( int i=0; i<4; i++){
        System.out.println( getName() + " " + i );
        try {
            sleep(400);
        } catch( InterruptedException e) { }
    }
  }
}

public class MultiHilo {
    public static void main(String arrg[]) {
        MiHilo mascar = new MiHilo("Mascando");
        MiHilo silbar = new MiHilo("Silbar");
        mascar.start();
        silbar.start();
    }
}
\end{minted}
\caption{Ejemplo básico de multihilos en Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Este pequeño ejemplo ejecuta dos hilos. Uno llamado \textit{mascar} y otro \textit{silbar}. Por lo que el programa es capaz de ''mascar'' y ''silbar'' al mismo tiempo, aunque como ya sabemos, en una computadora de un solo procesador tendrá que dejar de mascar para poder silbar, y viceversa.

\section{Estados de un hilo}

Cada hilo de ejecución en Java, es un objeto que puede estar en diferentes estados.

En la figura \ref{fig:multi_estados}  podemos apreciar que cuando un hilo es creado, no quiere decir que se encuentre corriendo, sino que esto sucede cuando es invocado el método \textit{start()} del objeto. Es hasta entonces que se encuentra en un estado de  "Listo para ejecutarse".

\begin{figure}
    \centering
    \includegraphics[scale=0.4]{imagenes/multihilos02_estados.png}
    \caption{Estados de un hilo en Java}
    \label{fig:multi_estados}
\end{figure}


Cuando un hilo está ejecutándose pueden pasar varias cosas con ese hilo en particular. El método \textit{start()} llama en forma automática al método \textit{run()}. Este método contiene el código principal del hilo, algo así como un método \textit{main} para un programa principal. 

Un hilo que está en ejecución puede pasar a un estado de muerto si termina de ejecutar al método \textit{run( )}.

El estado de ''no-ejecutable''. Se llega a este estado cuando el hilo no esta ''en ejecución'', debido a una llamada del método \textit{sleep()}, \textit{wait()} o porque se está realizando un proceso de entrada/salida que tarda cierto tiempo en ejecutarse.

Existen los métodos \textit{stop()}, \textit{suspend()} y \textit{resume()}, pero estos han sido desaprobados en la versión 2 de Java debido a que se consideran potencialmente peligrosos para la ejecución de los programas concurrentes\footnote{ El que sean desaprobados no quiere decir que ya no puedan ser usados. Se conservan por compatibilidad hacia atrás con el lenguaje, pero se ha visto que no es recomendable su uso. En algunos ejemplos pueden aparecer estas instrucciones por simplicidad.}.

Veamos ahora un diagrama (figura \ref{fig:multi_estado03}) que muestra de manera más completa los estados en los que puede estar un hilo.

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{imagenes/multihilos03_estados.png}
    \caption{ Estados de un hilo en Java (2) }
    \label{fig:multi_estado03}
\end{figure}

\section{La clase \textit{Thread}}

El programa de ejemplo que se vio antes, corresponde a la forma de implementación más común de un hilo: mediante la extensión de la clase Thread.  Por lo que se pudo apreciar, la sintaxis para la creación de un hilo seria:

\begin{minted}{java}
class MiHilo extends Thread {
    public void run() {
        . . .
        }
}
\end{minted}

Esta técnica, extiende a la clase \textit{Thread}, y redefine el método \textit{run()}, el cual debe contener un implementación propia, de acuerdo a lo que se quiera que realice el hilo.

Vamos a mencionar ahora los principales métodos de la clase\footnote{Para las características completas ver la documentación: \textit{Java Platform API Specification}}.


\begin{itemize}
\item \textit{Thread(String nombreThread)}. Constructor de la clase Thread, recibe una cadena para el nombre del hilo.
\item \textit{Thread( )}. Constructor sin parámetros. Crea de manera automática nombres para los hilos. Llamados Thread1, Thread2, etc.
\item \textit{start()}. Inicia la ejecución de un hilo. Invoca al método run().
\item \textit{run()}. Este método se redefine para controlar la ejecución del hilo.
\item sleep( tiempo ). Causa que el hilo se "duerma" un tiempo determinado. Un hilo dormido no compite por el procesador.
\item \textit{interrupt( )}. Interrumpe la ejecución de un hilo.
\item \textit{interrupted()}. Método estático que devuelve verdadero si el hilo actual ha sido interrumpido.
\item \textit{isInterrupted()}. Método no estático que verifica si un hilo ha sido interrumpido.
\item \textit{join( )}. Espera a que un hilo específico muera antes de continuar. Está sobrecargado para recibir un tiempo límite de espera  como parámetro.
\item \textit{yield( )}. El hilo cede la ejecución a otros hilos.
\end{itemize}

Métodos usados también con los hilos son $notify ()$ y $wait( )$, aunque estos en realidad están definidos y heredados desde la clase $Object$.

\section{Prioridades de los hilos}

A cada uno de los hilos de Java se les puede asignar una \textbf{prioridad}. ¿Por qué es  esto necesario? Recordemos que en las máquinas con un solo procesador solo se tiene la impresión de que todos los hilos se están ejecutando al mismo tiempo, cuando en realidad se están repartiendo el tiempo del procesador.

Ahora, suponga que tiene un programa con varios hilos de ejecución, y uno de los hilos lleva a cabo una tarea más importante o que requiera mayores recursos. Una opción lógica sería asignarle una prioridad mayor que al resto de los hilos para que tenga preferencia al competir por tiempo del procesador.

La prioridad de un hilo en Java puede ir de 1 a 10. Si se le asigna 10 como prioridad a un hilo, se le estaría asignando la prioridad más alta. Un hilo al que no se le especifica su prioridad, toma una prioridad normal con un valor de 5. Si un hilo es creado por otro, el nuevo hilo hereda la prioridad del hilo padre.
	
Java tiene predefinidas 3 constantes de prioridad:


\begin{itemize}
\item \textit{MIN\_PRIORITY}. Para asignar la mínima prioridad que puede tener un hilo (1).
\item \textit{NORM\_PRIORITY}. Prioridad intermedia (5), asignada por omisión.
\item \textit{MAX\_PRIORITY}. Asigna la máxima prioridad que puede tener un hilo (10).

\end{itemize}


El siguiente ejemplo muestra el uso de prioridades en los hilos e introduce además el manejo del  método \textit{setPriority}; el cual, junto con \textit{getPriority}, sirven para modificar y consultar la prioridad de un hilo respectivamente.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class miHilo extends Thread {

   public miHilo (String nombre)
     {
       super (nombre);
     }

   public void run()
     {
       for (int i = 0; i < 20; i++)
         {
           System.out.println(getName() + " " + i);
           try {
               sleep(10);
           } 
           catch (InterruptedException e) {}
         }
     }
 }

public class prioridadHilo  {

    
   public static void main(String args[])
     { 
       miHilo hilo_min = new miHilo ("Hilo Min");
       miHilo hilo_max = new miHilo ("Hilo Max");

       hilo_min.setPriority(Thread.MIN_PRIORITY);
       hilo_max.setPriority(Thread.MAX_PRIORITY);
       hilo_min.start();
       hilo_max.start();
     }    
 }
\end{minted}
\caption{Ejemplo de prioridades en multhilos con Java.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Mostramos a continuación un ejemplo parecido que genera cuatro hilos y son puestos a dormir un tiempo aleatorio, de entre 0 y 5 segundos. En este caso todos los hilos tienen la misma prioridad, y su ejecución depende del momento en que soliciten el procesador.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// Muestra múltiples hilos desplegándose a diferentes
// intervalos.

public class PrintTest {
   public static void main( String args[] )
   {
      PrintThread thread1, thread2, thread3, thread4;

      thread1 = new PrintThread( "1" );
      thread2 = new PrintThread( "2" );
      thread3 = new PrintThread( "3" );
      thread4 = new PrintThread( "4" );

      thread1.start();
      thread2.start();
      thread3.start();
      thread4.start();
   }
}

class PrintThread extends Thread {
   int sleepTime;

   // constructor PrintThread asigna nombre al hilo
   // llamando al constructor de Thread
   public PrintThread( String id )
   {
      super( id );

      // valor aleatorio para dormir el hilo de 0 a 5 segundos
      sleepTime = (int) ( Math.random() * 5000 );

      System.out.println( "Nombre: " + getName() +
                          ";  durmiendo: " + sleepTime );
   }

   // ejecuta el hilo
   public void run()
   {
      try {
         sleep( sleepTime );
      }
      catch ( InterruptedException exception ) {
         System.err.println( "Excepcion: " +
                             exception.toString() );
      }
      System.out.println( "Hilo " + getName() );                             
   }
}
\end{minted}
\caption{Ejemplo múltiples hilos desplegándose a diferentes
// intervalos.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Comportamiento de los hilos}

La implementación real de los hilos puede variar un poco de una plataforma a otra. Algunos sistemas como \textit{Windows}, los hilos funcionan por \textbf{rebanadas de tiempo} y otros como muchas versiones de \textit{Unix} no tienen esta característica.

En los sistemas que se manejan rebanadas de tiempo, los hilos de igual prioridad se reparten el tiempo de ejecución en partes iguales. En los sistemas que no tienen rebanadas de tiempo, un hilo se ejecuta hasta que cede el control voluntariamente, se lo quita un hilo de \textbf{mayor} prioridad, o termina su ejecución.

Bajo este último esquema, es importante que un hilo delegue el control cada determinado tiempo a hilos de igual prioridad. Para esto sirve poner a dormir el hilo con \textit{sleep()}, o ceder el control con el método \textit{yield()}. Un método que tiene estas consideraciones se conoce como hilo compartido, el caso contrario se conoce como \textbf{hilo egoísta}.

Tener en cuenta que el método \textit{yield()} cede el control a hilos de la misma prioridad. Esto es útil en plataformas que no cuenten con rebanadas de tiempo, pero no tiene sentido en sistemas que si cuentan con esta técnica\footnote{Sin embargo debería siempre considerarse el uso de \textit{yield()} si se piensa en sistemas multiplataformas.}.

Veamos una clase que implementa un hilo y cede el control a otros hilos.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class HiloEterno extends Thread {

  public HiloEterno (String nombre) {
    super (nombre);
  }

   public void run()
     {
       int i=0;
        
       while (true)     // Iterar para siempre
         {
          System.out.println(getName() + " " +"Ciclo " + i++);
	       if (i%100==0)  
       		yield();     // Ceder el procesador a otros hilos
         }
     }
 }

public class MultiHilo2 {
    public static void main(String arg[]) {
        HiloEterno infinito = new HiloEterno("Al infinito");
        HiloEterno  masAlla = new HiloEterno("y mas alla");
        infinito.start();
        masAlla.start();
    }
}

\end{minted}
\caption{Ejemplo que implementa un hilo y cede el control a otros hilos.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

	
\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%

%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\chapter{Multihilos:  Programación Concurrente en Java (2)}
\section{Sincronización de hilos}

Es lógico pensar que un programa concurrente puede tener problemas al tratar de acceder datos comunes. Por ejemplo, si dos hilos tratan de manipular una variable al mismo tiempo, puede ocasionarse un valor inesperado en la misma.  Para evitar este tipo de problemas, Java utiliza \textbf{monitores}\footnote{Un monitor es una colección de variables y procedimientos compartidos, con la restricción de que sólo un proceso a la vez puede ejecutar un procedimiento del monitor.}, permitiendo poner un \textbf{candado} para que un solo hilo pueda acceder a los datos a la vez. 

Existen dos formas de proteger el acceso a datos. El primero es ejecutar un método sincronizado, el cual es definido mediante la palabra reservada \textit{synchronized}, de manera que \textbf{sólo un método sincronizado puede ejecutarse para el objeto}. Hasta que termina de ejecutarse un método sincronizado, se permite que entre a ejecutarse el hilo con mayor prioridad, el cual puede ser a su vez un método sincronizado\footnote{Una opción adicional de implementar sincronización en Java es mediante la clase \textit{ReentrantLock}, pero no se verá en el curso. Ver: \href{https://www.geeksforgeeks.org/reentrant-lock-java/}{Reentrant lock Java}}.

Veamos un primer ejemplo de sincronización.  Se trata del control de una cuenta de cheques, en donde es posible que se trate de cobrar más de un cheque al mismo tiempo (en este caso se muestran dos hilos). El problema se daría si el método que modifica el balance de la cuenta no estuviera sincronizado, pues pudiera darse el caso de que no se registren correctamente los cambios. La modificación del balance es una \textbf{sección crítica}, y por lo mismo se encuentra protegida con monitores.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class Cuenta {
 
  static int balance = 1000;
  static int gasto = 0;

   static public synchronized void retirar(int cantidad)
     {
       if (cantidad <= balance)
         {
           System.out.println("cheque: " + cantidad);
           balance -= cantidad;
           gasto += cantidad;
           System.out.print("balance: " + balance);
           System.out.println(", se gastó: " + gasto);
         }
       else
         {
           System.out.println("rebotó: " + cantidad);
         }
     }
 }

class miHilo extends Thread {
   public void run()
     {
       for (int i = 0; i < 10; i++)
         {
           try {
              sleep(100);
             } 
           catch (InterruptedException e) {}
           Cuenta.retirar((int) (Math.random() * 500 ));
         }
     }
 }

public class Sincronizar  {
 
	public static void main(String arg[]){
      new miHilo().start();
      new miHilo().start();
    }    
}

\end{minted}
\caption{Ejemplo de sincronización de hilos.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Además de declarar un método como \textit{synchronized}, es posible declarar a un objeto y un bloque de código como sincronizados. Esto determina que \textbf{sólo un hilo puede ejecutar métodos del objeto en cuestión}. Por lo tanto, nadie puede modificar sus atributos más que el bloque de código declarado como sincronizado. Veamos el mismo ejemplo anterior implementado ahora con esta técnica:

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class miHilo extends Thread {
   
   static Integer balance = new Integer(1000);
   static int gasto = 0;
   static {  // bloque estático se ejecuta cuando la JVM carga la clase
      System.out.print("Balance inicial: " + balance);
     }
 
   public void run()
     {
        int cuenta;
  
        for (int i = 0; i < 10; i++)
          {
            try {
                sleep(100);
              } 
            catch (InterruptedException e) {}
          
            cuenta = ((int) (Math.random() * 500 ));
            synchronized (balance)
            {
                if (cuenta <= balance.intValue())
                 {
                   System.out.println("cheque: " + cuenta);
                   balance = new Integer(balance.intValue()-cuenta);
                   gasto += cuenta;
                   System.out.print("bal: "+balance.intValue());
                   System.out.println(", se gastó: " + gasto);
                 }else 
                  {
                   System.out.println("rebotó: " + cuenta);
                  }
              }
          }
     }
  }
 
public class ObjetoSincronizado {

   public static void main(String args[]){
       new miHilo().start();
       new miHilo().start();
     }    
}
\end{minted}
\caption{Ejemplo de multihilos declarando un bloque de código sincronizado.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Problema Productor / Consumidor}

En el sentido clásico, el problema del productor /consumidor se presenta cuando  en datos compartidos, un proceso necesita cierto dato (\textbf{consumidor}) que está preparando otro proceso (\textbf{productor}). Es lógico que ninguno de los dos deben acceder el dato al mismo tiempo. Pero también puede suceder que el consumidor llegue antes de que el productor tenga listos los datos; o viceversa, que el productor genere los datos y el consumidor todavía no pueda tomarlos.

El siguiente ejemplo muestra un caso de Productor /Consumidor \textbf{sin} sincronización. Existe un objeto productor que va generando números consecutivos y un objeto consumidor que los va obteniendo. En la ejecución se podrá apreciar que el consumidor ocasionalmente recupera un número más de una vez, lo cual no debería ocurrir\footnote{ Por la forma en que está programado el objeto productor, éste no genera dos veces el mismo número. Pero se daría este caso si obtuviera el último número generado del valor compartido como base para generar el siguiente número.}.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class SharedCell {
   public static void main( String args[] )
   {
      HoldInteger h = new HoldInteger();
      ProduceInteger p = new ProduceInteger( h );
      ConsumeInteger c = new ConsumeInteger( h );

      p.start();
      c.start();
   }
}

class ProduceInteger extends Thread {
   private HoldInteger pHold;

   public ProduceInteger( HoldInteger h )
   {
      pHold = h;
   }

   public void run()
   {
      for ( int count = 0; count < 10; count++ ) {
         pHold.setSharedInt( count );
         System.out.println( "El productor puso: " +
                             count );

        try {
            sleep( (int) ( Math.random() * 3000 ) );
         }
         catch( InterruptedException e ) {
            System.err.println( "Excepcion " + e.toString());
         }
      }
   }
}

class ConsumeInteger extends Thread {
   private HoldInteger cHold;

   public ConsumeInteger( HoldInteger h )
   {
      cHold = h;
   }

   public void run()
   {
      int val;

      val = cHold.getSharedInt();
      System.out.println( "Recuperado por el consumidor: " + val );

      while ( val != 9 ) {

         try {
            sleep( (int) ( Math.random() * 3000 ) );
         }
         catch( InterruptedException e ) {
            System.err.println( "Excepcion " + e.toString() );
         }

         val = cHold.getSharedInt();
         System.out.println( "Recuperado por el consumidor: " + val );
      }
   }
}

class HoldInteger {
   private int sharedInt;

   public void setSharedInt( int val ) {
    sharedInt = val;
   }

   public int getSharedInt() {
    return sharedInt;
   }
}
\end{minted}
\caption{Ejemplo: Problema Productor / Consumidor. Modificacion de un objeto compartido sin sincronizacion.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

A continuación veremos el mismo programa, pero resuelto con sincronización:

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Problema Productor /Consumidor
// con sincronizacion de hilos.

public class SharedCell {
   public static void main( String args[] )
   {
      HoldInteger h = new HoldInteger();
      ProduceInteger p = new ProduceInteger( h );
      ConsumeInteger c = new ConsumeInteger( h );

      p.start();
      c.start();
   }
}

class ProduceInteger extends Thread {
   private HoldInteger pHold;

   public ProduceInteger( HoldInteger h )
   {
      pHold = h;
   }

   public void run()
   {
      for ( int count = 0; count < 10; count++ ) {
         pHold.setSharedInt( count );
         System.out.println( "Productor asigna a sharedInt el valor: " +
                             count );

         try {
            sleep( (int) ( Math.random() * 3000 ) );
         }
         catch( InterruptedException e ) {
            System.err.println( "Excepcion " + e.toString() );
         }
      }
   }
}

class ConsumeInteger extends Thread {
   private HoldInteger cHold;

   public ConsumeInteger( HoldInteger h )
   {
      cHold = h;
   }

   public void run()
   {
      int val;

      val = cHold.getSharedInt();
      System.out.println( "Recuperado por Consumidor: " + val );

      while ( val != 9 ) {
         try {
            sleep( (int) ( Math.random() * 3000 ) );
         }
         catch( InterruptedException e ) {
            System.err.println( "Excepcion " + e.toString() );
         }

         val = cHold.getSharedInt();
         System.out.println( "Recuperado por consumidor: " + val );
      }
   }
}

class HoldInteger {
   private int sharedInt;
   private boolean writeable = true;

   public synchronized void setSharedInt( int val )
   {
      while ( !writeable ) {
         try {
            wait();
         }
         catch ( InterruptedException e ) {
            System.err.println( "Excepcion: " + e.toString() );
         }
      }

      sharedInt = val;
      writeable = false;
      notify();
   }

   public synchronized int getSharedInt()
   {
      while ( writeable ) {
         try {
            wait();
         }
         catch ( InterruptedException e ) {
            System.err.println( "Excepcion: " + e.toString() );
         }
      }

      writeable = true;
      notify();
      return sharedInt;
   }
}
\end{minted}
\caption{Ejemplo: Problema Productor /Consumidor
// con sincronizacion de hilos.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


En el ejemplo anterior se introducen los métodos \textit{wait()} y \textit{notify()}. Estos ayudan a mejorar el funcionamiento de los métodos sincronizados. Cuando un hilo sincronizado no puede continuar por algún motivo, deberá llamar al método \textit{wait()}, permitiendo que el hilo deje de competir por el tiempo de procesador y que otro hilo pueda procesar los datos compartidos. El método \textit{notify()} es ocupado para avisar a un hilo que se encuentra en espera, que el hilo que hizo la llamada ha terminado de realizar su proceso crítico y que pueden intentar ejecutarse, obteniendo para esto el \textbf{candado} del objeto monitor.

Veamos un último ejemplo para dejar claro el uso de \textit{wait()} y \textit{notify()}, usando el mismo concepto de Productor/consumidor.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
class Tienda {
   int mercancia = 0;
    
   public synchronized int consumir()
     {
       int temp;
       while (mercancia == 0)
         {
           try {
              wait();
            } 
          catch (InterruptedException e) {}
         }

       temp = mercancia;
       mercancia = 0;
       System.out.println("Se consumió: " + temp);
       notify();
       return temp;
     }

   public synchronized void producir(int cantidad)
     {
       while (mercancia != 0)
         {
           try {
               wait();
             } 
           catch (InterruptedException e) {}
         }

       mercancia = cantidad;
       notify();
       System.out.println("Se produjo: " + mercancia);
     }
 }
 
class miHilo extends Thread {
 
   boolean productor = false;
   Tienda tienda;
 
   public miHilo(Tienda d, String tipo)
     {
       tienda = d;

       if (tipo.equals("Productor"))
         productor = true;
     }
    
   public void run()
     {
       for (int i = 0; i < 10; i++) 
        {
          try {
             sleep((int)(Math.random() * 200 ));
           } 
          catch (InterruptedException e) {}
          
          if (productor)
            tienda.producir((int)(Math.random() * 10 ) + 1);
          else // debe ser un consumidor 
            tienda.consumir();
        }
     }
 }

public class WaitNotify  {
 
   Tienda tienda = new Tienda();

   public static void main(String args[]){
	   WaitNotify wn = new WaitNotify();
	   wn.ini();
   }
   
   public void ini(){
       new miHilo(tienda, "Consumidor").start();
       new miHilo(tienda, "Productor").start();
     }    
 }
\end{minted}
\caption{Ejemplo adicional de productor/consumidor.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Esperando que haya  quedado claro el uso de \textit{wait()} y \textit{notify()}, mencionaremos algunas observaciones que consideramos importantes. En primer lugar, un hilo que es puesto en espera mediante el método \textit{wait()}, debe ser notificado en algún momento de que puede continuar, de lo contrario puede quedarse esperando indefinidamente. Es vital entonces que para cada llamada a \textit{wait()} haya una correspondiente llamada a \textit{notify()}. Un hilo también puede ser mandado a la cola de espera porque trate de entrar un método sincronizado y ya se encuentre en ejecución un método sincronizado para ese objeto; pero, a diferencia de un hilo puesto en espera explícitamente, este hilo se reactivará cuando tenga oportunidad de entrar sin necesidad de que le notifiquen.

El método \textit{notify()} sólo le indica a un hilo que puede dejar de esperar. Existe además un método \textit{notifyAll()}, que hace que todos los hilos que están en espera traten de ejecutarse. Obviamente sólo uno podrá hacerlo, pero todos tendrán la oportunidad de entrar. 

Hay que tener cuidado con las sincronizaciones, ya que demasiado código sincronizado puede hacer muy lenta la ejecución de los hilos. Se debe sincronizar únicamente cuando se trate de situaciones críticas que tienen que ver con datos compartidos.

Un problema común es que un programa muy sincronizado genere una ejecución casi secuencial. Otro problema más grave es que puede llegarse a dar el caso de que todos los hilos se queden esperando, esto se conoce como \textbf{abrazo mortal} (\textit{deadlock}), y por supuesto que hay que tratar de evitarlo\footnote{Investigar sobre el problema de los filósofos tragones.}.  El abrazo mortal se puede evitar con una cuidadosa programación que promueva el uso ordenado de los recursos\footnote{Existen algunos métodos formales que salen del alcance de este curso.}.

\section{Grupos de hilos}

Cuando se tiene un programa que necesita manejar múltiples hilos, es posible que varios de ellos estén trabajando en procesos similares. En Java, es posible agrupar los hilos para poder manipularlos de manera más eficiente, ya que se pueden enviar mensajes al grupo de hilos - como una unidad - en lugar de tener que hacerlo a cada uno de los hilos.

Para lograr esto, se provee de la clase \textit{ThreadGroup}, la cual proporciona métodos para el control de los hilos que en general son versiones de grupo de los métodos que proporciona la clase \textit{Thread}. La formación de un grupo de hilos puede darse de la siguiente forma:

\begin{minted}{java}
ThreadGroup nombreGrupo = new ThreadGroup( "nombre del   grupo");
miHilo mh1 = new miHilo (nombreGrupo, "hilo 1");
miHilo mh2 = new miHilo (nombreGrupo, "hilo 2");
\end{minted}

\section{Hilos Demonios}

Es posible tener en Java hilos demonio o \textit{daemon}. Estos hilos tienen este nombre ya que -como los \textit{daemon} de un sistema operativo- son procesos servidores que se encuentran corriendo con el propósito de proporcionar un servicio a otros hilos.

Estos hilos \textit{daemon} se ejecutan por lo general con una prioridad baja, y si no hay ningún otro hilo al que le deban prestar servicio, finalizan. Un ejemplo de un hilo \textit{daemon} es el recolector de basura\footnote{garbage collector} de Java. Para que un hilo definido por nosotros sea considerado \textit{daemon} debe especificarse mediante el uso del método \textit{setDaemon()}:
	
\begin{minted}{java}
	Thread miHilo= new Thread();
	miHilo.setDaemon(true);
\end{minted}
Es importante señalar que un hilo debe de ser determinado como \textit{daemon} antes de que se ejecute el método \textit{start()} de ese hilo, o será lanzada la excepción \textit{IllegalThreadStateException}.

\section{La interfaz \textit{Runnable}}

Se ha visto la implementación de hilos heredando de la clase \textit{Thread}, la cual es la forma más común. Pero puede ser que la clase, a la que queremos implementar funcionalidades de hilos, ya tenga definida herencia de otra clase. Como Java no soporta herencia múltiple, para implementar el hilo en la clase tendría que hacerse a través de la interfaz \textit{Runnable}.

Esta interfaz únicamente tiene definido el método \textit{run()}, el cual debe implementarse al igual que en la clase que se extiende la clase Thread. El esquema general para usar la interfaz \textit{Runnable} es:

\begin{minted}{java}
public class MiHilo implements Runnable {

  public void run(){
     //código del hilo
  }
}
\end{minted}

El inicio de la ejecución de un hilo difiere cuando se implementa esta interfaz, ya que se debe crear una instancia de la clase \textit{Thread} y pasarle como parámetro al constructor del hilo un objeto de la clase que implementa la interfaz \textit{Runnable}:

\begin{minted}{java}
Thread miHilo= new Thread( new MiHilo() );

miHilo.start();
\end{minted}

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class DemoThread implements Runnable {

    @Override
    public void run() {
        for (int i = 0; i < 3; i++) {
            System.out.println("Hilo Hijo ");

            try {
                Thread.sleep(200);
            } catch (InterruptedException ie) {
                System.out.println("Hilo hijo se ha interrumpido! " + ie);
            }
        }

        System.out.println("Hilo hijo finalizado!");
    }

    public static void main(String[] args) {
        Thread t = new Thread(new DemoThread ());

        t.start();

        for (int i = 0; i < 3; i++) {
            System.out.println("Hilo principal");
            try {
                Thread.sleep(200);
            } catch (InterruptedException ie) {
                System.out.println("Hilo hijo interrumpido! " + ie);
            }
        }
        System.out.println("Hilo principal finalizado!");
    }
}
\end{minted}
\caption{Ejemplo de multihilos usando la interfaz Runnable.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\ejemplo \footnote{ Al compilar este programa el compilador nos avisará del uso de métodos deprecated, debido a que el código incluye llamadas a suspend() y resume().}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// Ejemplo de implementacion de la interfaz Runnable
import java.awt.*;
import java.applet.Applet;

public class RandomCharacters extends Applet
                              implements Runnable {

   String alphabet;
   TextField output1, output2, output3;
   Button button1, button2, button3;

   Thread thread1, thread2, thread3;

   boolean suspend1, suspend2, suspend3;

   public void init()
   {
      alphabet = new String( "ABCDEFGHIJKLMNOPQRSTUVWXYZ" );
      output1 = new TextField( 10 );
      output1.setEditable( false );
      output2 = new TextField( 10 );
      output2.setEditable( false );
      output3 = new TextField( 10 );
      output3.setEditable( false );
      button1 = new Button( "Suspender/Continuar 1" );
      button2 = new Button( "Suspender/Continuar 2" );
      button3 = new Button( "Suspender/Continuar 3" );

      add( output1 );
      add( button1 );
      add( output2 );
      add( button2 );
      add( output3 );
      add( button3 );
   }

   public void start()
   {
      // crea hilos e inicia cada vez que se invoca start()
      thread1 = new Thread( this, "Hilo 1" );
      thread2 = new Thread( this, "Hilo 2" );
      thread3 = new Thread( this, "Hilo 3" );

      thread1.start();
      thread2.start();
      thread3.start();
   }

   public void stop()
   {
      // detiene los hilos cada vez que se invoca stop()
      thread1.stop();
      thread2.stop();
      thread3.stop();
   }

   public boolean action( Event event, Object obj )
   {
      if ( event.target == button1 )
         if ( suspend1 ) {
            thread1.resume();
            suspend1 = false;
         }
         else {
            thread1.suspend();
            output1.setText( "suspendido" );
            suspend1 = true;
         }
      else if ( event.target == button2 )
         if ( suspend2 ) {
            thread2.resume();
            suspend2 = false;
         }
         else {
            thread2.suspend();
            output2.setText( "suspendido" );
            suspend2 = true;
         }
      else if ( event.target == button3 ) 
         if ( suspend3 ) {
            thread3.resume();
            suspend3 = false;
         }
         else {
            thread3.suspend();
            output3.setText( "suspendido" );
            suspend3 = true;
         }

      return true;
   }

   public void run(){
      int location;
      char display;
      String executingThread;

      while ( true ) {
         try {
            Thread.sleep( (int) ( Math.random() * 5000 ) );
         }
         catch ( InterruptedException e ) {
            e.printStackTrace();
         }

         location = (int) ( Math.random() * 26 );
         display = alphabet.charAt( location );

         executingThread = Thread.currentThread().getName();

         if ( executingThread.equals( "Hilo 1" ) )
            output1.setText( "Hilo 1: " + display );
         else if ( executingThread.equals( "Hilo 2" ) )
            output2.setText( "Hilo 2: " + display );
         else if ( executingThread.equals( "Hilo 3" ) )
            output3.setText( "Hilo 3: " + display );
      }
   }
}
\end{minted}
\caption{Ejemplo de implementacion de la interfaz \textit{Runnable} con un \textit{applet}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Actividades sugeridas}

Hacer un programa que simule el problema de los filósofos tragones (ver figura \ref{fig:filosofos}).

\begin{figure}
    \centering
    \includegraphics[scale=.35]{imagenes/filosofos.png}
    \caption{ Filósofos tragones }
    \label{fig:filosofos}
\end{figure}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Lecturas complementarias recomendadas} 
\end{center} 
\\ \hline
     • Writing multithreaded Java applications   \footnote{\url{http://www-128.ibm.com/developerworks/library/j-thread.html}} \\
    • Synchronization is not the enemy \\
    • Reducing contention  \\
    • Threading lightly : Sometimes it's best not to share \\
\\ \hline
\end{tabular}
\end{center}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%





%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage







\chapter{Multihilos en Python}
\section{Forking (Bifurcación)}
Una manera relativamente simple de implementar procesos concurrentes en Python es mediante \textit{forking} o bifurcación de procesos.

La bifurcación de procesos son una forma tradicional de ejecutar tareas concurrentes en Unix. La bifurcación esta basada en la idea de \textit{copia de programas}. Cuando un programa llama a una rutina bifurcada, el sistema operativo realiza una nueva copia del programa y su proceso en memoria e inicia la ejecución de la copia en paralelo con el programa original. 

El programa original es llamado \textit{proceso padre}, mientras la copia creada es llamada \textit{proceso hijo}

El soporte de Python para bifurcación se encuentra en el módulo \textit{os} y son en realidad llamadas encapsuladas a las operaciones del sistema para manejo de procesos.

Para iniciar un nuevo proceso concurrente se llama a la función $os.fork()$, lo que genera una copia del programa. Esta llamada regresa el valor de cero en el proceso hijo y el ID del proceso del nuevo hijo en el proceso padre. Este valor de cero generalmente es usado para diferenciar el código de ejecución del proceso hijo.

La bifurcación es parte del modelo Unix por lo que funciona bien en sistemas Unix, Linux y OS X, pero no funciona adecuadamente en Windows.

Veamos un ejemplo simple de bifurcación de procesos.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
#Bifurca procesos hijos hastq eu se introduce 's'

import os

def hijo():
    print('Hola desde el proceso hijo', os.getpid()) 
    os._exit(0) # si no regresa al ciclo padre

def padre(): 
    while True:
        newpid = os.fork() 
        if newpid == 0:
            hijo() 
        else:
            print('Hola desde el proceso padre', os.getpid(), newpid) 
        if input("Salir(s)") == 's': 
            break
        
padre()
\end{minted}
\caption{Ejemplo de bifurcación de procesos (Forking).}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El siguiente ejemplo iniciará cinco copias y sale inmediatamente.  Cada copia tiene un retardo de un segundo y se ejecuta a pesar de que el proceso padre ha terminado. 

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
""""
Inicia 5 copias del programa corriendo en paralelo con el original;
cada copia cuenta hasta 5 en el mismo flujo de salida estándar, 
bifurca copiando la memoria del proceso. 
No trabaja en Windows sin Cygwin
"""

import os, time

def contador(count):             #ejecuta un nuevo proceso
    for i in range(count):
        time.sleep(1)           # simula que trabaja
        print('[%s] => %s' % (os.getpid(), i))

for i in range(5): 
    pid = os.fork()
    if pid != 0:
        print('Proceso %d generado' % pid)  # en proceso padre: continua
    else: 
        contador(5)              # sino in proceso hijo/nuevo 
        os._exit(0)             # ejecuta función y sale

print('Saliendo del proceso principal.') #proceso padre no necesita esperar

\end{minted}
\caption{Ejemplo de bifurcación de 5 procesos (Forking).}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{fork/exec}

La combinación de \textit{fork} con ejecución de programas en sistemas operativos tipo Unix son otra forma simple de iniciar procesos concurrentes. Esto implica por un lado la creación de un proceso con la llamada al sistema operativo de ejecutar otro programa, para lo cual se puede ocupar alguna de los diferentes formatos de llamadas a funciones $os.exec$. Por ejemplo, una llamada a la función $os.execlp()$, le especifica al programa que se ejecute a partir de la línea de comandos usada para iniciar el programa. El nuevo programa se ejecutará y no regresa al programa original, que pudo haber terminado su ejecución. Este estilo de programación es similar al desarrollo de tareas paralelas en Unix.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

import os

parm = 0 
while True:
  parm += 1
  pid = os.fork() 
  if pid == 0:          # proceso de copia
    os.execlp('python', 'python', 'hijo.py', str(parm))  
    assert False, 'error iniciando programa'                
  else:
    print('Proceso hijo: ', pid) 
    if input("Salir (s)") == 's': 
      break

\end{minted}
\caption{Ejemplo de uso de os.execlp().}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Las variantes de $os.exec$ permite configurar variables de ambiente, pasar argumentos de comandos de diferentes formas, entre otras cosas.



%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
\newpage

%
%

$os.execv(program, commandlinesequence)$

The basic “v” exec form is passed an executable program’s name, along with a list or tuple of command-line argument strings used to run the executable (that is, the words you would normally type in a shell to start a program).

$os.execl(program, cmdarg1, cmdarg2,... cmdargN)$

The basic “l” exec form is passed an executable’s name, followed by one or more command-line arguments passed as individual function arguments. This is the same as os.execv(program, (cmdarg1, cmdarg2,...)).

$os.execlp$

$os.execvp$

Adding the letter p to the execv and execl names means that Python will locate the executable’s directory using your system search-path setting (i.e., PATH).

$os.execle$

$os.execve$

Adding a letter e to the execv and execl names means an extra, last argument is a dictionary containing shell environment variables to send to the program.

$os.execvpe$

$os.execlpe$

Adding the letters p and e to the basic exec names means to use the search path and to accept a shell environment settings dictionary.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
import os, sys
print('Hello from child', os.getpid(), sys.argv[1])

\end{minted}
\caption{Ejemplo .}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%



\section{Threads}

El manejo de hilos en Python puede hacerse de con diferentes módulos. En nuestro caso, vamos a revisar 3 módulos: $_thread$, $threading$ y $queue$.


\subsection{Módulo \_thread}

Este módulo es la aproximación más simple al manejo de hilos. Es básicamente una interfaz al sistema de multihilos del sistema operativo.

La función $\_thread.start\_new\_thread$ toma una función (o cualquier objeto invocable) y una tupla de argumento y e inicia un nuevo hilo para ejecutar la llamada a la función pasada como parámetro con los argumentos recibidos. 

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
"lanza hilos hasta que se introduce 's'" 

import _thread

def hijo(tid):
  print('Hola desde el hilo', tid)

def padre(): 
  i= 0
  while True: 
    i += 1
    _thread.start_new_thread(hijo, (i,)) 
    if input("s para salir: ") == 's': 
      break

padre()

\end{minted}
\caption{Ejemplo con el módulo $\_thread$.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Todos los hilos se ejecutan en el mismo proceso. Un hilo puede también ejecutar una función lambda o un método enlazado de un objeto.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
import _thread

def acción(i): 
  print(i ** 32)

class Potencia:
  def __init__(self, i):
    self.i = i 
  def acción(self):
    print(self.i ** 32)

_thread.start_new_thread(acción, (2,))

_thread.start_new_thread((lambda: acción(2)), ())

obj = Potencia(2) 
_thread.start_new_thread(obj.acción, ())

\end{minted}
\caption{Ejemplo con el módulo $\_thread$ con función lambda además de un método.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El siguiente ejemplo ejecuta múltiples hilos concurrentes.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
"""
Inicia 5 copias de una función ejecutándose concurrentemente
Usa time.sleep para que el hilo principal no finalice muy temprano, ya que en
algunas plataformas esto mata a todos los otros hilos
La stdout es compartida, las salidas de los hilos podría verse mezclada
de forma arbitraria
"""

import _thread as thread, time

def contador(miId, cont):       # función ejecutado en los hilos
  for i in range(cont):
    time.sleep(1)               
    print('[%s] => %s' % (miId, i))

for i in range(5):              # lanza 5 hilos
  thread.start_new_thread(contador, (i, 5))   #cada hilo itera 5 veces

time.sleep(6)
print("Saliendo del hilo principal")

\end{minted}
\caption{Ejemplo con el módulo $\_thread$ con 5 hilos concurrentes.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\subsubsection{Acceso sincronizado a nombres y objetos compartidos}

El módulo $\_thread$ incluye una forma de sincronización basada en el concepto de bloqueo (\textit{lock}). el hilo adquiere un bloqueo, hace sus cambios, y libera el bloqueo para que otros hilos lo obtengan. Únicamente un hilo puede obtener el bloqueo en un momento en particular. Si otros hilos lo solicitan mientras se encuentra activo el bloqueo, estos son detenidos hasta que se encuentre disponible.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

"""
Acceso sincronizado a stdout: debido a que es compartido globalmente,
la salida de los hilos puede mezclarse si no se sincroniza
"""

import _thread as thread, time

def contador(miId, cont):       # función ejecutado en los hilos
  for i in range(cont):
    time.sleep(1)      
    mutex.acquire()         
    print('[%s] => %s' % (miId, i))
    mutex.release()

mutex = thread.allocate_lock()  # generar un objeto para bloqueo global
for i in range(5):              # lanza 5 hilos
  thread.start_new_thread(contador, (i, 5))   #cada hilo itera 5 veces

time.sleep(6)
print("Saliendo del hilo principal")

\end{minted}
\caption{Ejemplo de acceso sincronizado a stdout.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El bloqueo de hilos puede ser útil para comportamientos un poco más elaborados. El siguiente ejemplo usa una lista global de bloqueos para saber que hilos han terminado.


%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

"""
Usa mutexes para saber cuando los hilos han terminado en un hilo principal,
en lugar de time.sleep.
"""

import _thread as thread

stdoutmutex = thread.allocate_lock()
mutexesFinalizados = [thread.allocate_lock() for i in range(10)]

def contador(miId, cont): 
  for i in range(cont):
    stdoutmutex.acquire() 
    print('[%s] => %s' % (miId, i)) 
    stdoutmutex.release()
  mutexesFinalizados[miId].acquire() # signal main thread

for i in range(10): 
  thread.start_new_thread(contador, (i, 100))

for mutex in exitmutexes:
  while not mutex.locked(): 
    pass

print('Salida de hilo principal')

\end{minted}
\caption{Ejemplo con una lista global para saber que un hilo ha terminado.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

O una versión más simple con una lista de enteros:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

"""
Usa una lista de datos globales (no mutexes) para saber cuando los hilos han 
terminado en un hilo principal; lista de hilos pero no sus elementos, se asume 
que la lista no se moverá de la memoria una vez que se ha creado inicialmente
"""

import _thread as thread

stdoutmutex = thread.allocate_lock()
mutexesFinalizados = [False] * 10

def contador(miId, cont): 
  for i in range(cont):
    stdoutmutex.acquire() 
    print('[%s] => %s' % (miId, i)) 
    stdoutmutex.release()
  mutexesFinalizados[miId] = True # signal main thread

for i in range(10): 
  thread.start_new_thread(contador, (i, 100))

while False in mutexesFinalizados: 
    pass

print('Salida de hilo principal')

\end{minted}
\caption{Ejemplo con una lista de enteros para saber que un hilo ha terminado.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\subsection{Módulo threading}

El módulo threading es una interface de alto nivel basada en clases y objetos. Internamente usa el módulo $\_thread$ para implementar objetos que representen hilos y herramientas básicas de sincronización.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

"""
Instancias de clase thread con estado y run() para la acción del hilo;
usa módulo multhilo de alto nivel similar a Java con método join (sin mutexes ni variables
compartidas globales) para saber cuando los hilos han terminado en el 
hilo principal.

"""
import threading

class MiHilo(threading.Thread):
  def __init__(self, miId, cont, mutex):
    self.miId = miId
    self.cont = cont
    self.mutex = mutex 
    threading.Thread.__init__(self)
  
  def run(self):
    for i in range(self.cont):
        with self.mutex:
          print('[%s] => %s' % (self.miId, i))

stdoutmutex = threading.Lock() 
hilos = []
for i in range(10):
  hilo = MiHilo(i, 100, stdoutmutex) 
  hilo.start()
  hilos.append(hilo)

for hilo in hilos: 
  hilo.join()

print('saliendo del hilo principal.')

\end{minted}
\caption{Ejemplo de uso de módulo $threading$.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En el ejemplo anterior vemos como se usa el método $join()$ para esperar a que el hilo salga; este método puede ser usado para prevenir que se salga del hilo principal  antes de los hilos hijos, en lugar de usar $time.sleep()$. 
También se puede usar $threading.lock()$ para sincronizar el acceso al flujo de manera similar a $\_thread.allocate\_lock$

En el siguiente ejemplo se muestra como se puede usas la clase $Thread$ para iniciar una función simple, o de hecho cualquier tipo de objeto invocable, sin el uso de subclases.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

import threading, _thread 

def accion(i):
  print(i ** 32)

# subclase con estado
class MiHilo(threading.Thread): 
  def __init__(self, i):
    self.i = i
    threading.Thread.__init__(self) 
  
  def run(self):                # redefine run con la acción
    print(self.i ** 32) 
  
MiHilo(2).start()               #start() invoca run()

# pasar acción en
hilo = threading.Thread(target=(lambda: accion(2)))   #run() invoca target
hilo.start()

#lo mismo pero sin envoltura lambda para el estado
threading.Thread(target=accion, args=(2,)).start()    # invocable mas sus args

#simple módulo de hilo
_thread.start_new_thread(accion, (2,))    

\end{minted}
\caption{Ejemplo de uso de módulo $threading$ usando la clase $Thread$ sin herencia.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Generalmente, hilos basados en clases pueden ser mejores si los hilos requieren un estado por hilo o pueden aprovechar los beneficios del paradigma OO en general. Las clases de hilos no necesariamente tienen que ser una subclase de $Thread$. Es posible inclusive combinar técnicas de clases anidadas y métodos enlazados. 

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

import threading, _thread
#una clase sin heredar de hilo con su estado

class Potencia:
  def __init__(self, i):
    self.i = i 
    
  def accion(self):
    print(self.i ** 32)

obj = Potencia(2) 
threading.Thread(target=obj.accion).start()

# alcance anidado para retener el estado
def accion(i): 
  def potencia():
    print(i ** 32) 
  return potencia

threading.Thread(target=accion(2)).start()

# ambas conmódulo básico de hilo
_thread.start_new_thread(obj.accion, ()) 
_thread.start_new_thread(accion(2), ())

\end{minted}
\caption{Ejemplo de uso de módulo $threading$ con referencia anidada.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}



\subsection{Módulo Queue}

Programas con hilos pueden ser frecuentemente estructurados como un conjunto de hilos productores y consumidores, que se comunican colocando datos y tomándolos de una cola compartida.  Mientras la cola sincronice el acceso a si misma, esto automáticamente sincronizará las interacciones entre los hilos.

Python cuenta con el módulo $queue$ que proporciona una estructura estándar de cola para objetos  en el que los elementos son añadidos por un lado y extraídos por el otro. La diferencia es que la cola de objetos es automáticamente controlada con operaciones de bloqueo de hilo y liberación, de forma que únicamente un hilo pueda modificar la cola en un momento determinado. 

El siguiente ejemplo muestra 2 hilos consumidores que esperan por datos que aparecen en la cola compartida y 4 hilos productores que colocan datos en la cola periódicamente después de dormir por un intervalo de tiempo. De forma que este ejemplo está ejecutando 7 hilos concurrentes (incluyendo el hilo principal) donde 6 hilos acceden a la cola compartida de forma concurrente.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}

# hilos productor y consumidor comunicándose con una cola compartida

numconsumidores = 2         # cantidad de consumidores para iniciar
numproductores = 4          # cantidad de productores para iniciar
nummensajes = 4             # mensajes para poner por productor
  
import _thread as thread, queue, time 

print_seguro = thread.allocate_lock()  # prints en el else se podrían superponer
cola_datos = queue.Queue()           #  compartido global, tamaño infinito

def productor(idnum, cola_datos):
  for num_mensaje in range(nummensajes):
    time.sleep(idnum)
    cola_datos.put('[productor id=%d, contador=%d]' % (idnum, num_mensaje))

def consumidor(idnum, cola_datos): 
  while True:
    time.sleep(0.1)
    try:
      dato = cola_datos.get(block=False)
    except queue.Empty: 
      pass
    else:
      with print_seguro:
        print('consumidor', idnum, 'obtuvo =>', dato)

if __name__ == '__main__':
  for i in range(numconsumidores):
    thread.start_new_thread(consumidor, (i, cola_datos)) 
  for i in range(numproductores):
    thread.start_new_thread(productor, (i, cola_datos)) 
  time.sleep(((numproductores-1) * nummensajes) + 1) 
  print('Salida de hilo principal.')
  
\end{minted}
\caption{Ejemplo de uso de módulo $queue$ productor/consumidor.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}




%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
\newpage

%
%
\subsection{Módulo subprocess}
https://twitter.com/driscollis/status/1470503196976160771
https://dzone.com/articles/interacting-with-a-long-running-child-process-in-p
\subsection{Avanzado: interprocess communication}
\subsection{Avanzado: Multiprocesamiento}






\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%




\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%



%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\chapter{Java: Clases anidadas y anónimas}
\section{Clases anidadas}

\textbf{Las clases anidadas son clases definidas dentro del alcance de otras clases. }Existen dos tipos de clases anidadas\footnote{Fuente: \href{Fuente: https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html}{Nested class}}:

\begin{itemize}
\item Clase anidadas estáticas
\item Clases interiores, las cuales son clases anidadas no estáticas
\end{itemize}

% TABLA con más de una línea de CÓDIGO
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Sintaxis} 
\end{center} 
\\ \hline
    \begin{minted} [linenos=false]{java}
class claseExterna {
    ...
    static class ClaseAnidadaEstática {
        ...
    }
    class claseInterior {
        ...
    }
}
    \end{minted}
\\ \hline
\end{tabular}
\end{center}

Una clase anidada es un miembro de la clase que la define, la clase externa. Clases interiores (clases anidadas no estáticas) tienen acceso a otros miembros de la clase externa, inclusive si estos miembros son privados. Clases anidadas estáticas no tienen acceso a los otros miembros de la clase externa. Las clases anidadas, al ser miembros de una clase pueden ser definidas como públicas, protegidas o privadas (privadas a nivel de paquete).

Una clase anidada puede ser 
\begin{itemize}
\item Es una forma de agrupar clases que son usadas en un sólo lugar
\item Incrementa la encapsulación
\item Puede llevar a un código más fácil de leer y/o mantener.
\end{itemize}

\ejemplo
Clases internas.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class EstructuraDeDatos {
    
    // Crea un arreglo 
    private final static int TAMAÑO = 15;
    private int[] arregloDeEnteros = new int[TAMAÑO];
    
    public EstructuraDeDatos() {
        for (int i = 0; i < TAMAÑO; i++) {
        	arregloDeEnteros[i] = i;
        }
    }
    
    public void despliegaPares() {
        
        // despliega valores de índices pares del arreglo
    	IteradorDeEstructuraDeDatos iterador = this.new IteradorPares();
        while (iterador.hasNext()) {
            System.out.print(iterador.next() + " ");
        }
        System.out.println();
    }
    
    //interfaz anidada extiende la interfaz Iterator<Interger>
    interface IteradorDeEstructuraDeDatos extends java.util.Iterator<Integer> { } 

    // Clase anidada implementa interfaz IteradorDeEstructuraDeDatos
    private class IteradorPares implements IteradorDeEstructuraDeDatos {
        
        // Inicializa el iterador para el inicio del arreglo
        private int nextIndice = 0;
        
		@Override
        public boolean hasNext() {
            //Verifica si el elemento actual es el último en el arreglo 
            return (nextIndice <= TAMAÑO - 1);
        }        
        
		@Override
        public Integer next() {
            // Registra un valor de un índice par del arreglo
            Integer reValor = Integer.valueOf(arregloDeEnteros[nextIndice]);
            
            // obtiene el siguiente elemento par
            nextIndice += 2;
            return reValor;
        }

		@Override
		public void remove() {
			// implementación es opcional
			throw new UnsupportedOperationException();
			
		}
    }
    
    public static void main(String s[]) {
    	EstructuraDeDatos edd = new EstructuraDeDatos();
        edd.despliegaPares();
    }
}
\end{minted}
\caption{Ejemplo de clases internas.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Variables con el mismo nombre. \ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class PruebaOcultarVariables {

    public int x = 0;

    class PrimerNivel {

        public int x = 1;

        void métodoEnPrimerNivel(int x) {
            System.out.println("x = " + x);
            System.out.println("this.x = " + this.x);
            System.out.println("PruebaOcultarVariables.this.x = " 
            + PruebaOcultarVariables.this.x); //Despliega x de la clase externa (x=0)
        }
    }

    public static void main(String... args) {
    	PruebaOcultarVariables pov = new PruebaOcultarVariables();
    	PruebaOcultarVariables.PrimerNivel pn = pov.new PrimerNivel();
    	pn.métodoEnPrimerNivel(25);
    }
}
\end{minted}
\caption{Ejemplo variables con el mismo nombre en clases internas .}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Clases anónimas}

\textbf{Una clase anónima es una clase anidada que no tiene un nombre.} Combina  en un solo paso la definición de la clase anidada y la instanciación de la misma.

Una clase anónima se ocupa cuando una clase solo se requiere una vez\footnote{\href{https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html}{Anonymouse classes}}.

Las clases anónimas son compiladas con el nombre de las clase que las contienen seguida de \$ y un número consecutivo. Por ejemplo: \textit{Clasecontenedora\$1.class}

Un código de clases anónimas. \ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
public class ClasesAnónimasHolaMundo {
	  
    interface HolaMundo {
        public void saludar();
        public void saludarAlguien(String alguien);
    }
  
    public void decirHola() {
        
        class SaludarEnInglés implements HolaMundo {
            String nombre = "world";
            public void saludar() {
            	saludarAlguien("world");
            }
            public void saludarAlguien(String alguien) {
                nombre = alguien;
                System.out.println("Hello " + nombre);
            }
        }
      
        HolaMundo saludarEnInglés = new SaludarEnInglés();
        
        HolaMundo saludarEnFrances = new HolaMundo() {
            String nombre = "tout le monde";
            public void saludar() {
            	saludarAlguien("tout le monde");
            }
            public void saludarAlguien(String alguien) {
                nombre = alguien;
                System.out.println("Salut " + nombre);
            }
        };
        
        HolaMundo saludarEnEspañol = new HolaMundo() {
            String nombre = "mundo";
            public void saludar() {
            	saludarAlguien("mundo");
            }
            public void saludarAlguien(String alguien) {
                nombre = alguien;
                System.out.println("Hola, " + nombre);
            }
        };

        saludarEnInglés.saludar();
        saludarEnFrances.saludarAlguien("Juliette");
        saludarEnEspañol.saludar();
    }

    public static void main(String... args) {
    		ClasesAnónimasHolaMundo miApl =
            new ClasesAnónimasHolaMundo();
        	miApl.decirHola();
    }            
}
\end{minted}
\caption{Ejemplo de clases anónimas.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava

\chapter{Java: Expresiones lambda $\lambda$}
\section{Introducción}


Java fue creado como un lenguaje orientado a objetos en los 90's, pero la tendencia de los lenguajes actuales es ser multiparadigma, tomando conceptos y adaptándolos a los lenguajes actuales. Un paradigma que antes estaba confinado más al mundo académico es el de programación funcional. Éste ha tomado mayor relevancia porque funciona bien con programación concurrente o manejada por eventos. Ejemplos de lenguajes puramente funcionales son Haskell y Erlang.

\includegraphics[scale=.6]{imagenes/java_lambda.png}

Java 8 añade constructores de programación funcional a sus bases orientadas a objetos. Algunos puntos básicos son\footnote{\href{http://www.drdobbs.com/jvm/lambda-expressions-in-java-8/240166764}{Lambda expressions in Java}}: 


\begin{itemize}
\item Una expresión lambda es un bloque de código con parámetros.
\item Expresiones lambda pueden ser convertidas en interfaces funcionales
\item Estas expresiones pueden acceder efectivamente variables finales dentro del alcance que encierran.
\item Se puede tener ahora métodos default y estáticos en las interfaces que ofrecen implementación concreta. Estos métodos de múltiples interfaces pueden generar conflictos que debe atender el programador.
\end{itemize}

Una expresión lambda es un bloque de código que puede ser pasado y ejecutarse eventualmente, una vez o múltiples veces. Básicamente permite la escritura de un método en el lugar que necesitas usarlo. Práctico especialmente si el método solo se va a usar una vez y éste es corto.

Pasar un bloque de código no era fácil en Java. Al ser orientado a objetos, se tenía que construir un objeto que perteneciera a una clase que tuviera el método con el código necesario.


El nombre lambda viene del lógico y matemático \textbf{Alonzo Church}, el cual quería formalizar lo que significa para una función matemática ser efectivamente computable. El usó la letra Griega minúscula lambda  $\lambda$ para marcar los parámetros. Propuso entonces un sistema formal conocido como cálculo lambda ( $\lambda-calculus$).

$\lambda-calculus$ es un simple modelo conceptual de cómputo universal. De hecho, Turing demostró en 1937 que las máquinas de Turing tienen una expresividad equivalente a $\lambda-calculus$ \cite{turing1937computability}. 

\section{Sintaxis de expresiones lambda}

La sintaxis general de una expresión lambda en Java es:


%TABLA para notas, primera linea de CÓDIGO coloreada. 
\begin{center}
\begin{tabular}{|c|}
\hline
\rowcolor{gray!50}\textbf{Sintaxis}\\ 
\hline
 \mint[linenos=false]{java}| (<argumentos>) -> <cuerpo>  |\\
\hline
\end{tabular}
\end{center}

Por ejemplo, las siguientes son expresiones lambda válidas:

\begin{minted}{java}
(int a, int b) -> {return a+b;}

( ) -> System.out.println(“Lambda”)

(String s) -> System.out.println(s)

( ) -> 123
\end{minted}

Algunas características relevantes\footnote{\href{http://viralpatel.net/blogs/lambda-expressions-java-tutorial/}{Lambda expressions java tutorial}}:

\begin{itemize}
\item Una expresión puede tener de cero a n parámetros.
\item El tipo del parámetro puede indicarse explícitamente o puede ser inferido del contexto.
\item Cuando no hay parámetros se debe indicar con paréntesis vacíos (). Si se tienen un sólo parámetro y su tipo es inferido, los paréntesis son opcionales.
\item El cuerpo de la expresión lambda puede ir vacío. 
\item Si se tiene una sola instrucción en el cuerpo, se pueden omitir las llaves y el tipo de retorno de la función es el mismo que el de la instrucción.
\end{itemize}

Las expresiones lambda pueden ser usadas en lugar de las clases anónimas para implementar el método de una interfaz funcional. Una \textbf{interfaz funcional}  es una interfaz que tiene sólo un método abstracto declarado. Cada expresión lambda puede ser implícitamente asignada a una interfaz funcional. 

Por ejemplo, inclusive cuando no especificamos la interfaz funcional, el compilador automáticamente resuelve que la siguiente expresión lambda puede ser enmascarada a la interfaz \textit{Runnable} en la firma del constructor \textit{Thread(Runnable r)}:

\begin{minted}{java}
new Thread(
	( ) -> System.out.println("ejemplo de expresión lambda")
).start();
\end{minted}

Dos diferencias importantes entre expresiones lambda y clases anónimas:


\begin{itemize}
\item Para una clase anónima el uso de this se refiere a la clase anónima, mientras que el uso de this en una expresión lambda se refiere a la clase que contiene la expresión lambda.
\item Para el compilador, una clase anónima es tratada como una clase y generará su código respectivo, mientras que una expresión lambda es compilada y convertida en un método privado de la clase que contiene la expresión.
\end{itemize}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%

%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\chapter{Java: Interfaz gráfica con JavaFX}
\section{Introducción}

JavaFX es el framework más reciente para el desarrollo de interfaces gráficas en Java. Como ya se mencionó, la AWT (\textit{Abstract Window Toolkit}) es útil para desarrollar aplicaciones con interfaces gráficas simples, pero es dependiente de la plataforma. AWT fue reemplazada por Swing - fue incluida inicialmente en Java 1.1-,  incluyendo componentes más robustos que son puestos en lienzos (canvas) y estos componentes son menos dependientes  de la plataforma de ejecución, usando menos recursos nativos\footnote{Información sobre JavaFX y Swing: \href{http://docs.oracle.com/javase/8/javase-clienttechnologies.htm}{Java SE client technologies}}. Swing incluyó componentes ligeros construidos enteramente en Java y \textit{look \& feel} independiente de la plataforma, separando la vista de la lógica del componente.

JavaFX es un conjunto nuevo de componentes para interfaces gráficas que permite desarrollar RIA (\textit{Rich Internet Applications}). Una aplicación RIA es una aplicación Web que ofrece las mismas características que una aplicación de escritorio. Agrega  soporte \textit{multi-touch} (para tabletas y \textit{smartphones}), animación 2D y 3D, reproducción de audio, video, etc.\cite{liang2015introduction}

Una aplicación JavaFX puede ejecutarse\footnote{\href{http://docs.oracle.com/javafx/2/get_started/basic_deployment.htm}{Basic deployment}}:

\begin{itemize}
\item Como aplicación de escritorio desde un archivo JAR
\item Desde la línea de comandos usando el lanzador JavaBeans
\item Dando click en un navegador y bajando la aplicación
\item En una página web al abrirse.
\end{itemize}

La arquitectura de JavaFX puede apreciarse en la  figura \ref{fig:javaFX_architecture}  \footnote{\url{https://docs.oracle.com/javafx/2/architecture/jfxpub-architecture.htm}}.

\begin{figure}
    \centering
    \includegraphics[scale=.7]{imagenes/javafx01_architecture.png}
    \caption{ Arquitectura de JavaFX }
    \label{fig:javaFX_architecture}
\end{figure}	

El framework de JavaFX  esta contenido con el prefijo \textit{javafx}, contando con más de 30 paquetes es la API de Java. La estructura general de una interfaz de usuario JavaFX está basada en:

 \begin{itemize}
\item \textit{Stage}  (Escenario)
\item \textit{Scene} (Escena)
\item \textit{Node}
\item \textit{Layout} (Esquema, disposición) 
\end{itemize}

 JavaFX utiliza una \textbf{metáfora de escenario}. En una obra teatral un escenario contiene a una escena. De esta forma un escenario define un espacio y una escena define que va en ese espacio. Podríamos decir que un escenario es un contenedor de escenas y una escena es un contenedor de los elementos relacionados con dicha escena. 

Una aplicación JavaFX tiene al menos un escenario y una escena mediante las clases \textit{Stage} y \textit{Scene}. \textit{Stage} es un contenedor de alto nivel llamado \textbf{escenario primario}. Es posible tener más de un escenario pero solo un escenario primario es requerido.

Los elementos de una escena son nodos. Puede tratarse de un elemento único (e.g., un botón) hasta grupos de nodos. Adicionalmente, un nodo puede tener un nodo hijo. Por lo que podemos tener: nodos padre, nodos hijo, hojas (o nodos terminales) y el nodo raíz (el nodo en el nivel más alto del árbol). La clase base para todos los nodos es \textit{Node}, algunas de sus principales subclases son \textit{Parent}, \textit{Group}, \textit{Region} y \textit{Control}.

Los \textit{Layouts}  son esquemas que se utilizan para organizar el contenido de los elementos en una escena. Se tienen diferentes clases de “páneles” que heredan de la clase \textit{Node}.

El siguiente \textcolor{blue}{ejemplo} es generado por default en NetBeans al crear un proyecto JavaFX:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.stage.Stage;

public class MyJavaFX extends Application {
	
	@Override // Sobreescribe el método start en la clase Application
	public void start(Stage primaryStage) {
		// Crea una escena y coloca un botón en la escena
		Button btOK = new Button("OK");
		Scene scene = new Scene(btOK, 200, 250);
		primaryStage.setTitle("MyJavaFX"); 
		primaryStage.setScene(scene); // Coloca escena en escenario
		primaryStage.show(); // Despliega escenario
}
	
	/**
	 * El método main solo es necesario para IDEs con soporte limitado
         * de JavaFX. No necesario para ejecución en línea de comandos.
	 */
	public static void main(String[] args) {
		Application.launch(args);
	}
}
\end{minted}
\caption{Ejemplo JavaFX generado por NetBeans.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


Otro \textcolor{blue}{ejemplo:}\cite{liang2015introduction}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
package javafxapplication1;

import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;


public class JavaFXApplication1 extends Application {
    
    @Override
    public void start(Stage escenarioPrimario) {
        Button btn = new Button();
        btn.setText("Di 'Hola Mundo'");
        btn.setOnAction(new EventHandler<ActionEvent>() {
            
            @Override
            public void handle(ActionEvent event) {
                System.out.println("¡Hola, Mundo!");
            }
        });
        
        StackPane root = new StackPane();
        root.getChildren()1.add(btn);
        
        Scene escena = new Scene(root, 300, 250);
        
        escenarioPrimario.setTitle("¡Hola Mundo!");
        escenarioPrimario.setScene(escena);
        escenarioPrimario.show();
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        launch(args);
    }
    
}
\end{minted}
\caption{Ejemplo JavaFX "¡Hola, Mundo!".}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El método \textit{launch()} es un método estático definido en la clase \textit{Application} y que se ocupa para lanzar la aplicación \textit{stand-alone}  de JavaFX. El método\textit{ main(...)} no es necesario si se ejecuta de la terminal, pero puede ser necesario para ejecutar el programa en un IDE que no tenga soporte completo para JavaFX. Al ejecutarse la aplicación JavaFX sin el método \textit{main}, la máquina virtual de Java ejecuta el método\textit{ run()} de la aplicación.

En este ejemplo, la clase redefine el método start() originalmente definido en: 

\textit{javafx.application.Application} 

Al ejecutarse el programa, la máquina virtual genera una instancia de la clase usando el constructor sin parámetros e invoca a su método \textit{start()}. 

El método \textit{start()} usualmente se encarga de colocar los controles de la interfaz de usuario en una escena (\textit{scene}) y la despliega en un escenario (\textit{stage}). 

El ejemplo crea un objeto \textit{Button}  y lo coloca en un objeto Scene. El objeto Scene puede ser creado con el constructor \textit{Scene(node, width, height)} . Se especifica el ancho y alto de la escena y coloca el nodo en la escena.

Un objeto \textit{Stage} es una ventana. Un objeto \textit{Stage} llamado \textit{primaryStage} es creado automáticamente por la JVM al lanzarse la aplicación.

Recordemos que JavaFX usa una \textbf{analogía de un teatro} con clases de escenas y escenarios. Puede verse a un escenario como una plataforma que soporta escenas y nodos como actores que intervienen en las escenas.

Un \textcolor{blue}{ejemplo}\cite{liang2015introduction} con múltiples escenarios, se omite el método \textit{main} ya que, como se explicó no debe ser necesario:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.stage.Stage;

public class MúltipleEscenario extends Application {
    @Override 
    public void start(Stage escenarioPrimario) {
        // Crea una escena y coloca un botón en la escena
        Scene escena = new Scene(new Button("OK"), 200, 250);
        escenarioPrimario.setTitle("MúltipleEscenarioApp"); // asigna título al escenario
        escenarioPrimario.setScene(escena); // Coloca la escena en el escenario
        escenarioPrimario.show(); // Despliega el escenario
        
        Stage escenario = new Stage(); // Crea un nuevo escenario
        escenario.setTitle("Segundo escenario"); 
        // Coloca una escena con un butón en el escenario
        escenario.setScene(new Scene(new Button("Nuevo escenario"), 100, 100));
        escenario.show();
    }
}
\end{minted}
\caption{Ejemplo de JavaFX con múltiples escenarios.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Elementos de interfaz de usuario}

Los elementos de interfaz con el usuario se pueden posicionar estableciendo las posiciones y el tamaño de los elementos en la ventana, pero esto no es la mejor solución. Un modelo más flexible es usar clases contenedoras de tipo panel (\textit{pane}) para colocar los nodos. Un nodo es un componente visual que puede ser un control de interfaz de usuario, una figura o un panel . Se colocan los nodos en un panel y se coloca el panel en una escena. La escena puede ser mostrada en un escenario, como ya se vió en los ejemplos anteriores. Ver figura \ref{fig:javafx_panel} \cite{liang2015introduction}.

\begin{figure}
    \centering
    \includegraphics[scale=.6]{imagenes/javaFX_pane.png}
    \caption{ (a) Paneles son usados para mantener nodos. (b) Nodos pueden ser figuras, vstas de imágenes, controles IU, y paneles. }
    \label{fig:javafx_panel}
\end{figure}

Un ejemplo \cite{liang2015introduction} con panel:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.stage.Stage;
import javafx.scene.layout.StackPane;

public class BotónEnPanel extends Application {
    @Override 
    public void start(Stage primaryStage) {
        // Crea una escena  y coloca botón en la escena
        StackPane panel = new StackPane();
        panel.getChildren().add(new Button("OK"));
        Scene escena = new Scene(panel, 200, 50);
        primaryStage.setTitle("Botón en un panel"); 
        primaryStage.setScene(escena); 
        primaryStage.show(); 
    }
}
\end{minted}
\caption{Ejemplo de JavaFX con panel.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Aunque aquí solo hay un objeto, un objeto \textit{StackPane} coloca los nodos en el centro del panel y los apila, respetando el tamaño preferido del nodo.

\subsection{Diseño de paneles}

De forma similar a las otras bibliotecas de IU, JavaFX ofrece un conjunto de tipos de páneles  para posicionar automáticamente los nodos en un tamaño y posición necesarios. A continuación se describen de manera general los principales paneles manejados.


\begin{itemize}
\item \textit{Pane}. 		Es la clase base de diseño de paneles. Contiene el método \textit{getChildren()} que regresa la lista de nodos del panel. 
\item \textit{StackPane}. 	Coloca los nodos encima unos de otros en el centro del panel.
\item \textit{FlowPane}. 	Coloca los nodos renglón por renglón de manera horizontal o columna por columna, verticalmente. 
\item \textit{GridPane}. 	Coloca los nodos en celdas en una tabla de dos dimensiones. 
\item \textit{BorderPane}. 	Coloca los nodos en las zonas de arriba, derecha, abajo, izquierda y centro.
\item \textit{HBox}. 		Coloca los nodos en un renglón simple. 
\item \textit{VBox}. 		Coloca los nodos en una columna sencilla.  
\end{itemize}
%\\

Los nodos se agregan a la lista del panel  con el método $add( <nodo>)$ de forma individual o con el método $addAll( <nodo 1>, <nodo 2>, ..., <nodo _n>)$  para añadir un conjunto de nodos al panel.

Usando \textit{FlowPane}. \ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.layout.FlowPane;
import javafx.stage.Stage;

public class MuestraFlowPane extends Application {
    @Override 
    public void start(Stage escenarioPrimario) {
        // Crea un panel y asigna sus propiedades
        FlowPane panel = new FlowPane();
		// asigna las propiedades de relleno de espacio 
		// con un objeto de Insets
		//Construye una nueva instancia Insets 
		//con cuatro diferentes offsets . 
		//Parámetros: top - the top offset; 
		//   right - the right offset; 
		// bottom - the bottom offset; left - the left offset. 
		//Fuente: 
		// https://docs.oracle.com/javase/8/javafx/api/javafx/geometry/Insets.html 
        panel.setPadding(new Insets(11, 12, 13, 14)1);
        panel.setHgap(5);
        panel.setVgap(5);
        // Coloca los nodos en el panel
        panel.getChildren().addAll(new Label("Nombre:"),
            new TextField());
        TextField tfIniciales = new TextField();
        tfIniciales.setPrefColumnCount(2);
        panel.getChildren().addAll(new Label("Apellidos:"),
            new TextField(), new Label("Iniciales:"), tfIniciales);
        // Crea una escena y la coloca en el escenario
        Scene escena = new Scene(panel, 200, 250);
        escenarioPrimario.setTitle("MuestraFlowPane"); 
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
    }
}
\end{minted}
\caption{Ejemplo JavaFX de panel usando \textit{FlowPane}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Usando BorderPane. \ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.geometry.Insets;
import javafx.scene.Scene;
import javafx.scene.control.Label;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

public class MuestraBorderPane extends Application {
    @Override 
    public void start(Stage escenarioPrimario) {
        // Crea un BorderPane
        BorderPane panel = new BorderPane();
        // Coloca nodos en el panel
        panel.setTop(new PanelAdaptado("Arriba"));
        panel.setRight(new PanelAdaptado("Derecha"));
        panel.setBottom(new PanelAdaptado("Abajo"));
        panel.setLeft(new PanelAdaptado("Izquierda"));
        panel.setCenter(new PanelAdaptado("Centro"));

        // Crea una escena y la coloca en el escenario
        Scene escena = new Scene(panel);
        escenarioPrimario.setTitle("MuestraBorderPane"); 
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
    }
}

// Define un panel adaptado para mantener una etiqueta en el centro del panel
class PanelAdaptado extends StackPane {
    public PanelAdaptado(String title) {
        getChildren().add(new Label(title));
        setStyle("-fx-border-color: red");
        setPadding(new Insets(11.5, 12.5, 13.5, 14.5));
    }
}
\end{minted}
\caption{Ejemplo JavaFX usando BorderPane.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


Resumiendo:


\begin{itemize}
\item JavaFX es un framework para interfaces de usuario de aplicaciones tanto \textit{stand-alone} como web
\item La idea es reemplazar \textit{AWT} y \textit{Swing}.
\item Una clase principal de JavaFX debe extender la clase \textit{javafx.application.Application} e implementar el método \textit{start()}. 
\item El escenario primario es creado automáticamente por la JVM y pasado al método \textit{start()}.
\item Un escenario es una ventana para el desplegado de una escena. Se pueden añadir nodos a una escena. Paneles, controles y figuras son nodos. Paneles pueden ser usados como contenedores de nodos.
\item La clase \textit{Node} define muchas propiedades que son comunes a todos los nodos. Estas propiedades pueden ser aplicadas a paneles, controles y figuras.
\end{itemize}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%

%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\chapter{Java: Manejo de eventos con JavaFX}
\section{Introducción}

Al igual que con \textit{AWT} o \textit{Swing}, no se trata nada más del diseño de la interfaz de usuario. También se tiene que considerar como se incorpora el comportamiento que el usuario tiene sobre la interfaz, esto se conoce como manejo de eventos. 

Por ejemplo, al dar \textit{click} a una aplicación se necesita incorporar código que procese esa acción. El botón entonces es el \textbf{objeto fuente del evento} donde la acción se origina, el evento por si solo es un objeto. Es necesario crear un objeto capaz de manejar el evento de acción sobre un botón. Este objeto es  llamado un manejador de eventos (\textit{event handler}). Ver figura \ref{fig:javafx_evento}

\begin{figure}
    \centering
    \includegraphics[]{imagenes/javaFX_manejo_eventos.png}
    \caption{ Proceso de manejo de evento }
    \label{fig:javafx_evento}
\end{figure}	

Para poder ser manejador de un evento de acción se requiere:
   
\begin{itemize}
\item El objeto debe ser una instancia de la interfaz \textit{EventHandler \textless T extends Event\textgreater}. Esta interfaz define el comportamiento común para todos los manejadores. Por su parte, \textit{\textless T extends Event\textgreater} especifica que \textit{T} es un tipo genérico que es un subtipo de \textit{Event}.
\item El objeto manejador de \textit{EventHandler} debe estar registrado con el objeto fuente del evento con el método $fuente.setOnAction(manejador)$.
\end{itemize}

La interfaz \textit{EventHandler\textless ActionEvent\textgreater} contiene el método $handle(ActionEvent)$ para procesar el evento de acción. Nuestra clase manejadora debe redefinir este método para responder al evento.

El siguiente \textcolor{blue}{ejemplo} procesa el evento de acción para 2 botones y despliega el mensaje correspondiente al ser presionados:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;


public class ManejoDeEventos extends Application {
    @Override 
    public void start(Stage escenarioPrimario) {
        
        // Crea un panel y establece sus propiedades
        HBox panel = new HBox(10);
        panel.setAlignment(Pos.CENTER);
        Button btHola = new Button("Hola");
        Button btAdiós = new Button("Adiós");
        ClaseManejadoraHola manejador1 = new ClaseManejadoraHola();
        btHola.setOnAction(manejador1);
        ClaseManejadoraAdiós manejador2 = new ClaseManejadoraAdiós();
        btAdiós.setOnAction(manejador2);
        panel.getChildren().addAll(btHola, btAdiós);
       
        // Crea una escena y la coloca en el escenario
        Scene escena = new Scene(panel);
        escenarioPrimario.setTitle("ManejoDeEventos"); 
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
    }
}

class ClaseManejadoraHola implements EventHandler<ActionEvent> {
    @Override
    public void handle(ActionEvent e) {
        System.out.println("Hola");
    }
} 

class ClaseManejadoraAdiós implements EventHandler<ActionEvent> {
    @Override
    public void handle(ActionEvent e) {
        System.out.println("Adiós");
    }
}
\end{minted}
\caption{Ejemplo JavaFX manejo de evento acción para 2 botones .}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Como se aprecia, se declararón dos clases manejadoras, cada una implementa \textit{EventHandler \textless ActionEvent\textgreater} para procesar el evento de acción \textit{ActionEvent}. El objeto \textit{manejador1} es una instancia de \textit{ClaseManejadoraHola}, y es registrado en el botón \textit{btHola}. Cuando el botón es presionado, el método $handle(ActionEvent)$ en \textit{ClaseManejadoraHola} es invocado para procesar el evento. El mismo proceso se sigue para el otro botón.

\section{Más sobre eventos}

Un evento es un objeto creado desde la fuente de un evento. Disparar un evento significa crear un evento y delegarlo al manejador para que maneje el evento.

Al ejecutar una interfaz gráfica en Java, el programa interactúa con el usuario y los eventos conducen la ejecución. Esto se conoce como programación manejada por eventos (\textit{event-driven}). Un evento puede ser visto como una señal para el programa de que algo ha pasado. Los eventos son disparados por acciones externas del usuario, como movimientos del \textit{mouse}, \textit{clicks}, teclas presionadas. Un programa puede reaccionar o ignorar los eventos.

El componente que crea un evento y lo dispara es el objeto fuente u origen del evento. Un evento es una instancia de una clase de evento. La clase raíz de las clases evento en Java es $java.util.EventObject$. Pero la clase raíz de las clases de evento en JavaFX es $javafx.event.Event$, por lo que un evento en JavaFX es un objeto de esta clase o una de sus subclases. Algunas de las cuales se muestran a continuación:


\begin{itemize}
\item EventObject
  \begin{itemize}
    \item Event
    \begin{itemize}
        \item ActionEvent
        \item InputEvent
        \begin{itemize}
            \item MouseEvent
            \item KeyEvent
        \end{itemize}
        \item WindowEvent
    \end{itemize}
  \end{itemize}
\end{itemize}

Un objeto de evento contiene propiedades propias del tipo de evento que maneja. Un objeto de evento puede identificar su origen mediante el método $getSource()$. Como se puede ver, las subclases de evento tratan con específicos tipos de eventos.

\section{Registro de manejadores y manejo de eventos}


Un manejador es un objeto que debe ser registrado en el objeto fuente del evento, y debe ser una instancia de una interfaz apropiada de manejo de eventos.

Java usa un modelo basado en delegación para el manejo de eventos: un objeto fuente dispara un evento, y un objeto interesado en el evento lo maneja. Este último evento es llamado manejador de eventos (\textit{event handler}) o escuchador de eventos (\textit{event listener}). Para que un objeto sea un manejador de un evento para un objeto fuente se tiene que cumplir:

\begin{itemize}
    \item El objeto manejador debe ser una instancia de la correspondiente interfaz manejadora de evento, para asegurar que el manejador tiene el método correcto para procesar el evento. 
    \begin{itemize}
        \item JavaFX tiene definida una interfaz manejadora unificada \textit{EventHandler \textless T extends Event\textgreater} para un evento \textit{T}. 
        \item La interfaz manejadora contiene el método \textit{handle(T e)} para procesar el evento.
        \item  Por ejemplo, la interfaz manejadora para \textit{ActionEvent} es \textit{EventHandler \textless ActionEvent\textgreater}; cada manejador para  \textit{ActionEvent} debe implementar el método \textit{handle(ActionEvent e)} para procesar un \textit{ActionEvent}.
    \end{itemize}
    \item El objeto manejador debe ser registrado por el objeto fuente. Los métodos a registrar dependen del tipo de evento.
    \begin{itemize}
        \item Para \textit{ActionEvent} el método es $setOnAction()$.
        \item Para el evento de presionar una tecla, el método es $setOnKeyPressed()$.
        \item Para el evento del mouse presionado, el método es $setOnMousePressed()$.
    \end{itemize}
\end{itemize}

Vamos a ver ahora un \textcolor{blue}{ejemplo} donde dos botones controlan el tamaño de un círculo. Vemos el código primero sin manejo de eventos:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;

public class ControlDeCírculoAúnSinManejoDeEventos extends Application {
    @Override 
    public void start(Stage escenarioPrimario) {
        StackPane panel = new StackPane();
        Circle círculo = new Circle(50);
        círculo.setStroke(Color.BLACK);
        círculo.setFill(Color.WHITE);
        panel.getChildren().add(círculo);
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        Button btAumentar = new Button("Aumentar");
        Button btReducir = new Button("Reducir");
        hBox.getChildren().add(btAumentar);
        hBox.getChildren().add(btReducir);

        BorderPane borderPanel = new BorderPane();
        borderPanel.setCenter(panel);
        borderPanel.setBottom(hBox);
        BorderPane.setAlignment(hBox, Pos.CENTER);

        Scene escena = new Scene(borderPanel, 200, 150);
        escenarioPrimario.setTitle("ControlDeCírculo"); 
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
    }
}
\end{minted}
\caption{Ejemplo JavaFX dos botones sin manejo de eventos.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Para lograr las acciones deseadas vamos a introducir los siguientes cambios:

\begin{itemize}
\item Definir una clase \textit{PanelCírculo} para desplegar el círculo en un panel, proporcionando métodos para alagar y reducir modificando el radio del círculo.
\item Crear un objeto de \textit{PanelCírculo} y declarar un atributo que haga referencia a este objeto en la clase \textit{ControlDeCírculo}. Los métodos en esta clase ahora accesan al objeto de \textit{PanelCírculo} a través de este atributo.
\item Definir una clase manejadora \textit{AgrandarManejador} que implementa \textit{EventHandler \textless ActionEvent\textgreater}. Para hacer accesible la variable de referencia \textit{PanelCírculo} desde el método $handle()$, se define  \textit{AgrandarManejador} como una clase anidada de clase  \textit{ControlDeCírculo}.
\item Se registra el manejador para el botón \textit{btAgrandar} y se implementa el método $handle()$ en \textit{AgrandarManejador} para invocar \textit{panelCírculo.agrandar()}.
\item Para reducir se hacen pasos similares de creación y registro del manejador correspondiente y la creación de la clase manejadora implementando la interfaz \textit{EventHandler \textless ActionEvent \textgreater}.
\end{itemize}

El código de nuestro \textcolor{blue}{ejemplo} quedaría como sigue:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.HBox;
import javafx.scene.layout.BorderPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;

public class ControlDeCírculo extends Application {
    private PanelCírculo panelCírculo = new PanelCírculo();

    @Override 
    public void start(Stage escenarioPrimario) {
        
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        Button btAgrandar = new Button("Agrandar");
        Button btReducir = new Button("Reducir");
        hBox.getChildren().add(btAgrandar);
        hBox.getChildren().add(btReducir);
        
        // Crear y registrar el manejador para reducir
        btReducir.setOnAction(new ReducirManejador());
        // Crear y registrar el manejador para agrandar
        btAgrandar.setOnAction(new AgrandarManejador());
        
        BorderPane borderPanel = new BorderPane();
        borderPanel.setCenter(panelCírculo);
        borderPanel.setBottom(hBox);
        BorderPane.setAlignment(hBox, Pos.CENTER);

        // Crear una escena y colocarla en el escenario
        Scene escena = new Scene(borderPanel, 200, 150);
        escenarioPrimario.setTitle("ControlDeCírculo"); 
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
    }

    class AgrandarManejador implements EventHandler<ActionEvent> {

        @Override 
        public void handle(ActionEvent e) {
            panelCírculo.agrandar();
        }
    }
    
        class ReducirManejador implements EventHandler<ActionEvent> {

        @Override 
        public void handle(ActionEvent e) {
            panelCírculo.reducir();
        }
    }
}

class PanelCírculo extends StackPane {
    private Circle círculo = new Circle(50);

    public PanelCírculo() {
        getChildren().add(círculo);
        círculo.setStroke(Color.BLACK);
        círculo.setFill(Color.WHITE);
    }

    public void agrandar() {
        círculo.setRadius(círculo.getRadius() + 2);
    }

    public void reducir() {
        círculo.setRadius(círculo.getRadius() > 2 ?
            círculo.getRadius() - 2 : círculo.getRadius());
    }
}
\end{minted}
\caption{Ejemplo JavaFX dos botones con manejo de eventos.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Usando clases anónimas}

Las clases anónimas son una muy buena opción para implementar una interfaz que contiene algunos métodos, ya que estas clase generalmente solo requieren de una instancia y no es necesario nombrar la clase. Ejemplo\footnote{\href{https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html}{Anonymous classes}}:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
 
public class ClaseAnónimaEjemplo extends Application {
       
    @Override
    public void start(Stage escenarioPrimario) {
        escenarioPrimario.setTitle("¡Hola clases anónimas!");
        Button btn = new Button();
        btn.setText("Decir 'Hola'");
        
        //clase anónima dentro de setOnAction
        btn.setOnAction(new EventHandler<ActionEvent>() {
 
            @Override
            public void handle(ActionEvent event) {
                System.out.println("¡Hola!");
            }
        });
        
        StackPane raíz = new StackPane();
        raíz.getChildren().add(btn);
        escenarioPrimario.setScene(new Scene(raíz, 300, 250));
        escenarioPrimario.show();
    }
}
\end{minted}
\caption{Ejemplo Java FX manejador de eventos con clase anónimas.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Otro ejemplo, en este caso el programa usa una clase anónima donde redefine la implementación de clase \textit{TextField} para los métodos $replaceText()$ y $replaceSelection()$, creando un campo de texto que solo acepta valores numéricos:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Group; 
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class ClaseAnónimaTextFieldAdaptado extends Application {
    
    final static Label etiqueta = new Label();
 
    @Override
    public void start(Stage escenarioPrimario) {
        Group raíz = new Group();
        Scene escena = new Scene(raíz, 300, 150);
        escenarioPrimario.setScene(escena);
        escenarioPrimario.setTitle("Ejemplo de campo de texto");
 
        GridPane cuadrícula = new GridPane();
        // asigna las propiedades de relleno de espacio con un objeto de Insets
        cuadrícula.setPadding(new Insets(10, 10, 10, 10));
        cuadrícula.setVgap(5);
        cuadrícula.setHgap(5);
 
        escena.setRoot(cuadrícula);
        final Label dinero = new Label("$");
        GridPane.setConstraints(dinero, 0, 0);
        cuadrícula.getChildren().add(dinero);
        
        final TextField tfSum = new TextField() {
            @Override
            public void replaceText(int inicio, int fin, String texto) {
                if (!texto.matches("[a-z, A-Z]")) {
                    super.replaceText(inicio, fin, texto);                     
                }
                etiqueta.setText("Introduce un valor numérico");
            }
 
            @Override
            public void replaceSelection(String texto) {
                if (!texto.matches("[a-z, A-Z]")) {
                    super.replaceSelection(texto);
                }
            }
        };
 
        tfSum.setPromptText("Introduce el total");
        tfSum.setPrefColumnCount(10);
        GridPane.setConstraints(tfSum, 1, 0);
        cuadrícula.getChildren().add(tfSum);
        
        Button btEnviar = new Button("Enviar");
        GridPane.setConstraints(btEnviar, 2, 0);
        cuadrícula.getChildren().add(btEnviar);
        
        btEnviar.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent e) {
                etiqueta.setText(null);
            }
        });
        
        GridPane.setConstraints(etiqueta, 0, 1);
        GridPane.setColumnSpan(etiqueta, 3);
        cuadrícula.getChildren().add(etiqueta);
        
        escena.setRoot(cuadrícula);
        escenarioPrimario.show();
    }
 
}
\end{minted}
\caption{Ejemplo JavaFX con clases anónimas y uso de \textit{TextField}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Usando expresiones lambda}

Las expresiones lambda introducidad en Java 8 son una forma de simplificar más el código para el manejo de eventos. Veamos un ejemplo de implementación de un manejador con expresiones lambda:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.HBox;
import javafx.stage.Stage;

public class EjemploManejadorLambda extends Application {
    @Override
    public void start(Stage escenarioPrimario) {
        
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        Button btNuevo = new Button("Nuevo");
        Button btAbrir = new Button("Abrir");
        Button btGrabar = new Button("Grabar");
        Button btImprimir = new Button("Imprimir");
        hBox.getChildren().addAll(btNuevo, btAbrir, btGrabar, btImprimir);
        
        // Crear y registrar el manejador de cada butón con expresiones lambda
		// Notar las diferentes formas es expresiones lambda
        btNuevo.setOnAction((ActionEvent e) -> {
            System.out.println("Proceso Nuevo");
        });

        btAbrir.setOnAction((e) -> {
            System.out.println("Proceso Abrir");
        });

        btGrabar.setOnAction(e -> {
            System.out.println("Proceso Grabar");
        });

        btImprimir.setOnAction(e -> System.out.println("Proceso Imprimir"));

        Scene escena = new Scene(hBox, 300, 50);
        escenarioPrimario.setTitle("Ejemplo de Manejador con Expresiones Lambda");
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
    }
}
\end{minted}
\caption{Ejemplo JavaFX y manejador de eventos con expresiones lambda.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{\textcolor{blue}{Ejemplo} con evento de mouse}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class EjemploEventoMouse extends Application {
    @Override 
    public void start(Stage escenarioPrimario) {
        
        Pane panel = new Pane();
        Text texto = new Text(20, 20, "Presiona y arrastra un texto cualquiera");
        panel.getChildren().addAll(texto);

        texto.setOnMouseDragged(e -> {
            texto.setX(e.getX());
            texto.setY(e.getY());
        });
        
        Scene escena = new Scene(panel, 300, 100);
        escenarioPrimario.setTitle("Ejemplo de Evento de Mouse"); 
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
    }
}
\end{minted}
\caption{Ejemplo JavaFX con evento de mouse.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{\textcolor{blue}{Ejemplo} con evento de teclado}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class EjemploEventoTeclado extends Application {
    @Override 
    public void start(Stage escenarioPrimario) {
        
        Pane panel = new Pane();
        panel.setMinSize(300, 300);
        Text texto = new Text(20, 20, "A");
        panel.getChildren().add(texto);
        texto.setOnKeyPressed(e -> {
            switch (e.getCode()) {
            case DOWN: texto.setY(texto.getY() + 10); break;
            case UP: texto.setY(texto.getY() - 10); break;
            case LEFT: texto.setX(texto.getX() - 10); break;
            case RIGHT: texto.setX(texto.getX() + 10); break;
            default:
                if (Character.isLetterOrDigit(e.getText().charAt(0)))
                    texto.setText(e.getText());
            }
        });

        Scene escena = new Scene(panel);
        escenarioPrimario.setTitle("Ejemplo Evento Teclado"); 
        escenarioPrimario.setScene(escena);      
        escenarioPrimario.show(); 
        texto.requestFocus(); // texto se enfoca para recibir la entrada de teclado
    }
}
\end{minted}
\caption{Ejemplo JavaFX con evento de teclado.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{\textcolor{blue}{Ejemplo} con evento de teclado y mouse}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.application.Application;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.input.KeyCode;
import javafx.scene.input.MouseButton;
import javafx.scene.layout.HBox;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;

public class EjemploEventoTecladoMouse extends Application {
    private PanelCírculo panelCírculo = new PanelCírculo();
    
    @Override 
    public void start(Stage escenarioPrimario) {
        // mantener dos botones en un HBox
        HBox hBox = new HBox();
        hBox.setSpacing(10);
        hBox.setAlignment(Pos.CENTER);
        Button btAgrandar = new Button("Agrandar");
        Button btReducir = new Button("Reducir");
        hBox.getChildren().add(btAgrandar);
        hBox.getChildren().add(btReducir);
        
        // Crear y registrar manejadores
        btAgrandar.setOnAction(e -> panelCírculo.agrandar());
        btReducir.setOnAction(e -> panelCírculo.reducir());

        panelCírculo.setOnMouseClicked(e -> {
            if (e.getButton() == MouseButton.PRIMARY) {
                panelCírculo.agrandar();
            } else if (e.getButton() == MouseButton.SECONDARY) {
                panelCírculo.reducir();
            }
        });

        panelCírculo.setOnKeyPressed(e -> {
            if (e.getCode() == KeyCode.U) {
                panelCírculo.agrandar();
            } else if (e.getCode() == KeyCode.D) {
                panelCírculo.reducir();
            }
        });

        BorderPane panelBorde = new BorderPane();
        panelBorde.setCenter(panelCírculo);
        panelBorde.setBottom(hBox);
        BorderPane.setAlignment(hBox, Pos.CENTER);

        Scene escena = new Scene(panelBorde, 200, 150);
        escenarioPrimario.setTitle("EjemploEventoTecladoMouse"); 
        escenarioPrimario.setScene(escena); 
        escenarioPrimario.show(); 
        panelCírculo.requestFocus();
    }
}

// vista en ejemplo anterior
class PanelCírculo extends StackPane {
    private Circle círculo = new Circle(50);

    public PanelCírculo() {
        getChildren().add(círculo);
        círculo.setStroke(Color.BLACK);
        círculo.setFill(Color.WHITE);
    }

    public void agrandar() {
        círculo.setRadius(círculo.getRadius() + 2);
    }

    public void reducir() {
        círculo.setRadius(círculo.getRadius() > 2 ?
            círculo.getRadius() - 2 : círculo.getRadius());
    }
}
\end{minted}
\caption{Ejemplo JavaFX con evento de teclado y mouse.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{\textcolor{blue}{Ejemplo} con  listener en un objeto observable}

Es posible añadir un \textit{listener} para procesar un cambio en un valor en un objeto observable. Una instancia de \textit{Observable} es conocida como un \textbf{objeto observable}.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
import javafx.beans.InvalidationListener;
import javafx.beans.Observable;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;

public class EjemploPropiedadObservable {
    public static void main(String[] args) {
        DoubleProperty balance = new SimpleDoubleProperty();
        balance.addListener(new InvalidationListener() {
            @Override
            public void invalidated(Observable ov) {
                System.out.println("El nuevo valor es " + balance.doubleValue());
            }
        });
        balance.set(4.5);
    }
}
\end{minted}
\caption{Ejemplo JavaFX con un objeto observable.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%


%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft

%%%%%%%%%%
% PYTHON
%%%%%%%%%%
\ifpython
\newpage
\Chapter{Python  GUI (tkinter o PyQt5 -- android supported}



\fi
%%%%%%%%%%
% PYTHON_END
%%%%%%%%%%

\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%



%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\chapter{Programación en Red con Java}

Java, como un lenguaje de programación moderno, provee de clases para el manejo de información en red. De hecho, el uso de otras tecnologías como JDBC involucra el acceso a bases de datos locales y remotas de forma prácticamente transparente.

\section{Paquete \textit{java.net}}

Dentro del paquete \textit{java.net} se tienen un conjunto de clases que dan soporte a los diversos protocolos de comunicación de Internet, conocido como paquete de protocolos de Internet, dentro de los cuales se encuentran:

 
\begin{enumerate}
\item IP. \textit{Internet Protocol}.
\item TCP. \textit{Transmission Control Protocol}.
\item UDP. \textit{User Datagram Protocol}.
\end{enumerate}

La mayor parte de las aplicaciones están basadas en los protocolos TCP/IP, las cuales muchas veces hacen uso de otros protocolos intermediarios entre TCP/IP y la aplicación.

La tabla \ref{tab:protocolos} muestra una lista de protocolos de uso común en Internet.

% Please add the following required packages to your document preamble:
% \usepackage{graphicx}
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\caption{Protocolos comunes}
\label{tab:protocolos}
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\rowcolor[HTML]{C0C0C0} 
\multicolumn{1}{|c|}{\cellcolor[HTML]{C0C0C0}\textbf{Acrónimo}} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}\textbf{Nombre}} & \multicolumn{1}{c|}{\cellcolor[HTML]{C0C0C0}\textbf{Descripción}} \\ \hline
HTTP                                                            & \textit{HyperText Transport Protocol}                        & Protocolo de hipertexto. Es la base del World Wide Web.           \\ \hline
FTP                                                             & \textit{File Transfer,Protocol}                              & Protocolo de transferencia de archivos.                           \\ \hline
POP3                                                            & \textit{Post Office Protocol}                                & Protocolo que permite el acceso al correo electrónico.            \\ \hline
SMTP                                                            & \textit{Simple Mail Transfer Protocol}                       & Protocolo para transferencia de correo electrónico.               \\ \hline
NNTP                                                            & \textit{Network News Transfer Protocol}                      & Protocolo para grupos de noticias (news)                          \\ \hline
\end{tabular}%
}
\end{table}

El paquete \textit{java.net} cuenta hasta la versión 1.4 del jdk con 6 interfaces, 27 clases y 11 excepciones. Las clases más usadas son:

 
\begin{enumerate}
\item \textit{URL}. Representa un URL de Internet.
\item \textit{URLConnection}. Es un complemento de URL (no una subclase de ella). Cubre algunas operaciones más complejas.
\item \textit{Socket}. Establece conexiones TCP/IP.
\item \textit{DatagramPacket}. Establece conexiones de tipo UDP.
\item \textit{InetAddress}. Representa una dirección IP.
\end{enumerate}

\subsection{Clase \textit{URL}}

Esta clase permite crear instancias que almacenen direcciones de recursos en Internet\footnote{URL. \textit{Uniform Resource Locator}}. Este recurso puede ser un archivo, directorio, o inclusive una consulta a un motor de búsqueda. En caso de que el URL tenga una sintaxis incorrecta se lanza una excepción \textit{MalformedURLException}.

\ejemplo  %ACTUALIZAR

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Ejemplo de uso de URL
import java.applet.*;
import java.net.*;
import java.awt.*;

public class URLEjemplo extends Applet {

   URL utm = null;
 
   public void init()
     {

       try {
           utm = new URL("http://www.utm.mx");
         } 
       catch (MalformedURLException e)
         {
           System.out.println("Error:" + e.getMessage());
         }
     }

   public boolean mouseDown(Event evt, int x, int y)
     {
       getAppletContext().showDocument(utm);
       return(true);
     }
  }
\end{minted}
\caption{Ejemplo de clase URL.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Este programa detecta un \textit{click} del ratón sobre el área del \textit{applet} y como acción asociada despliega una página de html en el navegador\footnote{No se pruebe en el \textit{appletviewer} ya que este no despliega más que el \textit{applet} y no muestra la página html.}.

Este es sólo un ejemplo, pero la clase URL es usada por todos aquellos programas que requieran del uso de direcciones de recursos de Internet.

\subsection{Clase \textit{InetAddress}}

Como se mencionó antes, esta clase representar una dirección IP. La clase no maneja atributos ni constructores. Ofrece en cambio métodos de acceso para operaciones comunes de Internet.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//obtiene la dirección IP de la máquina local

import java.net.*;

public class ObtenIPLocal {

    public static void main(String args[]) {
        InetAddress IPLocal=null;

        try {
            IPLocal= InetAddress.getLocalHost();
        }catch (UnknownHostException e) {}

        System.out.println(IPLocal);
    }
}
\end{minted}
\caption{Ejemplo de \textit{InetAddress}, obtiene la dirección IP de la máquina local.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El programa anterior usa una instancia de \textit{InetAddress} para obtener la dirección de la máquina local mediante el método $getLocalHost()$ de la clase. Es un ejemplo muy simple del uso de la clase.

El siguiente programa  recibe como parámetro el nombre de un servidor y obtiene la dirección asociada a ese nombre.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//identifica la direccion IP asociada al host
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.lang.System;

public class NSLookupApp {
 public static void main(String args[]) {
  try {
   if(args.length!=1){
    System.out.println("Sintaxis: java NSLookupApp nombreServidor");
    return;
   }
   InetAddress host = InetAddress.getByName(args[0]);
   String hostName = host.getHostName();
   System.out.println("Nombre servidor: "+hostName);
   System.out.println("Direccion IP: "+host.getHostAddress());
  }catch(UnknownHostException ex) {
   System.out.println("Servidor desconocido");
   return;
  }
 }
}
\end{minted}
\caption{Ejemplo de \textit{InetAddress}, identifica la dirección IP asociada al \textit{host}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}
%\\
Ejecutando por ejemplo:

\mint[linenos=false]{bash}| \$java NSLookupApp www.utm.mx |


\subsection{Clase \textit{Socket}}

Esta clase se usa para la implementación de \textit{sockets} de cliente basados en una conexión.  La aplicación cliente debe comúnmente iniciar la conexión de \textit{sockets} hacia el servidor.

Una instancia de la clase \textit{Socket} es creada con el constructor recibiendo como parámetros por lo general el número IP o nombre de dominio del servidor y el puerto del servidor, creando una conexión a un puerto y \textit{host} de destino.

Un \textit{socket} se puede crear de la siguiente forma:

\mint[linenos=false]{java}| miSocket = new Socket ("mixteco.utm.mx", 1111); |

Esta línea de código tiene que estar dentro de un segmento \textit{try} para recibir una excepción en caso de que se produzca. 

Algunos métodos importantes de la clase \textit{Socket}:

\begin{itemize}
\item \textit{getInetAddress()}.  Obtiene la dirección IP del servidor destino.
\item \textit{getPort()}. Obtiene el puerto del servidor destino.
\item \textit{getLocalAddress()}. Obtiene la dirección IP local.
\item \textit{getLocalPort()}. Obtiene el número de puerto local.
\item \textit{getInputStream()}. Para acceder a los flujos de entrada.
\item \textit{getOutputStream()}. Para acceder a los flujos de salida.
\item \textit{close()}. Cerrar el socket cliente.
\end{itemize}

\subsection{Clase ServerSocket}

Esta clase implementa un \textit{socket} del servidor TCP. Una instancia de la clase recibe comúnmente el número de puerto por el cual va a \textbf{escuchar} las solicitudes de conexión del cliente.

Dentro de código para manejo de excepciones se declara un \textit{socket} servidor de la siguiente forma:

\mint[linenos=false]{java}| miServidor = new ServerSocket(1111); |

Algunos métodos importantes de la clase \textit{ServerSocket}:


\begin{itemize}
\item \textit{accept()}. Hace que el \textit{socket} servidor escuche y espere hasta que se establezca una conexión entrante.
\item \textit{getSoTimeout()}. Devuelve el tiempo que va a estar bloqueado el \textit{socket} con respecto a una llamada al método \textit{accept()}.
\item \textit{setSoTimeout()}. Modifica el tiempo de bloqueo del \textit{socket}.
\item \textit{close()}. Cierra el \textit{socket} servidor.
\end{itemize}

Veamos ahora un ejemplo con una clase cliente y otra clase servidor. Este programa aprovecha las características de multihilos de Java creando un hilo cliente y otro servidor.

\ejemplo %ACTUALIZAR

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Programa cliente servidor con sockets
import java.awt.*;
import java.net.*;
import java.io.*;

class hiloCliente extends Thread {

   DataInputStream dis = null;
   Socket s = null;

   public hiloCliente() {
        try {
           //se crea socket con dirección de máquina local
           s = new Socket("127.0.0.1", 2525);
           dis = new DataInputStream(s.getInputStream());
        } 
        catch (IOException e)
        {
            System.out.println("Error: " + e);
        }
   }

   public void run()
   {
       while (true)
       {
            try {
               String mensaje = dis.readLine();
               if (mensaje == null)
                 break;
               System.out.println(mensaje);
           } 
           catch (IOException e)
           {
               System.out.println("Error: " + e);
           }
       }
   }
}

public class clienteYServidor extends Frame {
   static ServerSocket servidor = null;

   public boolean handleEvent (Event evt)
   {
       if (evt.id == Event.WINDOW_DESTROY)
       {
           System.exit(0);
       }
       return super.handleEvent (evt);
   }

   public boolean mouseDown(Event evt, int x, int y)
   {
       new hiloCliente().start(); // Iniciar el hilo cliente
       return(true);
   }

   public static void main(String args[])
   {
      clienteYServidor f = new clienteYServidor();
      f.resize (200, 200);
      f.show();
      try {
            //genera el socket servidor
          servidor = new ServerSocket(2525);
      } 
      catch (IOException e)
      {
          System.out.println("Error: " + e);
      }
      while (true)
      {
          Socket s = null;
          try {
              s = servidor.accept();
          } 
          catch (IOException e)
          {
              System.out.println("Error: " + e);
          }

          try {
            PrintStream ps = new  PrintStream(s.getOutputStream());
            ps.println("Hola, Mundo");
            ps.flush();
            s.close();
          } 
          catch (IOException e)
          {
             System.out.println("Error: " + e);
          }
      }
  }
}
\end{minted}
\caption{Ejemplo de programa cliente servidor con sockets .}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El programa muestra a un hilo cliente solicitando una cadena de un flujo de datos al servidor: cada vez que se da \textit{click} sobre la ventana el servidor inicia a un hilo cliente que a su vez se comunica con el servidor.

En el \textbf{sección complementaria uno }se muestra otro ejemplo de uso de la clase \textit{Socket} para crear un cliente y en la \textbf{sección complementaria dos} se muestra el código correspondiente al servidor. Estos programas se comunican entre sí: el cliente es capaz de enviar una cadena y recibirla de vuelta modificada por el servidor. Cada uno corre de manera independiente e idealmente debería ser probado en distintas máquinas en red.

Ejemplo de ejecución del \textbf{cliente}:

\begin{minted}{bash}
$ java PortTalkApp yodocono.utm.mx 1234
Conectando a: yodocono.utm.mx puerto 1234.
servidor destino yodocono.utm.mx.
IP servidor destino 192.100.170.5.
numero de puerto servidor destino 1234.
servidor Local iec23.
IP servidor Local 192.100.170.33.
numero de puerto servidor Local 2162.
Enviar, recibir, o salir (E/R/S): e
Hola yodocono
Enviar, recibir, o salir (E/R/S): r
***onocodoy aloH
\end{minted}

Ejemplo de ejecución del \textbf{servidor}:

\begin{minted}{bash}
$ java ReverServerApp
Servidor escuchando en puerto: 1234.
Aceptando conexion a iec23.utm.mx en puerto 2162.
Recibido: Hola yodocono
Enviado: onocodoy aloH
\end{minted}


\subsection{Clase \textit{DatagramSocket}}

Esta clase es el punto de entrada de todas las acciones sobre datagramas UDP\footnote{UDP es un protocolo que carece de conexión y que permite que los programas de aplicación intercambien información por medio de trozos de información a los que se conoce datagramas.}. Sería el equivalente a la clase \textit{Socket} y \textit{ServerSocket} para el protocolo TCP, ya que implementa los \textit{sockets} cliente y servidor.

	Principales métodos\footnote{Algunos métodos importantes no se mencionan porque son comunes a los proporcionados por otras clases con anterioridad.} de la clase \textit{DatagramSocket}:


\begin{itemize}
\item \textit{send()}. Enviar un datagrama a través del \textit{socket}.
\item \textit{receive()}. Recibir un datagrama a través del \textit{socket}.
\item \textit{close()}. Cerrar el \textit{socket}.
\end{itemize}

\subsection{Clase \textit{DatagramPacket}}

Esta clase representa un paquete de datos recibido o enviado mediante un \textit{socket} a través del protocolo UDP. Se le considera una clase de bajo nivel que sólo resulta útil para aplicaciones que deben leer o escribir datos según un formato específico, pero que no necesitan garantizar la integridad de la llamada.

Cada datagrama es enviado de una máquina a otra a partir de la información del paquete. Si un conjunto de paquetes son enviados hacia una máquina estos podrían ser enviados por caminos distintos y tener un orden de llegada distinto.

A continuación se muestra la salida generada por dos programas que se detallan en las \textbf{secciones complementarias tres y cuatro}. El programa \textit{TimeServerApp} esta a la espera de solicitudes de \textbf{tiempo} o \textbf{salida} y de acuerdo a estas solicitudes enviará al cliente la fecha y hora o provocará la finalización del servidor. 

Ejemplo de ejecución de \textit{TimeServerApp}:

\begin{minted}{bash}
$ java TimeServerApp
iec23: TimeServer escuchando el puerto 2345.

Recibiendo un datagrama desde iec23.utm.mx puerto 1188.
Contenido del datagrama: tiempo
Enviando: Fri Jun 02 17:20:58 GMT-05:00 2000 a iec23.utm.mx al puerto 1188.

Recibiendo un datagrama desde iec23.utm.mx puerto 1188.
Contenido del datagrama: tiempo
Enviando: Fri Jun 02 17:20:59 GMT-05:00 2000 a iec23.utm.mx al puerto 1188.

Recibiendo un datagrama desde iec23.utm.mx puerto 1188.
Contenido del datagrama: tiempo
Enviando: Fri Jun 02 17:20:59 GMT-05:00 2000 a iec23.utm.mx al puerto 1188.

Recibiendo un datagrama desde iec23.utm.mx puerto 1188.
Contenido del datagrama: tiempo
Enviando: Fri Jun 02 17:20:59 GMT-05:00 2000 a iec23.utm.mx al puerto 1188.

Recibiendo un datagrama desde iec23.utm.mx puerto 1188.
Contenido del datagrama: tiempo
Enviando: Fri Jun 02 17:20:59 GMT-05:00 2000 a iec23.utm.mx al puerto 1188.

Recibiendo un datagrama desde iec23.utm.mx puerto 1188.
Contenido del datagrama: salida
Enviando: Fri Jun 02 17:21:00 GMT-05:00 2000 a iec23.utm.mx al puerto 1188.
\end{minted}

Por su parte, el programa \textit{GetTimeApp} envía cinco solicitudes de "tiempo"  y una de "salida" al servidor.

Ejemplo de ejecución de \textit{GetTimeApp}:

\begin{minted}{java}
$ java GetTimeApp

Envia peticion de tiempo a iec23 al puerto 2345.
Recibiendo un datagrama desde iec23.utm.mx at port 2345.
El datagrama contiene los sig. datos: Fri Jun 02 17:20:58 GMT-05:00 2000

Envia peticion de tiempo a iec23 al puerto 2345.
Recibiendo un datagrama desde iec23.utm.mx at port 2345.
El datagrama contiene los sig. datos: Fri Jun 02 17:20:59 GMT-05:00 2000

Envia peticion de tiempo a iec23 al puerto 2345.
Recibiendo un datagrama desde iec23.utm.mx at port 2345.
El datagrama contiene los sig. datos: Fri Jun 02 17:20:59 GMT-05:00 2000

Envia peticion de tiempo a iec23 al puerto 2345.
Recibiendo un datagrama desde iec23.utm.mx at port 2345.
El datagrama contiene los sig. datos: Fri Jun 02 17:20:59 GMT-05:00 2000

Envia peticion de tiempo a iec23 al puerto 2345.
Recibiendo un datagrama desde iec23.utm.mx at port 2345.
El datagrama contiene los sig. datos: Fri Jun 02 17:20:59 GMT-05:00 2000
\end{minted}

En este ejemplo se asume el funcionamiento en una sola máquina pues se toma la dirección de la máquina local, pero modificarlo para probarlo en máquinas distintas no debe ser problema.

\section{Complemento 1. \textit{PortTalkApp}}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Ejemplo de uso de la clase Socket
import java.lang.System;
import java.net.Socket;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.io.*;

public class PortTalkApp {
 public static void main(String args[]){
  PortTalk portTalk = new PortTalk(args);
  portTalk.displayDestinationParameters();
  portTalk.displayLocalParameters();
  portTalk.chat();
  portTalk.shutdown();
 }
}

class PortTalk {
 Socket connection;
 DataOutputStream outStream;
 BufferedReader inStream;
 public PortTalk(String args[]){
  if(args.length!=2) error("Sintaxis: java PortTalkApp <servidor> <puerto>");
  String destination = args[0];
  int port = 0;
  try {
   port = Integer.valueOf(args[1]).intValue();
  }catch (NumberFormatException ex){
   error("N£mero de puerto inv lido");
  }
  try{
   connection = new Socket(destination,port);
  }catch (UnknownHostException ex){
   error("Servidor desconocido");
  }
  catch (IOException ex){
   error("Error E/S: al crear el socket");
  }
  try{
   inStream = new BufferedReader(
    new InputStreamReader(connection.getInputStream()));
   outStream = new DataOutputStream(connection.getOutputStream());
  }catch (IOException ex){
   error("Error E/S: obteniendo el flujo");
  }
  System.out.println("Conectando a: "+destination+" puerto "+port+".");
 }
 public void displayDestinationParameters(){
  InetAddress destAddress = connection.getInetAddress();
  String name = destAddress.getHostName();
  byte ipAddress[] = destAddress.getAddress();
  int port = connection.getPort();
  displayParameters("servidor destino ",name,ipAddress,port);
 }
 public void displayLocalParameters(){
  InetAddress localAddress = null;
  try{
   localAddress = InetAddress.getLocalHost();
  }catch (UnknownHostException ex){
   error("Error obteniendo informaci¢n de servidor local");
  }
  String name = localAddress.getHostName();
  byte ipAddress[] = localAddress.getAddress();
  int port = connection.getLocalPort();
  displayParameters("servidor Local ",name,ipAddress,port);
 }
 public void displayParameters(String s,String name,byte ipAddress[],int port){
  System.out.println(s+name+".");
  System.out.print("IP "+s);
  for(int i=0;i<ipAddress.length;++i)
   System.out.print((ipAddress[i]+256)%256+".");
  System.out.println();
  System.out.println("numero de puerto "+s+port+".");
 }
 public void chat(){
  BufferedReader keyboardInput = new BufferedReader(
   new InputStreamReader(System.in));
  boolean finished = false;
  do {
   try{
    System.out.print("Enviar, recibir, o salir (E/R/S): ");
    System.out.flush();
    String line = keyboardInput.readLine();
    if(line.length()>0){
     line=line.toUpperCase();
     switch (line.charAt(0)){
     case 'E':
      String sendLine = keyboardInput.readLine();
      outStream.writeBytes(sendLine);
      outStream.write(13);
      outStream.write(10);
      outStream.flush();
      break;
     case 'R':
      int inByte;
      System.out.print("***");
      while ((inByte = inStream.read()) != '\n')
      System.out.write(inByte);
      System.out.println();
      break;
     case 'S':
      finished=true;
      break;
     default:
      break;
     }
    }
   }catch (IOException ex){
    error("Error leyendo del teclado o socket");
   }
  } while(!finished);
 }
 public void shutdown(){
  try{
   connection.close();
  }catch (IOException ex){
   error("Error e/S cerrando socket");
  }
 }
 public void error(String s){
  System.out.println(s);
  System.exit(1);
 }
}
\end{minted}
\caption{Ejemplo de uso de la clase Socket. \textit{PortTalkApp}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Complemento 2. \textit{ServerSocket}}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//ejemplo de uso de la clase ServerSocket
import java.lang.System;
import java.net.ServerSocket;
import java.net.Socket;
import java.io.*;

public class ReverServerApp {
 public static void main(String args[]){
  try{
   ServerSocket server = new ServerSocket(1234);
   int localPort = server.getLocalPort();
   System.out.println("Servidor escuchando en puerto: "+localPort+".");
   Socket client = server.accept();
   String destName = client.getInetAddress().getHostName();
   int destPort = client.getPort();
   System.out.println("Aceptando conexion a "+destName+" en puerto "+
    destPort+".");
   BufferedReader inStream = new BufferedReader(
    new InputStreamReader(client.getInputStream()));
   DataOutputStream outStream = new DataOutputStream(client.getOutputStream());
   boolean finished = false;
   do {
    String inLine = inStream.readLine();
    System.out.println("Recibido: "+inLine);
    if(inLine.equalsIgnoreCase("salir")) finished=true;
    String outLine=new ReverseString(inLine.trim()).getString();
    for(int i=0;i<outLine.length();++i)
     outStream.write((byte)outLine.charAt(i));
    outStream.write(13);
    outStream.write(10);
    outStream.flush();
    System.out.println("Enviado: "+outLine);
   } while(!finished);
   inStream.close();
   outStream.close();
   client.close();
   server.close();
  }catch (IOException ex){
   System.out.println("excepcion: IOException .");
  }
 }
}
class ReverseString {
 String s;
 public ReverseString(String in){
  int len = in.length();
  char outChars[] = new char[len];
  for(int i=0;i<len;++i)
   outChars[len-1-i]=in.charAt(i);
  s = String.valueOf(outChars);
 }
 public String getString(){
  return s;
 }
}
\end{minted}
\caption{Ejemplo de uso de la clase \textit{ServerSocket}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}


\section{Complemento 3. \textit{TimeServerApp}}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//ejemplo de escucha de un socket UDP
import java.lang.System;
import java.net.DatagramSocket;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.io.IOException;
import java.util.Date;

public class TimeServerApp {
 public static void main(String args[]){
  try{
   DatagramSocket socket = new DatagramSocket(2345);
   String localAddress = InetAddress.getLocalHost().getHostName().trim();
   int localPort = socket.getLocalPort();
   System.out.print(localAddress+": ");
   System.out.println("TimeServer escuchando el puerto "+localPort+".");
   int bufferLength = 256;
   byte outBuffer[];
   byte inBuffer[] = new byte[bufferLength];
   DatagramPacket outDatagram;
   DatagramPacket inDatagram = new DatagramPacket(inBuffer,inBuffer.length);
   boolean finished = false;
   do {
    socket.receive(inDatagram);
    InetAddress destAddress = inDatagram.getAddress();
    String destHost = destAddress.getHostName().trim();
    int destPort = inDatagram.getPort();
    System.out.println("\nRecibiendo un datagrama desde "+destHost+" puerto "+
     destPort+".");
    String data = new String(inDatagram.getData()).trim();
    System.out.println("Contenido del datagrama: "+data);
    if(data.equalsIgnoreCase("salida")) finished=true;
    String time = new Date().toString();
    outBuffer=time.getBytes();
    outDatagram = new DatagramPacket(outBuffer,outBuffer.length,destAddress,
     destPort);
    socket.send(outDatagram);
    System.out.println("Enviando: "+time+" a "+destHost+" al puerto "+destPort+".");
   } while(!finished);
  }catch (IOException ex){
   System.out.println("Excepcion: IOException");
  }
 }
}

\end{minted}
\caption{Ejemplo de escucha de un socket UDP. \textit{TimeServerApp}}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\section{Complemento 4. \textit{GetTimeApp}}

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//ejemplo de uso de datagramas
import java.lang.System;
import java.net.DatagramSocket;
import java.net.DatagramPacket;
import java.net.InetAddress;
import java.io.IOException;

public class GetTimeApp {
 public static void main(String args[]){
  try{
   DatagramSocket socket = new DatagramSocket();
   InetAddress localAddress = InetAddress.getLocalHost();
   String localHost = localAddress.getHostName();
   int bufferLength = 256;
   byte outBuffer[];
   byte inBuffer[] = new byte[bufferLength];
   DatagramPacket outDatagram;
   DatagramPacket inDatagram = new DatagramPacket(inBuffer,inBuffer.length);
   for(int i=0;i<5;++i){
    outBuffer = new byte[bufferLength];
    outBuffer = "tiempo".getBytes();
    outDatagram = new DatagramPacket(outBuffer,outBuffer.length,
     localAddress,2345);
    socket.send(outDatagram);
    System.out.println("\nEnvia peticion de tiempo a "+localHost+" al puerto 2345.");
    socket.receive(inDatagram);
    InetAddress destAddress = inDatagram.getAddress();
    String destHost = destAddress.getHostName().trim();
    int destPort = inDatagram.getPort();
    System.out.println("Recibiendo un datagrama desde "+destHost+" at port "+
     destPort+".");
    String data = new String(inDatagram.getData());
    data=data.trim();
    System.out.println("El datagrama contiene los sig. datos: "+data);
   }
   outBuffer = new byte[bufferLength];
   outBuffer = "salida".getBytes();
   outDatagram = new DatagramPacket(outBuffer,outBuffer.length,
    localAddress,2345);
   socket.send(outDatagram);
  }catch (IOException ex){
   System.out.println("excepci¢n: IOException");
  }
 }
}
\end{minted}
\caption{Ejemplo de uso de datagramas. \textit{GetTimeApp}.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

% TABLA con más de una línea 
\begin{center}
\begin{tabular}{|m{\textwidth}| }
 \hline 
\rowcolor{gray!50} 
\begin{center}
\textbf{Ejercicios sugeridos} 
\end{center} 
\\ \hline

\begin{itemize}
\item      • ¿Qué pasa si al programa \textit{ReverServerApp} se tratan de conectar dos o más clientes? Proponga e implemente una solución para recibir más de un cliente. 
\item     • Modifique el ejemplo de uso de datagramas para poder conectarse desde cualquier máquina en la red al servidor \textit{TimeServerApp}.
\end{itemize}

\\ \hline
\end{tabular}
\end{center}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%



%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\chapter{Programación en Red con Java (2)}

Una vez analizados los conceptos básicos de programación en red en el material pasa
do,  revisaremos unas clases complementarias y veremos algunos ejemplos de aplicaciones cliente/servidor.

\section{Clases \textit{URL}}


	En el documento anterior se han revisado varias clases para la comunicación en red a través de TCP y de UDP. Sin embargo, Java proporciona otras clases de alto nivel y se encuentran organizadas alrededor de la clase URL.

	Existen varias clases para el manejo de URL además de la propia clase URL vista anteriormente.


\begin{enumerate}
\item \textit{URLConnection}. Es una clase abstracta, ofrece una conexión activa a un recurso representado en una instancia de URL. Tiene como subclases a  \textit{HttpURLConnection} y \textit{JarURLConnection}. Proporciona la funcionalidad básica para que las instancias de sus subclases puedan leer o escribir del recurso apuntado por un URL.
\item \textit{HttpURLConnection}. Extiende la clase \textit{URLConnection}. Una instancia de esta clase permite la conexión a un servidor http.
\item \textit{JarURLConnection}. Es usada para hacer referencia a un archivo jar o a un recurso contenido dentro de un archivo jar. La conexión sigue siendo bajo http. Sintaxis general:

$jar:<url>!/{entry}$

\item \textit{URLEncoder}. Esta clase contiene un método estático para convertir una cadena en formato \textit{x-www-form-urlencoded}\footnote{Este formato es posible apreciarlo en el uso de CGI's; donde por ejemplo, un espacio es representado con el símbolo +.}.
\item \textit{URLDecoder}. Al contrario de la clase anterior, una instancia de esta clase convierte del formato \textit{x-www-form-urlencoded} a cadena.
\end{enumerate}

\section{Cliente / Servidor}

Mucho se ha hablado de la tecnología cliente / servidor y como ésta es lograda en diferentes niveles. Por ejemplo, el uso de la JDBC es una arquitectura de este estilo donde la aplicación carga con las capas de manipulación y presentación de datos y el manejador de la base de datos obviamente tiene la responsabilidad del almacenamiento. Con la programación en red nosotros podemos realizar aplicaciones cliente y aplicaciones servidor, donde dependiendo de nuestras necesidades podamos proponer inclusive el movimiento de estas capas como se mencionaba en el curso propedéutico de introducción a la tecnología de objetos.

	Retomando la JDBC, uno de los problemas del acceso usando el puente JDBC-ODBC es que debe estar configurado el acceso a la base de datos en cada máquina, lo que no es recomendable para cierto tipo de aplicaciones. Si no se tiene otra forma de acceder a la base de datos es posible hacer un cliente que solo se encargue de recibir la información y presentarla, y una aplicación del lado del servidor que acceda a la base de datos a través de JDBC-ODBC y envié la información a través de conexiones de \textit{sockets}.

De una manera más formal, un cliente y servidor se definen como sigue:

\textbf{Cliente}. Un cliente es una aplicación que realiza un servicio al usuario  apoyado en tareas realizadas por un servidor, a través de solicitudes de servicio. Se asume que por lo general el cliente es quien contacta al servidor para realizar la conexión.

\textbf{Servidor}. Un servidor por su parte es una aplicación que se encuentra a la espera de conexiones de clientes a través de un puerto asociado a su servicio. Un servidor debe generar un hilo por cada cliente que se encuentre solicitando un servicio.

\subsection{Programas cliente}

Se muestran a continuación ejemplos de programas cliente básicos.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Programa que almacena páginas html
import java.util.Vector;
import java.io.*;
import java.net.*;

public class CapturaHtmlApp {
 public static void main(String args[]){
  CapturaHtml captu = new CapturaHtml();
  captu.run();
 }
}

class CapturaHtml {
 String urlList = "urlList.txt";
 Vector URLs = new Vector();
 Vector fileNames = new Vector();
 public CapturaHtml() {
  super();
 }
 public void getURLList() {
  try {
   BufferedReader inStream = new BufferedReader(new FileReader(urlList));
   String inLine;
   while((inLine = inStream.readLine()) != null) {
    inLine = inLine.trim();
    if(!inLine.equals("")) {
     int tabPos = inLine.lastIndexOf('\t');
     String url = inLine.substring(0,tabPos).trim();
     String fileName = inLine.substring(tabPos+1).trim();
     URLs.addElement(url);
     fileNames.addElement(fileName);
    }
   }
  }catch(IOException ex){
   error("Error leyendo "+urlList);
  }
 }
 public void run() {
  getURLList();
  int numURLs = URLs.size();
  for(int i=0;i<numURLs;++i)
   captuURL((String) URLs.elementAt(i),(String) fileNames.elementAt(i));
  System.out.println("Ok.");
 }
 public void captuURL(String urlName,String fileName) {
  try{
   URL url = new URL(urlName);
   System.out.println("Obteniendo "+urlName+"...");
   File outFile = new File(fileName);
   PrintWriter outStream = new PrintWriter(new FileWriter(outFile));
   BufferedReader inStream = new BufferedReader(
    new InputStreamReader(url.openStream()));
   String line;
   while ((line = inStream.readLine())!= null) outStream.println(line);
   inStream.close();
   outStream.close();
  }catch (MalformedURLException ex){
   System.out.println("MalformedURLException");
  }catch (IOException ex){
   System.out.println("IOException");
  }
 }
 public void error(String s){
  System.out.println(s);
  System.exit(1);
 }
}
\end{minted}
\caption{Ejemplo que almacena páginas html.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Este programa toma un archivo urlList.txt para obtener una lista de direcciones de Web y almacenar localmente los archivos html resultantes, obtenidos de los servidores correspondientes. El archivo de direcciones puede ser:
\begin{alltt}
http://www.utm.mx   utm.htm 
http://virtual.utm.mx   virtual.htm
\end{alltt}

donde la dirección se encuentra separada del nombre del archivo local por un carácter de tabulación.

En el siguiente programa podemos ver a un cliente de SMTP para envío de correo, el cual manda un correo electrónico de prueba conectándose a un servidor SMTP.  Para que se ejecute correctamente es necesario ajustar las cuentas de origen y destino, así como el nombre de dominio del servidor de SMTP.

Es posible que este programa no funcione con algunos servidores. Una de las razones puede ser por cuestiones de seguridad, ya que fácilmente se podría mandar un mensaje aparentando un remitente que no nos pertenece pues, como es posible apreciar, en el código no hay ninguna medida de seguridad de para comprobar nuestra identidad. Sin embargo muchos servidores SMTP no están activados para verificar la identidad del cliente\footnote{ El código muestra servidores de ejemplo. En la fecha de prueba de este programa dicho servidor no verificaba la identidad del cliente pero esto pudo haber cambiado a la fecha. }.

\ejemplo
%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Ejemplo de  cliente de SMTP
import java.io.*;
import java.net.*;

public class CorreoJava {
   static PrintStream ps = null;       // envío de mensajes
   static BufferedReader dis =null; 
              

   public static void enviar(String str) throws IOException
     {
       ps.println(str); // enviar una cadena SMTP
       ps.flush();      // vaciar la cadena

       System.out.println("Java envió: " + str);
     }

   public static void recibir() throws IOException
     {
       String readstr = dis.readLine(); // obtener la respuesta SMTP
       System.out.println("respuesta SMTP: " + readstr);
     }

   public static void main (String args[])
     {
       String HELO = "HELO ";
       String MAIL_FROM = "MAIL FROM: miCuenta@mixteco.utm.mx ";
       String RCPT_TO = "RCPT TO: destino@nuyoo.utm.mx ";
       String DATA = "DATA"; // inicio del mensage
       String ASUNTO = "Subject: Prueba Java\n";

       // Nota: "\n.\n" indica el final el mensaje 
       String MENSAJE = "Cadena de mensaje\n.\n";
 
       Socket smtp = null;   // socket de SMTP
       
       try {  // Nota: 25 es el número de puerto SMTP por omisión
           smtp = new Socket("mixteco.utm.mx", 25);
           OutputStream os = smtp.getOutputStream();
           ps = new PrintStream(os);
           InputStream is = smtp.getInputStream();
           dis= new BufferedReader(new InputStreamReader(is));
         }  
       catch (IOException e)
         {
           System.out.println("Error al conectar: " + e);
         }

       try {      
           String loc = InetAddress.getLocalHost().getHostName();
           enviar(HELO + loc);
           recibir();           // obtener la respuesta SMTP
           enviar(MAIL_FROM);   // enviar el remitente
           recibir();
           enviar(RCPT_TO);     // enviar el receptor
           recibir();
           enviar(DATA);        // enviar el inicio de mensaje
           recibir();
           enviar(ASUNTO); 
           recibir();
           enviar(MENSAJE); 
           recibir();
           smtp.close();
         } 
       catch (IOException e)
         {
           System.out.println("Error al enviar:" + e);
         }
      
       System.out.println("Correo enviado!");
    }
}
\end{minted}
\caption{Ejemplo de cliente SMTP.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

Un ejemplo muy claro de una aplicación cliente/servidor mediante sockets es la del juego de gato presentada por Deitel \cite{deitel2012c}, donde el servidor está a la espera de que se conecten dos clientes jugadores de gato. Se muestra a continuación el lado del cliente.

\ejemplo  %ACTUALIZAR

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// Cliente de TicTacToe 
import java.applet.Applet;
import java.awt.*;
import java.net.*;
import java.io.*;

public class TicTacToeClient extends Applet
                             implements Runnable {
   TextField id;
   TextArea display;
   Panel boardPanel, panel2;
   Square board[][], currentSquare;
   Socket connection;
   DataInputStream input;
   DataOutputStream output;
   Thread outputThread;
   char myMark;


   public void init()
   {
      setLayout( new BorderLayout() );
      display = new TextArea( 4, 30 );
      display.setEditable( false );
      add( "South", display );

      boardPanel = new Panel();
      boardPanel.setLayout( new GridLayout( 3, 3, 0, 0 ) );
      board = new Square[ 3 ][ 3 ];

      for ( int row = 0; row < board.length; row++ )
         for (int col = 0; col < board[row].length; col++ ) {
            board[ row ][ col ] = new Square();
            boardPanel.add( board[ row ][ col ] );
         }
      id = new TextField();
      id.setEditable( false );
      add( "North", id );

      panel2 = new Panel();
      panel2.add( boardPanel );
      add( "Center", panel2 );
   }

   public void start()
   {
      try {
         connection =
            new Socket( InetAddress.getLocalHost(), 5000 );
         input = new DataInputStream(
            connection.getInputStream() );
         output = new DataOutputStream(
            connection.getOutputStream() );
      }
      catch ( IOException e ) {
         e.printStackTrace();         
      }

      outputThread = new Thread( this );
      outputThread.start();
   }

   public boolean mouseUp( Event e, int x, int y )
   {      
      for ( int row = 0; row < board.length; row++ ) {
         for (int col = 0; col < board[row].length; col++ ) {
            try {
               if ( e.target == board[ row ][ col ] ) {
                  currentSquare = board[ row ][ col ];
                  output.writeInt( row * 3 + col );
               }
            }
            catch ( IOException ie ) {
                  ie.printStackTrace();         
            }
         }
      }
      return true;
   }

   public void run()
   {
      try {
         myMark = input.readChar();
         id.setText( "Eres el jugador \"" + myMark + "\"" );
      }
      catch ( IOException e ) {
         e.printStackTrace();         
      }

      // Recibir mensajes
      while ( true ) {
         try {
            String s = input.readUTF();
            processMessage( s );
         }
         catch ( IOException e ) {
            e.printStackTrace();         
         }
      }
   }


   public void processMessage( String s )
   {
      if ( s.equals( "Movida valida." ) ) {
         display.appendText( "Movida valida, espere un momento.\n" );
         currentSquare.setMark( myMark );
         currentSquare.repaint();
      }
      else if ( s.equals( "Movida invalida, intente de nuevo" ) ) {
         display.appendText( s + "\n" );
      }
      else if ( s.equals( "El oponente movio" ) ) {
         try {
            int loc = input.readInt();
   
            done:
            for ( int row = 0; row < board.length; row++ )
               for ( int col = 0;
                     col < board[ row ].length; col++ )
                  if ( row * 3 + col == loc ) {
                     board[ row ][ col ].setMark(
                        ( myMark == 'X' ? 'O' : 'X' ) );
                     board[ row ][ col ].repaint();
                     break done;
                  }
            display.appendText(
               "El oponente movio. Es tu turno.\n" );
         }
         catch ( IOException e ) {
            e.printStackTrace();         
         }
      }
      else {
         display.appendText( s + "\n" );
      }
   }
}

class Square extends Canvas {
   char mark;

   public Square()
   {
      resize ( 30, 30 );
   }

   public void setMark( char c ) { mark = c; }

   public void paint( Graphics g )
   {
      g.drawRect( 0, 0, 29, 29 );
      g.drawString( String.valueOf( mark ), 11, 20 );
   }
}
\end{minted}
\caption{Ejemplo - Cliente de TicTacToe.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\subsection{Programas servidor}

Veremos ahora algunos ejemplos de programas servidores, recordando que ya se ha mencionado la importancia de que estos sean capaces de soportar la conexión de varios clientes al mismo tiempo, por lo que es relevante el manejo de programación concurrente.

Inicialmente veamos el código de un servidor genérico, este no hace nada en particular, únicamente se muestra como un ejemplo de los aspectos generales de los servidores en Java.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
//Ejemplo de un servidor genérico multihilado
import java.net.*;
import java.io.*;
import java.util.*;

public class GenericServer {
    // 1234 puede ser cualquier número de puerto que se determine
    int serverPort = 1234; 
    public static void main(String args[]){
        //crear un objeto de servidor y ejecutarlo
        GenericServer server = new GenericServer();
        server.run();
    }
    public GenericServer() {
        super();
    }
    public void run() {
        try {
            //crear un socket servidor en el puerto especificado
            ServerSocket server = new ServerSocket(serverPort);
            do {
                //hacer un ciclo infinito para aceptar conexiones entrantes
                Socket client = server.accept();
                //crear un hilo nuevo para cada conexión
                (new ServerThread(client)).start();
            } while(true);
        } catch(IOException ex) {
            System.exit(0);
        }
    }
}

class ServerThread extends Thread {
    Socket client;
    //almacenar una referencia al socket en el que
    //está  conectado el cliente
    public ServerThread(Socket client) {
        this.client = client;
    }
    //este es el método inicial del hilo
    public void run() {
        try {
            //crea flujos para comunicarse con el cliente
            ServiceOutputStream outStream = new ServiceOutputStream(
                new BufferedOutputStream(client.getOutputStream()));
            ServiceInputStream inStream = new ServiceInputStream(client.getInputStream());
            //leer la solicitud del cliente en el flujo de entrada
            ServiceRequest request = inStream.getRequest();
            //procesar solicitudes del cliente y devolver la salida al cliente
            while (processRequest(outStream)) {};
        }catch(IOException ex) {
            System.exit(0);
        }
        try {
            client.close();
        }catch(IOException ex) {
            System.exit(0);
        }
    }
    //procesamiento de solicitudes
    public boolean processRequest(ServiceOutputStream outStream) {
        return false;
    }
}

//filtro de flujo de entrada
class ServiceInputStream extends FilterInputStream {
    public ServiceInputStream(InputStream in) {
        super(in);
    }
    //método para leer solicitudes de los clientes en el flujo de entrada
    public ServiceRequest getRequest() throws IOException {
        ServiceRequest request = new ServiceRequest();
        return request;
    }
}

//filtro de flujo de salida
class ServiceOutputStream extends FilterOutputStream {
    public ServiceOutputStream(OutputStream out) {
        super(out);
    }
}

//clase que implementa solicitudes del cliente
class ServiceRequest {
}
\end{minted}
\caption{Ejemplo de un servidor genérico multihilado.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

El programa servidor del gato, el cual lógicamente debe ejecutarse antes que los clientes para estar listo a recibir las conexiones. Es importante señalar que estos ejemplos no contienen más que una validación simple de las casillas ocupadas y el turno. No realiza por ejemplo, una validación para ver si alguno de los jugadores gano el juego.

\ejemplo

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
// Servidor de TicTacToe.
import java.awt.*;
import java.net.*;
import java.io.*;

public class TicTacToeServer extends Frame {
   private byte board[];
   private boolean xMove;
   private TextArea output;
   private Player players[];
   private ServerSocket server;
   private int numberOfPlayers;
   private int currentPlayer;

   public TicTacToeServer()
   {
      super( "Servidor Tic-Tac-Toe" );
      board = new byte[ 9 ];
      xMove = true;
      players = new Player[ 2 ];
      currentPlayer = 0;
 
      try {
         server = new ServerSocket( 5000, 2 );
      }
      catch( IOException e ) {
         e.printStackTrace();
         System.exit( 1 );
      }

      output = new TextArea();
      add( "Center", output );
      resize( 300, 300 );
      show();
   }

   // espera por dos conexiones de los clientes
   public void execute()
   {
      for ( int i = 0; i < players.length; i++ ) {
         try {
            players[ i ] =
               new Player( server.accept(), this, i );
            players[ i ].start();
            ++numberOfPlayers;
         }
         catch( IOException e ) {
            e.printStackTrace();
            System.exit( 1 );
         }
      }
   }
   
   public int getNumberOfPlayers() {
 return numberOfPlayers;
   }

   public void display( String s )
   {
      output.appendText( s + "\n" );
   }
 
   public synchronized boolean validMove( int loc, int player )
   {
      boolean moveDone = false;

      while ( player != currentPlayer ) {
         try {
            wait();
         }
         catch( InterruptedException e ) {
         }
      }

      if ( !isOccupied( loc ) ) {
         board[ loc ] =
            (byte)( currentPlayer == 0 ? 'X' : 'O' );
         currentPlayer = ++currentPlayer % 2;
         players[ currentPlayer ].otherPlayerMoved( loc );
         notify();    // indicar al jugador en espera que continúe
         return true;
      }
      else 
         return false;
   }

   public boolean isOccupied( int loc )
   {
      if ( board[ loc ] == 'X' || board [ loc ] == 'O' )
          return true;
      else
          return false;
   }

   public boolean gameOver()
   {
      return false;
   }

   public boolean handleEvent( Event event )
   {
      if ( event.id == Event.WINDOW_DESTROY ) {
         hide();
         dispose();

         for ( int i = 0; i < players.length; i++ )
            players[ i ].stop();

         System.exit( 0 );
      }

      return super.handleEvent( event );
   }

   public static void main( String args[] )
   {
      TicTacToeServer game = new TicTacToeServer();

      game.execute();
   }
}

class Player extends Thread {
   Socket connection;
   DataInputStream input;
   DataOutputStream output;
   TicTacToeServer control;
   int number;
   char mark;

   public Player( Socket s, TicTacToeServer t, int num )
   {
      mark = ( num == 0 ? 'X' : 'O' );

      connection = s;
      
      try {
         input = new DataInputStream(
                    connection.getInputStream() );
         output = new DataOutputStream(
                    connection.getOutputStream() );
      }
      catch( IOException e ) {
         e.printStackTrace();
         System.exit( 1 );
      }

      control = t;
      number = num;
   }

   public void otherPlayerMoved( int loc )
   {
      try {
         output.writeUTF( "El oponente movio" );
         output.writeInt( loc );
      }
      catch ( IOException e ) {}
   }

   public void run()
   {
      boolean done = false;

      try {
         control.display( "Jugador " +
            ( number == 0 ? 'X' : 'O' ) + " conectado" );
         output.writeChar( mark );
         output.writeUTF( "Jugador " +
            ( number == 0 ? "X conectado\n" :
                            "O conectado, espere un momento\n" ) );

         if ( control.getNumberOfPlayers() < 2 ) {
            output.writeUTF( "Esperando otro jugador" );

            while (control.getNumberOfPlayers() < 2 )
               ; 

            output.writeUTF(
               "Ya se conectó otro jugador. Es tu turno." );
         }

         while ( !done ) {
            int location = input.readInt();

            if ( control.validMove( location, number ) ) {
               control.display( "pos: " + location );
               output.writeUTF( "Movida válida." );
            }
            else 
               output.writeUTF( "Movida inválida, intente de nuevo" );

            if ( control.gameOver() )
               done = true;
         }         
         connection.close();
      }
      catch( IOException e ) {
         e.printStackTrace();
         System.exit( 1 );
      }
   }
}
\end{minted}
\caption{Ejemplo - Servidor de TicTacToe.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}




\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%






%\section*{Acknowledgments}
%\noindent Delete if not applicable\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Acknowledgments not required
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%ajustando encabezado para Referencias y apéndices
%\pagestyle{fancy}
%\fancyhf{}
\rhead{\textcolor{blue}{\textbf{Notas de Programación Orientada a Objetos}} }  %\\ \leftmark}

%\lfoot{Página \thepage}
%\rfoot{\textcolor{blue}{Carlos Alberto Fernández y Fernández}}
%\cfoot{\\ - \thepage \hspace{1pt} / \pageref{LastPage} -}
%\renewcommand{\footrulewidth}{1pt}
%%%


\chapter*{Referencias}
\addcontentsline{toc}{chapter}{Referencias}
\bibliographystyle{techpubs}
\bibliography{References}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Please use the techpubs BibTeX style when compiling bibliography, or follow the instructions on tinyurl.com/techpubsnist to format your .bib / .bbl file appropriately.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\chapter*{Apéndice A. Herramientas adicionales sugeridas }
\addcontentsline{toc}{chapter}{Apéndice A}

%%%%%%%%%%
% JAVA
%%%%%%%%%%
\ifjava
\section*{BlueJ} \label{bluej}

BlueJ \footnote{Ver: \url{http://www.bluej.org/}} es un programa desarrollado por la universidades de \textit{Kent} y \textit{Deakin} para ayudar a los estudiantes a entender programación orientada a objetos en Java, particularmente ayuda a entender la herencia.

A partir de un diagrama de clases, BlueJ puede generar el código básico de la clase en Java, el cuál puede ser editado y compilado conforme las necesidades del programa. El programa es básico -ver figura \ref{bl} - y fácil de usar permitiendo entender estructuras complejas en las relaciones de herencia.

\begin{figure}
    \centering
    \includegraphics[scale=.7]{imagenes/BlueJ.png}
    \caption{ Interface de BlueJ }
    \label{fig:bluej}
\end{figure}	

El código Java generado por BlueJ para el diagrama de la figura anterior es el siguiente:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
/**
 * Write a description of class Vehiculo here.
 * 
 * @author (your name) 
 * @version (a version number or a date)
 */
public class Vehiculo
{
	// instance variables - replace the example below with your own
	private int x;

	/**
	 * Constructor for objects of class Vehiculo
	 */
	public Vehiculo()
	{
		// initialise instance variables
		x = 0;
	}

	/**
	 * An example of a method - replace this comment with your own
	 * 
	 * @param  y   a sample parameter for a method
	 * @return     the sum of x and y 
	 */
	public int sampleMethod(int y)
	{
		// put your code here
		return x + y;
	}
}



/**
 * Write a description of class Camion here.
 * 
 * @author (your name) 
 * @version (a version number or a date)
 */
public class Camion extends Vehiculo
{
	// instance variables - replace the example below with your own
	private int x;

	/**
	 * Constructor for objects of class Camion
	 */
	public Camion()
	{
		// initialise instance variables
		x = 0;
	}

	/**
	 * An example of a method - replace this comment with your own
	 * 
	 * @param  y   a sample parameter for a method
	 * @return     the sum of x and y 
	 */
	public int sampleMethod(int y)
	{
		// put your code here
		return x + y;
	}
}
\end{minted}
\caption{Ejemplo de código generado por BlueJ.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

\fi
%%%%%%%%%%
% JAVA_END
%%%%%%%%%%

%%%%%%%%%%
% CPP
%%%%%%%%%%
\ifcpp
\newpage
\section*{UMLGEC++}

El proyecto de desarrollo de esta herramienta CASE (UMLGEC ++)\cite{rumbaugh1991object, matias2003herramienta} soporta la notación UML\footnote{Información básica sobre UML puede ser vista en \cite{fernandez2002modelado}} para diagramas de clase y generación de código en C++, con una interfaz lo más completa y sencilla posible, ver figura \ref{fig:umlgec}. Siendo útil para entender gráficamente conceptos básicos de objetos y su correspondiente implementación en código. Los elementos de este software son:

\begin{itemize}
\item Depósito de datos
\item Módulo para Creación de Diagramas y Modelado 
\item Generador de código
\item Analizador de sintaxis
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[scale=.5]{imagenes/UMLGEC.png}
    \caption{ Herramienta CASE UMLGEC++ }
    \label{fig:umlgec}
\end{figure}

De la generación de código se puede decir:


\begin{itemize}
\item A partir del diagrama se genera la estructura de las clases.
\item Se crean automáticamente: el constructor, el constructor de copia, el operador de asignación, las operaciones de igualdad y el destructor. 
\item Todos los atributos y asociaciones son establecidos como privados independientemente de la visibilidad establecida por el usuario, pero el acceso a ellos está permitido mediante operaciones \textit{get} y \textit{set} generadas automáticamente para cada atributo o asociación, las cuáles adquieren la visibilidad correspondiente al atributo  o asociación al que hacen referencia.
\item Se definen los cuerpos de las operaciones \textit{get} y \textit{set}, como funciones \textit{inline}.
\end{itemize}
    
\fi
%%%%%%%%%%
% CPP_END
%%%%%%%%%%





%%%%%%%%%%
% DRAFT
%%%%%%%%%%
\ifdraft
\newpage


\chapter{Temas pendientes}
\subsection{Decoradores en Python}

\subsubsection{¿Qué son?}

Los decoradores (\textit{decorators}) son una forma de envolver una función, como envolver un paquete con papel de regalo. Estos añaden funcionalidad a la función siendo decorada. Toman otra función como entrada y devuelven una nueva función modificada. 

\subsubsection{¿Por qué usarlos?}
Cuando se necesita código en nuestros programas que se va a ejecutar frecuentemente, podemos poner ese código en un decorador.

Pueden ser utilizados para aplicar cambios en una función existente sin tener que modificar su código. Esto separa el código adicional de la función principal y, si el código adicional no se necesita más, podemos simplemente remover el decorador.

\subsubsection{¿Cómo se escriben los decoradores?}
Se escribe una función decorada que toma a otra función cómo argumento.
Dentro de la función decoradora se escribe una función interna que contiene el código adicional, ejecuta el argumento de la función. son aplicados a una función utilizando el símbolo ''@'' seguido del nombre del decorador. Los decoradores son una forma de "meta-programación" ya que permiten modificar el comportamiento de una función en tiempo de ejecución.
Se regresa la función interna.

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
import datetime

def registrar_hora(funcion):
    def envoltorio(*args, **kwargs):
        print(f"[{datetime.datetime.now()}] Se ejecutó la función {funcion.__name__}")
        return funcion(*args, **kwargs)
    return envoltorio

@registrar_hora
def mi_funcion():
    print("Hola mundo!")

mi_funcion()

\end{minted}
\caption{Ejemplo de uso de decoradores.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo se define la función decoradora \textit{registrar\_hora} que toma como parámetro una función y devuelve una nueva función \textit{envoltorio} que imprime la hora actual y el nombre de la función que se esta ejecutando antes de llamar a la función original y devolver su resultado. Se aplica el decorador a la función \textit{mi\_funcion} usando el símbolo ''@'' antes de su declaración y se ejecuta la función \textit{mi\_funcion}, la cual imprimirá ''Hola mundo!'' y también la hora en la que se ejecutó la función.


Otros ejemplos:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
import time

def temporizador(func):
    def envoltorio(*args, **kwargs):
        inicio = time.time()
        resultado = func(*args, **kwargs)
        fin = time.time()
        print(f"La función {func.__name__} tardó {fin - inicio} 
          segundos en ejecutarse.")
        return resultado
    return envoltorio

@temporizador
def funcion_lenta():
    time.sleep(1)

funcion_lenta()

\end{minted}
\caption{Ejemplo de decorador para medir tiempo de ejecución de una función.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En el ejemplo entarior, la función decoradora \textit{temporizador} toma otra función como argumento y devuelve una nueva función \textit{envoltorio} que mide el tiempo de ejecución de la función original y lo imprime antes de devolver el resultado. La función \textit{funcion\_lenta} simula una tarea que dura 1 segundo. Al llamar a esta función se imprimirá ''La función funcion\_lenta tardó 1.0 segundos en ejecutarse.''

Otro ejemplo seria el siguiente:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {java}
def asegurar_primer_arg_es(val):
    def interno(fn):
        def envoltorio(*args, **kwargs):
            if args and args[0] != val:
                return f"El primer argumento no es {val}"
            return fn(*args, **kwargs)
        return envoltorio
    return interno

@asegurar_primer_arg_es("pizza")
def comida_fav(*comidas):
    return comidas

print(comida_fav("pizza", "helado")) # imprime ("pizza", "helado")
print(comida_fav("helado", "pizza")) # imprime "El primer argumento no es pizza"

\end{minted}
\caption{Ejemplo de decorador que verifica un argumento.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo se define la función decoradora \textit{asegurar\_primer\_arg\_es} que toma un valor y devuelve una nueva función \textit{interno} que a su vez toma otra función como argumento y devuelve una nueva función \textit{envoltorio} que verifica si el primer argumento de la función original es igual al valor especificado, si no es así devuelve un mensaje de error, si es así ejecuta la función original. Se aplica este decorador a la función \textit{comida\_fav} y se llama a esta función con diferentes argumentos, si el primer argumento es ''pizza'' se ejecuta normalmente, si no se imprime el mensaje de error.

\subsubsection{Decoradores predefinidos más comunes\protect\footnote{Partes de esta sección fueron desarrollados con apoyo de ChatGPT}}

Algunos decoradores usados con frecuencia:

\begin{itemize}
\item dataclass. Éste decorador  se utiliza para crear clases de datos de manera rápida y sencilla. Al aplicar @dataclass a una clase, Python automáticamente genera ciertos métodos para la clase.
\item property. Éste decorador se utiliza para definir un método como una propiedad de una clase, lo que permite acceder al método como si fuera un atributo.
\item staticmethod. Éste decorador se utiliza para definir un método estático, que no tiene acceso a los atributos de la clase o de la instancia.
\item classmethod. Éste decorador se utiliza para definir un método como un método de clase, lo que permite acceder al método a través de la clase en lugar de a través de una instancia.
\item abstractmethod. Éste decorador se utiliza para definir un método abstracto en una clase abstracta. Los métodos abstractos son métodos que deben ser implementados por las subclases.
\end{itemize}

Al final, un decorador es únicamente una función con código en ésta.

\subsubsection{@dataclass}

@dataclass es un decorador de Python 3.7 que es parte de la biblioteca estándar, se utiliza para crear clases de datos de manera rápida y sencilla.

Al aplicar @dataclass a una clase, Python automáticamente genera ciertos métodos para la clase, como  las funciones especiales \textit{init}, \textit{repr} y \textit{eq} , así como también agrega la clase al módulo \textit{dataclasses}.

Además, permite especificar los atributos de clase mediante la creación de variables de instancia con el decorador \textit{field}. Esto proporciona una manera fácil de especificar los atributos de clase y también proporciona una forma de especificar opciones adicionales como el valor predeterminado, si el campo es inmutable, etc.

Un ejemplo de uso de @dataclass se muestra a continuación:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
from dataclasses import dataclass

@dataclass
class Persona:
    nombre: str
    fecha_nacimiento: str
    genero: str

p1 = Persona("Juan", "01/01/2000", "Masculino")
p2 = Persona("Maria", "01/01/1995", "Femenino")

print(p1) # Persona(nombre='Juan', fecha_nacimiento='01/01/2000', genero='Masculino')
print(p2) # Persona(nombre='Maria', fecha_nacimiento='01/01/1995', genero='Femenino')

\end{minted}
\caption{Ejemplo de @dataclass.}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo, se utiliza @dataclass para definir la clase Persona, y se utilizan los tipos de datos básicos de Python para especificar los atributos de la clase. Al imprimir las instancias de Persona, se puede ver que @dataclass ha generado automáticamente un método de representación legible de la instancia.

Otro ejemplo se muestre enseguida:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
from dataclasses import dataclass, field

@dataclass
class Alumno:
    nombre: str
    edad: int =18
    notas: list = field(default_factory=list)

    def mostrar_notas(self):
        print(self.notas)
        
# Crear una instancia de Alumno
alumno1 = Alumno("Juan")

# Acceder a los atributos
print(alumno1.nombre) # "Juan"
print(alumno1.edad) # 18

# Modificar el valor de un atributo
alumno1.edad = 20

# Agregar una nota
alumno1.notas.append(10)

# Genera una representación legible de la instancia
print(alumno1) # Alumno(nombre='Juan', edad=20, notas=[10])

# Comparar dos instancias de Alumno
alumno2 = Alumno("Juan", 20, [10])
print(alumno1 == alumno2) # True
alumno1.mostrar_notas() # [10]

\end{minted}
\caption{Ejemplo adicional de @dataclass .}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo se tiene una clase Alumno la cual tiene lo campos nombre, edad y notas. El campo notas se inicializa con una lista vacía.

Al crear una instancia de la clase Alumno (alumno1 = Alumno("Juan")), se genera automáticamente un método especial \textit{init} que asigna los valores de los atributos nombre, edad y notas a los valores especificados al crear la instancia. También se genera un método especial repr que permite generar una representación legible de la instancia y un método especial eq que permite comparar dos instancias de la clase para ver si son iguales. En este caso también se agregó un método mostrar\_notas para mostrar las notas del alumno

Se uso la función field(). field() es una función decoradora incluida en el módulo dataclasses de Python. Se utiliza para especificar ciertas opciones para los campos de una clase de datos. Cuando se aplica a un atributo de una clase, indica que ese atributo es un campo y se debe tratar de manera especial por el decorador dataclass.

Los argumentos opcionales que se pueden pasar a la función field() son:

default: especifica un valor por defecto para el campo.
default_factory: especifica una función que se ejecutará para calcular el valor por defecto del campo.
init: indica si el campo debe ser incluido en el constructor de la clase. Por defecto es True.
repr: indica si el campo debe ser incluido en la representación legible de la instancia. Por defecto es True.
compare: indica si el campo debe ser comparado al comparar dos instancias de la clase. Por defecto es True.
hash: indica si el campo debe ser incluido en el cálculo del valor hash de la instancia. Por defecto es True.

field() es una forma de personalizar cómo se comporta la clase con el decorador dataclass. Sin embargo, no es necesario utilizar field() en cada atributo de una clase decorada con dataclass, ya que por defecto se consideran todos los atributos como campos con las opciones por defecto.


Por otro lado, al momento de usar el decorador, es posible pasar algunos parámetros. Los parámetros posibles que se pueden pasar a la decoración @dataclass son:

init: indica si se debe generar automáticamente un constructor para la clase. Por defecto es True.
eq: indica si se debe generar automáticamente el método __eq__ para la clase. Por defecto es True.
order: indica si se deben generar automáticamente los métodos __lt__, __le__, __gt__ y __ge__ para la clase. Por defecto es False.
unsafe_hash: indica si se debe generar automáticamente el método __hash__ para la clase. Por defecto es False.
frozen: indica si se deben congelar los atributos de la clase, es decir, no se podrán modificar una vez que se ha creado una instancia de la clase. Por defecto es False.
Es importante mencionar que estos parámetros solo se pueden pasar al momento de usar la decoración @dataclass, no en la definición de la clase.

Un ejemplo usando algunos de los parámetros de dataclass:

%longlist  para potencialmente grandes codigos fuentes
\begin{longlisting}
\begin{minted}
    [frame=lines,
framesep=2mm,
baselinestretch=1.2,
bgcolor=lightgray,
fontsize=\footnotesize]
    {python}
from dataclasses import dataclass, asdict

# Creando una clase con parámetros
@dataclass(frozen=True, order=True)
class Persona:
    nombre: str
    edad: int
    altura: float
    
# Creando una instancia de Persona
p1 = Persona("Juan", 25, 1.75)

# Imprimiendo una representación legible de la instancia
print(p1)

# Modificando un valor de una atributo, genera un error ya que la clase esta congelada
# p1.edad = 30

# Generando un diccionario a partir de la instancia
print(asdict(p1))

# Comparando dos instancias de Persona
p2 = Persona("Pedro", 30, 1.80)
print(p1 < p2)

\end{minted}
\caption{Ejemplo .}
% \caption[Long Code Example]{A long code example which will break across pages.}
\label{listing:1}
\end{longlisting}

En este ejemplo se está utilizando el parámetro \textit{frozen=True} para congelar la clase, lo que significa que no se pueden modificar los valores de los atributos una vez que se ha creado una instancia. También se está utilizando el parámetro \textit{order=True} para habilitar la comparación entre instancias de la clase. Además se utiliza \textit{asdict} para generar un diccionario a partir de una instancia de la clase.



\subsection{Python Generators}

¿Qué son los generadores?

Los generadores nos permiten escribir funciones eficientes que puedan actuar como iteradores, por ejemplo, pueden usarse en un ciclo $for$. 
Cualquier función que regresa un iterador puede convertirse a un generador usando la palabra reservada $yield$.

¿Cómo escribir un generador?

Cualquier función que regresa un iterador puede convertirse a un generador usando la palabra reservada $yield$.

En el primer ejemplo, regresamos una lista conteniendo cubos de números hasta el 50 al mismo tiempo.

<ejemplo>

En el segundo ejemplo cedemos ($yield$) el siguiente cubo bajo demanda

<ejemplo>

¿Por qué usar generadores?
Son limpios y hacen uso eficiente de memoria.

Del ejemplo anterior imaginemos la diferencia entre tener que crear y mantener una lista de cubos de 50 números al mismo tiempo contra únicamente regresar el siguiente valor bajo demanda.

¿Cuando usar generadores?

Cuando sea necesario ahorrar memoria.

Si se está inseguro si todos los elementos en un iterador no van a ser usados.


\subsection{Python Sys y OS}
\subsection{Python- Shelves}
\subsection{Python - Persistence}
\subsection{Python - GUI - PySimpleGUI}
https://twitter.com/driscollis/status/1570115002249498646
\subsection{Python - GUI - tkinter}




%Temas de MTCA POO
\section{Envío múltiple (Multiple dispatch}

\Chapter{6 Encapsulamiento}
\section{Principios de encapsulamiento}
\section{Patrón de diseño proxy}
\section{Modelado y construcción de componentes}


\fi
%%%%%%%%%%
% DRAFT_END
%%%%%%%%%%


\end{document}
